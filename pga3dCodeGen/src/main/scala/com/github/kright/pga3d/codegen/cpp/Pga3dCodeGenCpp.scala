package com.github.kright.pga3d.codegen.cpp

import com.github.kright.pga3d.codegen.common.FileContent
import com.github.kright.pga3d.codegen.cpp.ops.*

import java.nio.file.{Files, Path}


@main
def runCppCodeGen(): Unit = {
  new Pga3dCodeGenCpp(
    directory = Path.of("cpp/pga3d"),
    namespace = "pga3d",
  ).generateAll()

  CustomAmalgamate.fuseMath()
  CustomAmalgamate.fusePhysicsWithMath()
}


class Pga3dCodeGenCpp(val directory: Path,
                      val namespace: String) {
  assert(Files.exists(directory))

  object Headers {
    val typesForward = "typesForward.h"
    val types = "types.h"
    val pga3d = "pga3d.h"
  }

  private val codeGenerators = Seq(
    new StructFieldsGenerator,
    new StructStaticConstructorGenerator,

    new TranslatorWithQuaternionGenerator,

    new QuaternionOpsGenerator,
    new TranslatorOpsGenerator,
    new MotorOpsGenerator,
    new BivectorOpsGenerator,
    new BivectorBulkOpsGenerator,
    new BivectorWeightOpsGenerator,
    new PointOpsGenerator,
    new VectorOpsGenerator,

    new DualOpGenerator,
    new WeightOpGenerator,
    new BulkOpGenerator,
    new ReverseOpGenerator,
    new AntiReverseOpGenerator,
    new ConversionOpGenerator,
    new ArithmeticsGenerator,
    new NormOpGenerator,
    new ToStreamOpGenerator,
    new ProjectionOpsGenerator,
    new GeometricOpsGenerator,
  )

  def generateAll(): Unit = {
    generateStructForwardDeclarations().writeWithLogging()
    generateStructHeadersAggregation().writeWithLogging()

    for (cls <- CppSubclasses.all if cls.shouldBeGenerated) {
      val code = generateStructHeader(cls)
      val fileContent = FileContent(directory.resolve(s"${cls.name}.h"), code)
      fileContent.writeWithLogging()
    }

    val ops = codeGenerators.flatMap(_.generateFiles(this))
    ops.foreach(_.writeWithLogging())
    generatePga3d(ops).writeWithLogging()
  }

  private def generateStructForwardDeclarations(): FileContent = {
    val codeGen = new CppCodeBuilder()

    codeGen.myHeader(Seq(), getClass.getName)

    codeGen.namespace(namespace) {
      for (cls <- CppSubclasses.all if cls.shouldBeGenerated) {
        codeGen(s"struct ${cls.name};")
      }
      codeGen(s"struct ${TranslatorWithQuaternionGenerator.quaternionWithTranslator};")
      codeGen(s"struct ${TranslatorWithQuaternionGenerator.translatorWithQuaternion};")
    }

    FileContent(directory.resolve(Headers.typesForward), codeGen.toString)
  }

  private def generatePga3d(ops: Seq[FileContent]): FileContent = {
    val code = new CppCodeBuilder()

    val includes = Seq("#include \"types.h\"") ++ ops.map { op => s"#include \"${op.path.getFileName}\"" }
    code.myHeader(includes, getClass.getName)

    FileContent(directory.resolve(Headers.pga3d), code.toString)
  }

  private def generateStructHeadersAggregation(): FileContent = {
    val codeGen = new CppCodeBuilder()

    val includes =
      for (cls <- CppSubclasses.all if cls.shouldBeGenerated)
        yield s"#include \"${cls.name}.h\""

    val additionalIncludes = s"#include \"${TranslatorWithQuaternionGenerator.translatorWithQuaternion}.h\""

    codeGen.myHeader(includes :+ additionalIncludes, getClass.getName)

    FileContent(directory.resolve(Headers.types), codeGen.toString)
  }

  private def generateStructHeader(cls: CppSubclass): String = {
    val codeGen = new CppCodeBuilder()

    val structBodyParts = codeGenerators.flatMap(_.generateStructBody(cls))

    val includes: Seq[String] =
      (Seq("<type_traits>", "\"typesForward.h\"") ++ structBodyParts.flatMap(_.includes))
        .distinct.sorted.sortBy(s => if (s.startsWith("\"")) 1 else 0)
        .map(incl => s"#include $incl")

    codeGen.myHeader(includes, getClass.getName)

    codeGen.namespace(namespace) {
      codeGen.struct(cls.name) {
        codeGen(
          structBodyParts
            .filter(_.structCode.nonEmpty)
            .map(sc => s"// generated by ${sc.sourceGenerator.getClass.getName}\n\n${sc.structCode}")
            .mkString("\n\n")
        )
      }

      codeGen("")
      codeGen(s"static_assert(std::is_trivially_copyable_v<${cls.name}>);")

      if (cls.variableFields.nonEmpty) {
        codeGen(s"static_assert(sizeof(${cls.name}) == 8 * ${cls.name}::componentsCount, \"${cls.name} must be exactly ${8 * cls.variableFields.size} bytes\");")
      }
    }

    codeGen.toString()
  }
}
