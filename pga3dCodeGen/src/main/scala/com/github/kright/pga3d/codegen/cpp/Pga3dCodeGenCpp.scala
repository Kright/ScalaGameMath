package com.github.kright.pga3d.codegen.cpp

import com.github.kright.pga3d.codegen.common.FileContent
import com.github.kright.pga3d.codegen.cpp.binops.*
import com.github.kright.pga3d.codegen.cpp.struct.*

import java.nio.file.{Files, Path}


@main
def main(): Unit = {
  new Pga3dCodeGenCpp(
    directory = Path.of("cpp/pga3d"),
    namespace = "pga3d",
  ).generateAll()

  CustomAmalgamate.fuse()
}



class Pga3dCodeGenCpp(val directory: Path,
                      val namespace: String) {
  assert(Files.exists(directory))

  object Headers {
    val typesForward = "typesForward.h"
    val types = "types.h"
    val pga3d = "pga3d.h"
  }

  private val structCodeGenerators = Seq(
    new StructFieldsGenerator,
    new StructStaticConstructorGenerator,
  )

  private val binopCodeGenerators = Seq(
    new QuaternionOpsGenerator,
    new TranslatorOpsGenerator,
    new MotorOpsGenerator,
    new BivectorOpsGenerator,
    new BivectorBulkOpsGenerator,
    new BivectorWeightOpsGenerator,
    new PointOpsGenerator,
    new VectorOpsGenerator,
    
    new DualOpGenerator,
    new WeightOpGenerator,
    new BulkOpGenerator,
    new ReverseOpGenerator,
    new AntiReverseOpGenerator,
    new ConversionOpGenerator,
    new ArithmeticsGenerator,
    new NormOpGenerator,
    new ToStreamOpGenerator,
    new ProjectionOpsGenerator,
  ) ++ GeometricOpsGenerators.all

  def generateAll(): Unit = {
    generateStructForwardDeclarations().write()
    generateStructHeadersAggregation().write()

    for (cls <- CppSubclasses.all if cls.shouldBeGenerated) {
      val code = generateStructHeader(cls)
      Files.writeString(directory.resolve(s"${cls.name}.h"), code)
    }

    val ops = binopCodeGenerators.map(_.generateBinopCode(this))
    ops.foreach(_.write())
    generatePga3d(ops).write()
  }

  private def generateStructForwardDeclarations(): FileContent = {
    val codeGen = new CppCodeGen()

    codeGen("#pragma once")
    codeGen("")
    codeGen.namespace(namespace) {
      for (cls <- CppSubclasses.all if cls.shouldBeGenerated) {
        codeGen(s"struct ${cls.name};")
      }
    }

    FileContent(directory.resolve(Headers.typesForward), codeGen.toString)
  }

  private def generatePga3d(ops: Seq[FileContent]): FileContent = {
    val code = new CppCodeGen()

    val includes = Seq("#include \"types.h\"") ++ ops.map{ op =>s"#include \"${op.path.getFileName}\""}
    code.myHeader(includes, getClass.getName)

    FileContent(directory.resolve(Headers.pga3d), code.toString)
  }

  private def generateStructHeadersAggregation(): FileContent = {
    val codeGen = new CppCodeGen()

    codeGen("#pragma once")
    codeGen("")

    for (cls <- CppSubclasses.all if cls.shouldBeGenerated) {
      codeGen(s"#include \"${cls.name}.h\"")
    }

    FileContent(directory.resolve(Headers.types), codeGen.toString)
  }

  private def generateStructHeader(cls: CppSubclass): String = {
    val codeGen = new CppCodeGen()

    val includes: Seq[String] =
      (Seq("<type_traits>", "\"typesForward.h\"") ++ (structCodeGenerators ++ binopCodeGenerators).flatMap(_.includes(cls)))
        .distinct.sorted.sortBy(s => if (s.startsWith("\"")) 1 else 0)
        .map(incl => s"#include $incl")

    codeGen.myHeader(includes, getClass.getName)

    codeGen.namespace(namespace) {
      codeGen.struct(cls.name) {
        codeGen((structCodeGenerators ++ binopCodeGenerators)
          .map(g => g -> g.structCode(cls))
          .filter(_._2.nonEmpty)
          .map((g, s) => s"// generated by ${g.getClass.getName}\n\n$s")
          .mkString("\n\n"))
      }

      codeGen("")
      codeGen(s"static_assert(std::is_trivially_copyable_v<${cls.name}>);")

      if (cls.variableFields.nonEmpty) {
        codeGen(s"static_assert(sizeof(${cls.name}) == 8 * ${cls.name}::componentsCount, \"${cls.name} must be exactly ${8 * cls.variableFields.size} bytes\");")
      }
    }

    codeGen.toString()
  }
}
