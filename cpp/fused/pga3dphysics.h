// Copyright (c) 2025 Igor Slobodskov
// SPDX-License-Identifier: MIT

#pragma once

#include <algorithm>
#include <array>
#include <cmath>
#include <ostream>
#include <span>
#include <type_traits>
#include <utility>
#include <vector>

// generated by com.github.kright.pga3d.codegen.cpp.CustomAmalgamate

// typesForward.h

// generated by com.github.kright.pga3d.codegen.cpp.Pga3dCodeGenCpp

namespace pga3d {
    struct Multivector;
    struct Motor;
    struct Plane;
    struct Bivector;
    struct ProjectivePoint;
    struct Quaternion;
    struct ProjectiveTranslator;
    struct Translator;
    struct Vector;
    struct Point;
    struct PlaneIdeal;
    struct BivectorBulk;
    struct BivectorWeight;
    struct PseudoScalar;
    struct PointCenter;
    struct QuaternionWithTranslator;
    struct TranslatorWithQuaternion;
}

// Multivector.h

// generated by com.github.kright.pga3d.codegen.cpp.Pga3dCodeGenCpp

namespace pga3d {
    struct Multivector {
        // generated by com.github.kright.pga3d.codegen.cpp.ops.StructFieldsGenerator

        double s = 0.0;
        double w = 0.0;
        double x = 0.0;
        double y = 0.0;
        double z = 0.0;
        double wx = 0.0;
        double wy = 0.0;
        double wz = 0.0;
        double xy = 0.0;
        double xz = 0.0;
        double yz = 0.0;
        double wxy = 0.0;
        double wxz = 0.0;
        double wyz = 0.0;
        double xyz = 0.0;
        double i = 0.0;

        static constexpr int componentsCount = 16;

        [[nodiscard]] constexpr std::array<double, componentsCount> toArray() const noexcept { return { s, w, x, y, z, wx, wy, wz, xy, xz, yz, wxy, wxz, wyz, xyz, i }; }
        [[nodiscard]] static constexpr Multivector from(const std::span<double, componentsCount>& values) noexcept { return { .s = values[0], .w = values[1], .x = values[2], .y = values[3], .z = values[4], .wx = values[5], .wy = values[6], .wz = values[7], .xy = values[8], .xz = values[9], .yz = values[10], .wxy = values[11], .wxz = values[12], .wyz = values[13], .xyz = values[14], .i = values[15] }; }

        // generated by com.github.kright.pga3d.codegen.cpp.ops.DualOpGenerator

        [[nodiscard]] constexpr Multivector dual() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.WeightOpGenerator

        [[nodiscard]] constexpr Multivector weight() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.BulkOpGenerator

        [[nodiscard]] constexpr Multivector bulk() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ReverseOpGenerator

        [[nodiscard]] constexpr Multivector reverse() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiReverseOpGenerator

        [[nodiscard]] constexpr Multivector antiReverse() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ConversionOpGenerator

        [[nodiscard]] constexpr Motor toMotorUnsafe() const noexcept;
        [[nodiscard]] constexpr Plane toPlaneUnsafe() const noexcept;
        [[nodiscard]] constexpr Bivector toBivectorUnsafe() const noexcept;
        [[nodiscard]] constexpr ProjectivePoint toProjectivePointUnsafe() const noexcept;
        [[nodiscard]] constexpr Quaternion toQuaternionUnsafe() const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator toProjectiveTranslatorUnsafe() const noexcept;
        [[nodiscard]] constexpr Translator toTranslatorUnsafe() const noexcept;
        [[nodiscard]] constexpr Vector toVectorUnsafe() const noexcept;
        [[nodiscard]] constexpr Point toPointUnsafe() const noexcept;
        [[nodiscard]] constexpr PlaneIdeal toPlaneIdealUnsafe() const noexcept;
        [[nodiscard]] constexpr BivectorBulk toBivectorBulkUnsafe() const noexcept;
        [[nodiscard]] constexpr BivectorWeight toBivectorWeightUnsafe() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ArithmeticsGenerator

        [[nodiscard]] constexpr Multivector madd(const Multivector& other, double mult) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.NormOpGenerator

        [[nodiscard]] constexpr double normSquare() const noexcept;
        [[nodiscard]] inline double norm() const noexcept;
        [[nodiscard]] inline Multivector normalizedByNorm() const noexcept;
        [[nodiscard]] constexpr double bulkNormSquare() const noexcept;
        [[nodiscard]] inline double bulkNorm() const noexcept;
        [[nodiscard]] inline Multivector normalizedByBulk() const noexcept;
        [[nodiscard]] constexpr double weightNormSquare() const noexcept;
        [[nodiscard]] inline double weightNorm() const noexcept;
        [[nodiscard]] inline Multivector normalizedByWeight() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.GeometricOpGenerator

        [[nodiscard]] constexpr Multivector geometric(const Multivector& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiGeometricOpGenerator

        [[nodiscard]] constexpr Multivector antiGeometric(const Multivector& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.DotOpGenerator

        [[nodiscard]] constexpr Multivector dot(const Multivector& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiDotOpGenerator

        [[nodiscard]] constexpr Multivector antiDot(const Multivector& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.WedgeOpGenerator

        [[nodiscard]] constexpr Multivector wedge(const Multivector& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiWedgeOpGenerator

        [[nodiscard]] constexpr Multivector antiWedge(const Multivector& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.SandwichOpGenerator

        [[nodiscard]] constexpr Multivector sandwich(const Multivector& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ReverseSandwichOpGenerator

        [[nodiscard]] constexpr Multivector reverseSandwich(const Multivector& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.CrossOpGenerator

        [[nodiscard]] constexpr Multivector cross(const Multivector& b) const noexcept;
    };

    static_assert(std::is_trivially_copyable_v<Multivector>);
    static_assert(sizeof(Multivector) == 8 * Multivector::componentsCount, "Multivector must be exactly 128 bytes");
}

// Motor.h

// generated by com.github.kright.pga3d.codegen.cpp.Pga3dCodeGenCpp

namespace pga3d {
    struct Motor {
        // generated by com.github.kright.pga3d.codegen.cpp.ops.StructFieldsGenerator

        double s = 0.0;
        double wx = 0.0;
        double wy = 0.0;
        double wz = 0.0;
        double xy = 0.0;
        double xz = 0.0;
        double yz = 0.0;
        double i = 0.0;

        static constexpr int componentsCount = 8;

        [[nodiscard]] constexpr std::array<double, componentsCount> toArray() const noexcept { return { s, wx, wy, wz, xy, xz, yz, i }; }
        [[nodiscard]] static constexpr Motor from(const std::span<double, componentsCount>& values) noexcept { return { .s = values[0], .wx = values[1], .wy = values[2], .wz = values[3], .xy = values[4], .xz = values[5], .yz = values[6], .i = values[7] }; }

        // generated by com.github.kright.pga3d.codegen.cpp.ops.MotorOpsGenerator

        [[nodiscard]] static constexpr Motor id() noexcept { return { .s = 1.0 }; };

        [[nodiscard]] static constexpr Motor addVector(const Vector& v) noexcept;

        [[nodiscard]] inline Bivector log() const noexcept;
        [[nodiscard]] inline Motor pow(double p) const noexcept;

        [[nodiscard]] constexpr QuaternionWithTranslator toQuaternionWithTranslator() const noexcept;
        [[nodiscard]] constexpr TranslatorWithQuaternion toTranslatorWithQuaternion() const noexcept;

        [[nodiscard]] inline Motor renormalized() const noexcept;

        [[nodiscard]] constexpr Vector axisX() const noexcept;
        [[nodiscard]] constexpr Vector axisY() const noexcept;
        [[nodiscard]] constexpr Vector axisZ() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.DualOpGenerator

        [[nodiscard]] constexpr Motor dual() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.WeightOpGenerator

        [[nodiscard]] constexpr Motor weight() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.BulkOpGenerator

        [[nodiscard]] constexpr Quaternion bulk() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ReverseOpGenerator

        [[nodiscard]] constexpr Motor reverse() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiReverseOpGenerator

        [[nodiscard]] constexpr Motor antiReverse() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ConversionOpGenerator

        [[nodiscard]] constexpr Multivector toMultivector() const noexcept;
        [[nodiscard]] constexpr Bivector toBivectorUnsafe() const noexcept;
        [[nodiscard]] constexpr Quaternion toQuaternionUnsafe() const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator toProjectiveTranslatorUnsafe() const noexcept;
        [[nodiscard]] constexpr Translator toTranslatorUnsafe() const noexcept;
        [[nodiscard]] constexpr BivectorBulk toBivectorBulkUnsafe() const noexcept;
        [[nodiscard]] constexpr BivectorWeight toBivectorWeightUnsafe() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ArithmeticsGenerator

        [[nodiscard]] constexpr Motor madd(const Motor& other, double mult) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.NormOpGenerator

        [[nodiscard]] constexpr double normSquare() const noexcept;
        [[nodiscard]] inline double norm() const noexcept;
        [[nodiscard]] inline Motor normalizedByNorm() const noexcept;
        [[nodiscard]] constexpr double bulkNormSquare() const noexcept;
        [[nodiscard]] inline double bulkNorm() const noexcept;
        [[nodiscard]] inline Motor normalizedByBulk() const noexcept;
        [[nodiscard]] constexpr double weightNormSquare() const noexcept;
        [[nodiscard]] inline double weightNorm() const noexcept;
        [[nodiscard]] inline Motor normalizedByWeight() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.GeometricOpGenerator

        [[nodiscard]] constexpr Motor geometric(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const Point& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiGeometricOpGenerator

        [[nodiscard]] constexpr Motor antiGeometric(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Motor antiGeometric(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Quaternion antiGeometric(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Motor antiGeometric(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Motor antiGeometric(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const Point& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Quaternion antiGeometric(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Motor antiGeometric(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr Motor antiGeometric(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.DotOpGenerator

        [[nodiscard]] constexpr Motor dot(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Multivector dot(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Motor dot(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Multivector dot(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Motor dot(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Motor dot(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Motor dot(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Multivector dot(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Multivector dot(const Point& b) const noexcept;
        [[nodiscard]] constexpr Multivector dot(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Motor dot(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight dot(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr Motor dot(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr Multivector dot(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiDotOpGenerator

        [[nodiscard]] constexpr Motor antiDot(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiDot(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Motor antiDot(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiDot(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Quaternion antiDot(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Motor antiDot(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Motor antiDot(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiDot(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiDot(const Point& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiDot(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk antiDot(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Motor antiDot(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr Motor antiDot(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiDot(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.WedgeOpGenerator

        [[nodiscard]] constexpr Motor wedge(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Multivector wedge(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Motor wedge(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint wedge(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Motor wedge(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Motor wedge(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Motor wedge(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Vector wedge(const Vector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint wedge(const Point& b) const noexcept;
        [[nodiscard]] constexpr Multivector wedge(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Motor wedge(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Motor wedge(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar wedge(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint wedge(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiWedgeOpGenerator

        [[nodiscard]] constexpr Motor antiWedge(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Plane antiWedge(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Motor antiWedge(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiWedge(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Quaternion antiWedge(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator antiWedge(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator antiWedge(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiWedge(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiWedge(const Point& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal antiWedge(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Quaternion antiWedge(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator antiWedge(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr Motor antiWedge(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiWedge(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.SandwichOpGenerator

        [[nodiscard]] constexpr Motor sandwich(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Plane sandwich(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Bivector sandwich(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint sandwich(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Motor sandwich(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Motor sandwich(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Motor sandwich(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Vector sandwich(const Vector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint sandwich(const Point& b) const noexcept;
        [[nodiscard]] constexpr Plane sandwich(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Bivector sandwich(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight sandwich(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar sandwich(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint sandwich(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ReverseSandwichOpGenerator

        [[nodiscard]] constexpr Motor reverseSandwich(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Plane reverseSandwich(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Bivector reverseSandwich(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint reverseSandwich(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Motor reverseSandwich(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Motor reverseSandwich(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Motor reverseSandwich(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Vector reverseSandwich(const Vector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint reverseSandwich(const Point& b) const noexcept;
        [[nodiscard]] constexpr Plane reverseSandwich(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Bivector reverseSandwich(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight reverseSandwich(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar reverseSandwich(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint reverseSandwich(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.CrossOpGenerator

        [[nodiscard]] constexpr Bivector cross(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Multivector cross(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Bivector cross(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Multivector cross(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Bivector cross(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight cross(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight cross(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Vector cross(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Multivector cross(const Point& b) const noexcept;
        [[nodiscard]] constexpr Multivector cross(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Bivector cross(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight cross(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr Multivector cross(const PointCenter& b) const noexcept;
    };

    static_assert(std::is_trivially_copyable_v<Motor>);
    static_assert(sizeof(Motor) == 8 * Motor::componentsCount, "Motor must be exactly 64 bytes");
}

// Plane.h

// generated by com.github.kright.pga3d.codegen.cpp.Pga3dCodeGenCpp

namespace pga3d {
    struct Plane {
        // generated by com.github.kright.pga3d.codegen.cpp.ops.StructFieldsGenerator

        double x = 0.0;
        double y = 0.0;
        double z = 0.0;
        double w = 0.0;

        static constexpr int componentsCount = 4;

        [[nodiscard]] constexpr std::array<double, componentsCount> toArray() const noexcept { return { x, y, z, w }; }
        [[nodiscard]] static constexpr Plane from(const std::span<double, componentsCount>& values) noexcept { return { .x = values[0], .y = values[1], .z = values[2], .w = values[3] }; }

        // generated by com.github.kright.pga3d.codegen.cpp.ops.DualOpGenerator

        [[nodiscard]] constexpr ProjectivePoint dual() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.WeightOpGenerator

        [[nodiscard]] constexpr Plane weight() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.BulkOpGenerator

        [[nodiscard]] constexpr PlaneIdeal bulk() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ReverseOpGenerator

        [[nodiscard]] constexpr Plane reverse() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiReverseOpGenerator

        [[nodiscard]] constexpr Plane antiReverse() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ConversionOpGenerator

        [[nodiscard]] constexpr Multivector toMultivector() const noexcept;
        [[nodiscard]] constexpr PlaneIdeal toPlaneIdealUnsafe() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ArithmeticsGenerator

        [[nodiscard]] constexpr Plane madd(const Plane& other, double mult) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.NormOpGenerator

        [[nodiscard]] constexpr double normSquare() const noexcept;
        [[nodiscard]] inline double norm() const noexcept;
        [[nodiscard]] inline Plane normalizedByNorm() const noexcept;
        [[nodiscard]] constexpr double bulkNormSquare() const noexcept;
        [[nodiscard]] inline double bulkNorm() const noexcept;
        [[nodiscard]] inline Plane normalizedByBulk() const noexcept;
        [[nodiscard]] constexpr double weightNormSquare() const noexcept;
        [[nodiscard]] inline double weightNorm() const noexcept;
        [[nodiscard]] inline Plane normalizedByWeight() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.GeometricOpGenerator

        [[nodiscard]] constexpr Multivector geometric(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const Point& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr Vector geometric(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiGeometricOpGenerator

        [[nodiscard]] constexpr Multivector antiGeometric(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Motor antiGeometric(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Motor antiGeometric(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Motor antiGeometric(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Motor antiGeometric(const Point& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk antiGeometric(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal antiGeometric(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr Plane antiGeometric(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr double antiGeometric(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.DotOpGenerator

        [[nodiscard]] constexpr Multivector dot(const Motor& b) const noexcept;
        [[nodiscard]] constexpr double dot(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Plane dot(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Bivector dot(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Plane dot(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Plane dot(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Plane dot(const Translator& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight dot(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Bivector dot(const Point& b) const noexcept;
        [[nodiscard]] constexpr double dot(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal dot(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Plane dot(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr Vector dot(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk dot(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiDotOpGenerator

        [[nodiscard]] constexpr Multivector antiDot(const Motor& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar antiDot(const Plane& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiDot(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Bivector antiDot(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiDot(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiDot(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiDot(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Bivector antiDot(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Bivector antiDot(const Point& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiDot(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr Plane antiDot(const PseudoScalar& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.WedgeOpGenerator

        [[nodiscard]] constexpr Multivector wedge(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Bivector wedge(const Plane& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint wedge(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar wedge(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Multivector wedge(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Multivector wedge(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Multivector wedge(const Translator& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar wedge(const Vector& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar wedge(const Point& b) const noexcept;
        [[nodiscard]] constexpr Bivector wedge(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint wedge(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Vector wedge(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar wedge(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiWedgeOpGenerator

        [[nodiscard]] constexpr Plane antiWedge(const Motor& b) const noexcept;
        [[nodiscard]] constexpr double antiWedge(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr double antiWedge(const Vector& b) const noexcept;
        [[nodiscard]] constexpr double antiWedge(const Point& b) const noexcept;
        [[nodiscard]] constexpr Plane antiWedge(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr double antiWedge(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.SandwichOpGenerator

        [[nodiscard]] constexpr Motor sandwich(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Plane sandwich(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Bivector sandwich(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint sandwich(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Motor sandwich(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator sandwich(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator sandwich(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Vector sandwich(const Vector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint sandwich(const Point& b) const noexcept;
        [[nodiscard]] constexpr Plane sandwich(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Bivector sandwich(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight sandwich(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar sandwich(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint sandwich(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ReverseSandwichOpGenerator

        [[nodiscard]] constexpr Motor reverseSandwich(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Plane reverseSandwich(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Bivector reverseSandwich(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint reverseSandwich(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Motor reverseSandwich(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator reverseSandwich(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator reverseSandwich(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Vector reverseSandwich(const Vector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint reverseSandwich(const Point& b) const noexcept;
        [[nodiscard]] constexpr Plane reverseSandwich(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Bivector reverseSandwich(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight reverseSandwich(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar reverseSandwich(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint reverseSandwich(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.CrossOpGenerator

        [[nodiscard]] constexpr Multivector cross(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Bivector cross(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Plane cross(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar cross(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal cross(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Plane cross(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Plane cross(const Translator& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar cross(const Vector& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar cross(const Point& b) const noexcept;
        [[nodiscard]] constexpr Bivector cross(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal cross(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Plane cross(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr Vector cross(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar cross(const PointCenter& b) const noexcept;
    };

    static_assert(std::is_trivially_copyable_v<Plane>);
    static_assert(sizeof(Plane) == 8 * Plane::componentsCount, "Plane must be exactly 32 bytes");
}

// Bivector.h

// generated by com.github.kright.pga3d.codegen.cpp.Pga3dCodeGenCpp

namespace pga3d {
    struct Bivector {
        // generated by com.github.kright.pga3d.codegen.cpp.ops.StructFieldsGenerator

        double wx = 0.0;
        double wy = 0.0;
        double wz = 0.0;
        double xy = 0.0;
        double xz = 0.0;
        double yz = 0.0;

        static constexpr int componentsCount = 6;

        [[nodiscard]] constexpr std::array<double, componentsCount> toArray() const noexcept { return { wx, wy, wz, xy, xz, yz }; }
        [[nodiscard]] static constexpr Bivector from(const std::span<double, componentsCount>& values) noexcept { return { .wx = values[0], .wy = values[1], .wz = values[2], .xy = values[3], .xz = values[4], .yz = values[5] }; }

        // generated by com.github.kright.pga3d.codegen.cpp.ops.BivectorOpsGenerator

        [[nodiscard]] inline std::pair<Bivector, BivectorWeight> split() const noexcept;

        [[nodiscard]] inline Motor exp() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.DualOpGenerator

        [[nodiscard]] constexpr Bivector dual() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.WeightOpGenerator

        [[nodiscard]] constexpr BivectorWeight weight() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.BulkOpGenerator

        [[nodiscard]] constexpr BivectorBulk bulk() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ReverseOpGenerator

        [[nodiscard]] constexpr Bivector reverse() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiReverseOpGenerator

        [[nodiscard]] constexpr Bivector antiReverse() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ConversionOpGenerator

        [[nodiscard]] constexpr Multivector toMultivector() const noexcept;
        [[nodiscard]] constexpr Motor toMotor() const noexcept;
        [[nodiscard]] constexpr Quaternion toQuaternionUnsafe() const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator toProjectiveTranslatorUnsafe() const noexcept;
        [[nodiscard]] constexpr Translator toTranslatorUnsafe() const noexcept;
        [[nodiscard]] constexpr BivectorBulk toBivectorBulkUnsafe() const noexcept;
        [[nodiscard]] constexpr BivectorWeight toBivectorWeightUnsafe() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ArithmeticsGenerator

        [[nodiscard]] constexpr Bivector madd(const Bivector& other, double mult) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.NormOpGenerator

        [[nodiscard]] constexpr double normSquare() const noexcept;
        [[nodiscard]] inline double norm() const noexcept;
        [[nodiscard]] inline Bivector normalizedByNorm() const noexcept;
        [[nodiscard]] constexpr double bulkNormSquare() const noexcept;
        [[nodiscard]] inline double bulkNorm() const noexcept;
        [[nodiscard]] inline Bivector normalizedByBulk() const noexcept;
        [[nodiscard]] constexpr double weightNormSquare() const noexcept;
        [[nodiscard]] inline double weightNorm() const noexcept;
        [[nodiscard]] inline Bivector normalizedByWeight() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ProjectionOpsGenerator

        [[nodiscard]] constexpr Bivector projectOntoPlane(const Plane& plane) const noexcept;
        [[nodiscard]] constexpr Bivector projectOntoPlane(const PlaneIdeal& plane) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.GeometricOpGenerator

        [[nodiscard]] constexpr Motor geometric(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const Point& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight geometric(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiGeometricOpGenerator

        [[nodiscard]] constexpr Motor antiGeometric(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Motor antiGeometric(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Quaternion antiGeometric(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Motor antiGeometric(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Motor antiGeometric(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const Point& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Quaternion antiGeometric(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Motor antiGeometric(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr Bivector antiGeometric(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal antiGeometric(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.DotOpGenerator

        [[nodiscard]] constexpr Motor dot(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Plane dot(const Plane& b) const noexcept;
        [[nodiscard]] constexpr double dot(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Plane dot(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Motor dot(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Bivector dot(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Bivector dot(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Plane dot(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Plane dot(const Point& b) const noexcept;
        [[nodiscard]] constexpr Plane dot(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr double dot(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight dot(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal dot(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiDotOpGenerator

        [[nodiscard]] constexpr Motor antiDot(const Motor& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiDot(const Plane& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar antiDot(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiDot(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk antiDot(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Motor antiDot(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Motor antiDot(const Translator& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiDot(const Vector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiDot(const Point& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiDot(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar antiDot(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr Bivector antiDot(const PseudoScalar& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.WedgeOpGenerator

        [[nodiscard]] constexpr Motor wedge(const Motor& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint wedge(const Plane& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar wedge(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Motor wedge(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Motor wedge(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Motor wedge(const Translator& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint wedge(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar wedge(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar wedge(const BivectorWeight& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiWedgeOpGenerator

        [[nodiscard]] constexpr Motor antiWedge(const Motor& b) const noexcept;
        [[nodiscard]] constexpr double antiWedge(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Plane antiWedge(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr double antiWedge(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr double antiWedge(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr double antiWedge(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Plane antiWedge(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Plane antiWedge(const Point& b) const noexcept;
        [[nodiscard]] constexpr double antiWedge(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr double antiWedge(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr Bivector antiWedge(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal antiWedge(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.SandwichOpGenerator

        [[nodiscard]] constexpr Motor sandwich(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Plane sandwich(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Bivector sandwich(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint sandwich(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Motor sandwich(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Motor sandwich(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Motor sandwich(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Vector sandwich(const Vector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint sandwich(const Point& b) const noexcept;
        [[nodiscard]] constexpr Plane sandwich(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Bivector sandwich(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight sandwich(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar sandwich(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint sandwich(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ReverseSandwichOpGenerator

        [[nodiscard]] constexpr Motor reverseSandwich(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Plane reverseSandwich(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Bivector reverseSandwich(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint reverseSandwich(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Motor reverseSandwich(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Motor reverseSandwich(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Motor reverseSandwich(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Vector reverseSandwich(const Vector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint reverseSandwich(const Point& b) const noexcept;
        [[nodiscard]] constexpr Plane reverseSandwich(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Bivector reverseSandwich(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight reverseSandwich(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar reverseSandwich(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint reverseSandwich(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.CrossOpGenerator

        [[nodiscard]] constexpr Bivector cross(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Plane cross(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Bivector cross(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Vector cross(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Bivector cross(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight cross(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight cross(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Vector cross(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Vector cross(const Point& b) const noexcept;
        [[nodiscard]] constexpr Plane cross(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Bivector cross(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight cross(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr Vector cross(const PointCenter& b) const noexcept;
    };

    static_assert(std::is_trivially_copyable_v<Bivector>);
    static_assert(sizeof(Bivector) == 8 * Bivector::componentsCount, "Bivector must be exactly 48 bytes");
}

// ProjectivePoint.h

// generated by com.github.kright.pga3d.codegen.cpp.Pga3dCodeGenCpp

namespace pga3d {
    struct ProjectivePoint {
        // generated by com.github.kright.pga3d.codegen.cpp.ops.StructFieldsGenerator

        double x = 0.0;
        double y = 0.0;
        double z = 0.0;
        double w = 0.0;

        static constexpr int componentsCount = 4;

        [[nodiscard]] constexpr double wyz() const noexcept { return -x; }
        [[nodiscard]] constexpr double wxz() const noexcept { return y; }
        [[nodiscard]] constexpr double wxy() const noexcept { return -z; }
        [[nodiscard]] constexpr double xyz() const noexcept { return w; }

        [[nodiscard]] constexpr std::array<double, componentsCount> toArray() const noexcept { return { x, y, z, w }; }
        [[nodiscard]] static constexpr ProjectivePoint from(const std::span<double, componentsCount>& values) noexcept { return { .x = values[0], .y = values[1], .z = values[2], .w = values[3] }; }

        // generated by com.github.kright.pga3d.codegen.cpp.ops.StructStaticConstructorGenerator

        [[nodiscard]] static constexpr ProjectivePoint blade3(double wxy = 0.0, double wxz = 0.0, double wyz = 0.0, double xyz = 0.0) noexcept { return {.x = -wyz, .y = wxz, .z = -wxy, .w = xyz}; }
        [[nodiscard]] static constexpr ProjectivePoint interpolate(const ProjectivePoint& a, const ProjectivePoint& b, double t) noexcept { return {.x = a.x * (1.0 - t) + b.x * t, .y = a.y * (1.0 - t) + b.y * t, .z = a.z * (1.0 - t) + b.z * t, .w = a.w * (1.0 - t) + b.w * t}; }
        [[nodiscard]] static constexpr ProjectivePoint mid(const ProjectivePoint& a, const ProjectivePoint& b) noexcept { return {.x = 0.5 * (a.x + b.x), .y = 0.5 * (a.y + b.y), .z = 0.5 * (a.z + b.z), .w = 0.5 * (a.w + b.w)}; }
        [[nodiscard]] static constexpr ProjectivePoint mid(const ProjectivePoint& a, const ProjectivePoint& b, const ProjectivePoint& c) noexcept { return {.x = (1.0 / 3.0) * (a.x + b.x + c.x), .y = (1.0 / 3.0) * (a.y + b.y + c.y), .z = (1.0 / 3.0) * (a.z + b.z + c.z), .w = (1.0 / 3.0) * (a.w + b.w + c.w)}; }

        // generated by com.github.kright.pga3d.codegen.cpp.ops.DualOpGenerator

        [[nodiscard]] constexpr Plane dual() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.WeightOpGenerator

        [[nodiscard]] constexpr Vector weight() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.BulkOpGenerator

        [[nodiscard]] constexpr ProjectivePoint bulk() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ReverseOpGenerator

        [[nodiscard]] constexpr ProjectivePoint reverse() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiReverseOpGenerator

        [[nodiscard]] constexpr ProjectivePoint antiReverse() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ConversionOpGenerator

        [[nodiscard]] constexpr Multivector toMultivector() const noexcept;
        [[nodiscard]] constexpr Vector toVectorUnsafe() const noexcept;
        [[nodiscard]] constexpr Point toPointUnsafe() const noexcept;
        [[nodiscard]] constexpr Point toPoint() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ArithmeticsGenerator

        [[nodiscard]] constexpr ProjectivePoint madd(const ProjectivePoint& other, double mult) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.NormOpGenerator

        [[nodiscard]] constexpr double normSquare() const noexcept;
        [[nodiscard]] inline double norm() const noexcept;
        [[nodiscard]] inline ProjectivePoint normalizedByNorm() const noexcept;
        [[nodiscard]] constexpr double bulkNormSquare() const noexcept;
        [[nodiscard]] inline double bulkNorm() const noexcept;
        [[nodiscard]] inline ProjectivePoint normalizedByBulk() const noexcept;
        [[nodiscard]] constexpr double weightNormSquare() const noexcept;
        [[nodiscard]] inline double weightNorm() const noexcept;
        [[nodiscard]] inline ProjectivePoint normalizedByWeight() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ProjectionOpsGenerator

        [[nodiscard]] constexpr ProjectivePoint projectOntoPlane(const Plane& plane) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint projectOntoPlane(const PlaneIdeal& plane) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint projectOntoLine(const Bivector& line) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.GeometricOpGenerator

        [[nodiscard]] constexpr Multivector geometric(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator geometric(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint geometric(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint geometric(const Translator& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight geometric(const Vector& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator geometric(const Point& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Vector geometric(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr Plane geometric(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator geometric(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiGeometricOpGenerator

        [[nodiscard]] constexpr Multivector antiGeometric(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Motor antiGeometric(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Motor antiGeometric(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Motor antiGeometric(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Motor antiGeometric(const Point& b) const noexcept;
        [[nodiscard]] constexpr Quaternion antiGeometric(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiGeometric(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk antiGeometric(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.DotOpGenerator

        [[nodiscard]] constexpr Multivector dot(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Bivector dot(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Plane dot(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr double dot(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Multivector dot(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint dot(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint dot(const Translator& b) const noexcept;
        [[nodiscard]] constexpr double dot(const Point& b) const noexcept;
        [[nodiscard]] constexpr Bivector dot(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Plane dot(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Plane dot(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr double dot(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiDotOpGenerator

        [[nodiscard]] constexpr Multivector antiDot(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Bivector antiDot(const Plane& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiDot(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar antiDot(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiDot(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiDot(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiDot(const Translator& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar antiDot(const Vector& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar antiDot(const Point& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk antiDot(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiDot(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Vector antiDot(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiDot(const PseudoScalar& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.WedgeOpGenerator

        [[nodiscard]] constexpr ProjectivePoint wedge(const Motor& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar wedge(const Plane& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint wedge(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint wedge(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint wedge(const Translator& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar wedge(const PlaneIdeal& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiWedgeOpGenerator

        [[nodiscard]] constexpr Multivector antiWedge(const Motor& b) const noexcept;
        [[nodiscard]] constexpr double antiWedge(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Plane antiWedge(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Bivector antiWedge(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal antiWedge(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Plane antiWedge(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Plane antiWedge(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Bivector antiWedge(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Bivector antiWedge(const Point& b) const noexcept;
        [[nodiscard]] constexpr double antiWedge(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal antiWedge(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Plane antiWedge(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiWedge(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk antiWedge(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.SandwichOpGenerator

        [[nodiscard]] constexpr Motor sandwich(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Plane sandwich(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Bivector sandwich(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint sandwich(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Motor sandwich(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator sandwich(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator sandwich(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Vector sandwich(const Vector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint sandwich(const Point& b) const noexcept;
        [[nodiscard]] constexpr Plane sandwich(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Bivector sandwich(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight sandwich(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar sandwich(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint sandwich(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ReverseSandwichOpGenerator

        [[nodiscard]] constexpr Motor reverseSandwich(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Plane reverseSandwich(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Bivector reverseSandwich(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint reverseSandwich(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Motor reverseSandwich(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator reverseSandwich(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator reverseSandwich(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Vector reverseSandwich(const Vector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint reverseSandwich(const Point& b) const noexcept;
        [[nodiscard]] constexpr Plane reverseSandwich(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Bivector reverseSandwich(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight reverseSandwich(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar reverseSandwich(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint reverseSandwich(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.CrossOpGenerator

        [[nodiscard]] constexpr Multivector cross(const Motor& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar cross(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Vector cross(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight cross(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Vector cross(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Vector cross(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Vector cross(const Translator& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight cross(const Vector& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight cross(const Point& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar cross(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Vector cross(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Vector cross(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr Plane cross(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight cross(const PointCenter& b) const noexcept;
    };

    static_assert(std::is_trivially_copyable_v<ProjectivePoint>);
    static_assert(sizeof(ProjectivePoint) == 8 * ProjectivePoint::componentsCount, "ProjectivePoint must be exactly 32 bytes");
}

// Quaternion.h

// generated by com.github.kright.pga3d.codegen.cpp.Pga3dCodeGenCpp

namespace pga3d {
    struct Quaternion {
        // generated by com.github.kright.pga3d.codegen.cpp.ops.StructFieldsGenerator

        double s = 0.0;
        double xy = 0.0;
        double xz = 0.0;
        double yz = 0.0;

        static constexpr int componentsCount = 4;

        [[nodiscard]] constexpr std::array<double, componentsCount> toArray() const noexcept { return { s, xy, xz, yz }; }
        [[nodiscard]] static constexpr Quaternion from(const std::span<double, componentsCount>& values) noexcept { return { .s = values[0], .xy = values[1], .xz = values[2], .yz = values[3] }; }

        // generated by com.github.kright.pga3d.codegen.cpp.ops.StructStaticConstructorGenerator

        [[nodiscard]] static constexpr Quaternion id() noexcept { return {.s = 1.0}; }

        // generated by com.github.kright.pga3d.codegen.cpp.ops.QuaternionOpsGenerator

        [[nodiscard]] static inline Quaternion rotation(const Vector& from, const Vector& to) noexcept;
        [[nodiscard]] static inline Quaternion rotation(const PlaneIdeal& from, const PlaneIdeal& to) noexcept;

        [[nodiscard]] inline BivectorBulk log() const noexcept;
        [[nodiscard]] inline Quaternion pow(double p) const noexcept;

        [[nodiscard]] inline Quaternion projectToRotationInPlane(const PlaneIdeal& plane) const noexcept;
        [[nodiscard]] inline double restoreRotationInPlane(const PlaneIdeal& plane) const noexcept;

        [[nodiscard]] constexpr Vector axisX() const noexcept;
        [[nodiscard]] constexpr Vector axisY() const noexcept;
        [[nodiscard]] constexpr Vector axisZ() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.DualOpGenerator

        [[nodiscard]] constexpr Motor dual() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.BulkOpGenerator

        [[nodiscard]] constexpr Quaternion bulk() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ReverseOpGenerator

        [[nodiscard]] constexpr Quaternion reverse() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiReverseOpGenerator

        [[nodiscard]] constexpr Quaternion antiReverse() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ConversionOpGenerator

        [[nodiscard]] constexpr Multivector toMultivector() const noexcept;
        [[nodiscard]] constexpr Motor toMotor() const noexcept;
        [[nodiscard]] constexpr Bivector toBivectorUnsafe() const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator toProjectiveTranslatorUnsafe() const noexcept;
        [[nodiscard]] constexpr BivectorBulk toBivectorBulkUnsafe() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ArithmeticsGenerator

        [[nodiscard]] constexpr Quaternion madd(const Quaternion& other, double mult) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.NormOpGenerator

        [[nodiscard]] constexpr double normSquare() const noexcept;
        [[nodiscard]] inline double norm() const noexcept;
        [[nodiscard]] inline Quaternion normalizedByNorm() const noexcept;
        [[nodiscard]] constexpr double bulkNormSquare() const noexcept;
        [[nodiscard]] inline double bulkNorm() const noexcept;
        [[nodiscard]] inline Quaternion normalizedByBulk() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.GeometricOpGenerator

        [[nodiscard]] constexpr Motor geometric(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Quaternion geometric(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const Point& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Quaternion geometric(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiGeometricOpGenerator

        [[nodiscard]] constexpr Quaternion antiGeometric(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Quaternion antiGeometric(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Quaternion antiGeometric(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Quaternion antiGeometric(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const Point& b) const noexcept;
        [[nodiscard]] constexpr Quaternion antiGeometric(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr Quaternion antiGeometric(const PseudoScalar& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.DotOpGenerator

        [[nodiscard]] constexpr Motor dot(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Plane dot(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Motor dot(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Multivector dot(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Quaternion dot(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Motor dot(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Motor dot(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Multivector dot(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Multivector dot(const Point& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal dot(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Quaternion dot(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight dot(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr Motor dot(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr Multivector dot(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiDotOpGenerator

        [[nodiscard]] constexpr Quaternion antiDot(const Motor& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiDot(const Plane& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk antiDot(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiDot(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk antiDot(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk antiDot(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiDot(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiDot(const Point& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk antiDot(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr Quaternion antiDot(const PseudoScalar& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.WedgeOpGenerator

        [[nodiscard]] constexpr Motor wedge(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Multivector wedge(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Motor wedge(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint wedge(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Quaternion wedge(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Motor wedge(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Motor wedge(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Vector wedge(const Vector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint wedge(const Point& b) const noexcept;
        [[nodiscard]] constexpr Multivector wedge(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk wedge(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Motor wedge(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar wedge(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint wedge(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiWedgeOpGenerator

        [[nodiscard]] constexpr Quaternion antiWedge(const Motor& b) const noexcept;
        [[nodiscard]] constexpr double antiWedge(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal antiWedge(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr double antiWedge(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr double antiWedge(const Translator& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal antiWedge(const Vector& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal antiWedge(const Point& b) const noexcept;
        [[nodiscard]] constexpr double antiWedge(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr Quaternion antiWedge(const PseudoScalar& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.SandwichOpGenerator

        [[nodiscard]] constexpr Motor sandwich(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Plane sandwich(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Bivector sandwich(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint sandwich(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Quaternion sandwich(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator sandwich(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator sandwich(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Vector sandwich(const Vector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint sandwich(const Point& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal sandwich(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk sandwich(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight sandwich(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar sandwich(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint sandwich(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ReverseSandwichOpGenerator

        [[nodiscard]] constexpr Motor reverseSandwich(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Plane reverseSandwich(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Bivector reverseSandwich(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint reverseSandwich(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Quaternion reverseSandwich(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator reverseSandwich(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator reverseSandwich(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Vector reverseSandwich(const Vector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint reverseSandwich(const Point& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal reverseSandwich(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk reverseSandwich(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight reverseSandwich(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar reverseSandwich(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint reverseSandwich(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.CrossOpGenerator

        [[nodiscard]] constexpr Bivector cross(const Motor& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal cross(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Bivector cross(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Vector cross(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk cross(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight cross(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight cross(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Vector cross(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Vector cross(const Point& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal cross(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk cross(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight cross(const BivectorWeight& b) const noexcept;
    };

    static_assert(std::is_trivially_copyable_v<Quaternion>);
    static_assert(sizeof(Quaternion) == 8 * Quaternion::componentsCount, "Quaternion must be exactly 32 bytes");
}

// ProjectiveTranslator.h

// generated by com.github.kright.pga3d.codegen.cpp.Pga3dCodeGenCpp

namespace pga3d {
    struct ProjectiveTranslator {
        // generated by com.github.kright.pga3d.codegen.cpp.ops.StructFieldsGenerator

        double s = 0.0;
        double wx = 0.0;
        double wy = 0.0;
        double wz = 0.0;

        static constexpr int componentsCount = 4;

        [[nodiscard]] constexpr std::array<double, componentsCount> toArray() const noexcept { return { s, wx, wy, wz }; }
        [[nodiscard]] static constexpr ProjectiveTranslator from(const std::span<double, componentsCount>& values) noexcept { return { .s = values[0], .wx = values[1], .wy = values[2], .wz = values[3] }; }

        // generated by com.github.kright.pga3d.codegen.cpp.ops.DualOpGenerator

        [[nodiscard]] constexpr Motor dual() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.WeightOpGenerator

        [[nodiscard]] constexpr BivectorWeight weight() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.BulkOpGenerator

        [[nodiscard]] constexpr double bulk() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ReverseOpGenerator

        [[nodiscard]] constexpr ProjectiveTranslator reverse() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiReverseOpGenerator

        [[nodiscard]] constexpr ProjectiveTranslator antiReverse() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ConversionOpGenerator

        [[nodiscard]] constexpr Multivector toMultivector() const noexcept;
        [[nodiscard]] constexpr Motor toMotor() const noexcept;
        [[nodiscard]] constexpr Bivector toBivectorUnsafe() const noexcept;
        [[nodiscard]] constexpr Quaternion toQuaternionUnsafe() const noexcept;
        [[nodiscard]] constexpr Translator toTranslatorUnsafe() const noexcept;
        [[nodiscard]] constexpr BivectorWeight toBivectorWeightUnsafe() const noexcept;
        [[nodiscard]] constexpr Translator toTranslator() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ArithmeticsGenerator

        [[nodiscard]] constexpr ProjectiveTranslator madd(const ProjectiveTranslator& other, double mult) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.NormOpGenerator

        [[nodiscard]] constexpr double normSquare() const noexcept;
        [[nodiscard]] inline double norm() const noexcept;
        [[nodiscard]] inline ProjectiveTranslator normalizedByNorm() const noexcept;
        [[nodiscard]] constexpr double bulkNormSquare() const noexcept;
        [[nodiscard]] inline double bulkNorm() const noexcept;
        [[nodiscard]] inline ProjectiveTranslator normalizedByBulk() const noexcept;
        [[nodiscard]] constexpr double weightNormSquare() const noexcept;
        [[nodiscard]] inline double weightNorm() const noexcept;
        [[nodiscard]] inline ProjectiveTranslator normalizedByWeight() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.GeometricOpGenerator

        [[nodiscard]] constexpr Motor geometric(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint geometric(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator geometric(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator geometric(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Vector geometric(const Vector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint geometric(const Point& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight geometric(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar geometric(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint geometric(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiGeometricOpGenerator

        [[nodiscard]] constexpr Motor antiGeometric(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Motor antiGeometric(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Quaternion antiGeometric(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Motor antiGeometric(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Motor antiGeometric(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const Point& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Quaternion antiGeometric(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Motor antiGeometric(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator antiGeometric(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal antiGeometric(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.DotOpGenerator

        [[nodiscard]] constexpr Motor dot(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Plane dot(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Bivector dot(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint dot(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Motor dot(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator dot(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator dot(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Vector dot(const Vector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint dot(const Point& b) const noexcept;
        [[nodiscard]] constexpr Plane dot(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk dot(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight dot(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar dot(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint dot(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiDotOpGenerator

        [[nodiscard]] constexpr Motor antiDot(const Motor& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiDot(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Motor antiDot(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiDot(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk antiDot(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Motor antiDot(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Motor antiDot(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiDot(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiDot(const Point& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiDot(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Motor antiDot(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator antiDot(const PseudoScalar& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.WedgeOpGenerator

        [[nodiscard]] constexpr Motor wedge(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Multivector wedge(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Motor wedge(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint wedge(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Motor wedge(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator wedge(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator wedge(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Vector wedge(const Vector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint wedge(const Point& b) const noexcept;
        [[nodiscard]] constexpr Multivector wedge(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Motor wedge(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight wedge(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar wedge(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint wedge(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiWedgeOpGenerator

        [[nodiscard]] constexpr ProjectiveTranslator antiWedge(const Motor& b) const noexcept;
        [[nodiscard]] constexpr double antiWedge(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Plane antiWedge(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr double antiWedge(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Plane antiWedge(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Plane antiWedge(const Point& b) const noexcept;
        [[nodiscard]] constexpr double antiWedge(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator antiWedge(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal antiWedge(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.SandwichOpGenerator

        [[nodiscard]] constexpr Motor sandwich(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Plane sandwich(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Bivector sandwich(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint sandwich(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Motor sandwich(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator sandwich(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator sandwich(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Vector sandwich(const Vector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint sandwich(const Point& b) const noexcept;
        [[nodiscard]] constexpr Plane sandwich(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Bivector sandwich(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight sandwich(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar sandwich(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint sandwich(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ReverseSandwichOpGenerator

        [[nodiscard]] constexpr Motor reverseSandwich(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Plane reverseSandwich(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Bivector reverseSandwich(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint reverseSandwich(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Motor reverseSandwich(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator reverseSandwich(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator reverseSandwich(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Vector reverseSandwich(const Vector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint reverseSandwich(const Point& b) const noexcept;
        [[nodiscard]] constexpr Plane reverseSandwich(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Bivector reverseSandwich(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight reverseSandwich(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar reverseSandwich(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint reverseSandwich(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.CrossOpGenerator

        [[nodiscard]] constexpr BivectorWeight cross(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Plane cross(const Plane& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight cross(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Vector cross(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight cross(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Vector cross(const Point& b) const noexcept;
        [[nodiscard]] constexpr Plane cross(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight cross(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Vector cross(const PointCenter& b) const noexcept;
    };

    static_assert(std::is_trivially_copyable_v<ProjectiveTranslator>);
    static_assert(sizeof(ProjectiveTranslator) == 8 * ProjectiveTranslator::componentsCount, "ProjectiveTranslator must be exactly 32 bytes");
}

// Translator.h

// generated by com.github.kright.pga3d.codegen.cpp.Pga3dCodeGenCpp

namespace pga3d {
    struct Translator {
        // generated by com.github.kright.pga3d.codegen.cpp.ops.StructFieldsGenerator

        double wx = 0.0;
        double wy = 0.0;
        double wz = 0.0;

        static constexpr int componentsCount = 3;

        [[nodiscard]] constexpr double s() const noexcept { return 1.0; }

        [[nodiscard]] constexpr std::array<double, componentsCount> toArray() const noexcept { return { wx, wy, wz }; }
        [[nodiscard]] static constexpr Translator from(const std::span<double, componentsCount>& values) noexcept { return { .wx = values[0], .wy = values[1], .wz = values[2] }; }

        // generated by com.github.kright.pga3d.codegen.cpp.ops.TranslatorOpsGenerator

        [[nodiscard]] static constexpr Translator id() noexcept { return {}; }
        [[nodiscard]] static constexpr Translator addVector(const Vector& v) noexcept;

        [[nodiscard]] constexpr BivectorWeight log() const noexcept;
        [[nodiscard]] constexpr Translator pow(double p) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.DualOpGenerator

        [[nodiscard]] constexpr Motor dual() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.WeightOpGenerator

        [[nodiscard]] constexpr BivectorWeight weight() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.BulkOpGenerator

        [[nodiscard]] constexpr double bulk() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ReverseOpGenerator

        [[nodiscard]] constexpr Translator reverse() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiReverseOpGenerator

        [[nodiscard]] constexpr Translator antiReverse() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ConversionOpGenerator

        [[nodiscard]] constexpr Multivector toMultivector() const noexcept;
        [[nodiscard]] constexpr Motor toMotor() const noexcept;
        [[nodiscard]] constexpr Bivector toBivectorUnsafe() const noexcept;
        [[nodiscard]] constexpr Quaternion toQuaternionUnsafe() const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator toProjectiveTranslator() const noexcept;
        [[nodiscard]] constexpr BivectorWeight toBivectorWeightUnsafe() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.NormOpGenerator

        [[nodiscard]] constexpr double normSquare() const noexcept;
        [[nodiscard]] inline double norm() const noexcept;
        [[nodiscard]] inline ProjectiveTranslator normalizedByNorm() const noexcept;
        [[nodiscard]] constexpr double bulkNormSquare() const noexcept;
        [[nodiscard]] inline double bulkNorm() const noexcept;
        [[nodiscard]] inline ProjectiveTranslator normalizedByBulk() const noexcept;
        [[nodiscard]] constexpr double weightNormSquare() const noexcept;
        [[nodiscard]] inline double weightNorm() const noexcept;
        [[nodiscard]] inline ProjectiveTranslator normalizedByWeight() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.GeometricOpGenerator

        [[nodiscard]] constexpr Motor geometric(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint geometric(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator geometric(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Translator geometric(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Vector geometric(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Point geometric(const Point& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight geometric(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar geometric(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr Point geometric(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiGeometricOpGenerator

        [[nodiscard]] constexpr Motor antiGeometric(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Motor antiGeometric(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Quaternion antiGeometric(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Motor antiGeometric(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Motor antiGeometric(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const Point& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Quaternion antiGeometric(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Motor antiGeometric(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator antiGeometric(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal antiGeometric(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.DotOpGenerator

        [[nodiscard]] constexpr Motor dot(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Plane dot(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Bivector dot(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint dot(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Motor dot(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator dot(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Translator dot(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Vector dot(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Point dot(const Point& b) const noexcept;
        [[nodiscard]] constexpr Plane dot(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk dot(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight dot(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar dot(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr PointCenter dot(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiDotOpGenerator

        [[nodiscard]] constexpr Motor antiDot(const Motor& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiDot(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Motor antiDot(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiDot(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk antiDot(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Motor antiDot(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Motor antiDot(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiDot(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiDot(const Point& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiDot(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Motor antiDot(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator antiDot(const PseudoScalar& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.WedgeOpGenerator

        [[nodiscard]] constexpr Motor wedge(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Multivector wedge(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Motor wedge(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint wedge(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Motor wedge(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator wedge(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Translator wedge(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Vector wedge(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Point wedge(const Point& b) const noexcept;
        [[nodiscard]] constexpr Multivector wedge(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Motor wedge(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight wedge(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar wedge(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr PointCenter wedge(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiWedgeOpGenerator

        [[nodiscard]] constexpr ProjectiveTranslator antiWedge(const Motor& b) const noexcept;
        [[nodiscard]] constexpr double antiWedge(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Plane antiWedge(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr double antiWedge(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Plane antiWedge(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Plane antiWedge(const Point& b) const noexcept;
        [[nodiscard]] constexpr double antiWedge(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator antiWedge(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal antiWedge(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.SandwichOpGenerator

        [[nodiscard]] constexpr Motor sandwich(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Plane sandwich(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Bivector sandwich(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint sandwich(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Motor sandwich(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator sandwich(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Translator sandwich(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Vector sandwich(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Point sandwich(const Point& b) const noexcept;
        [[nodiscard]] constexpr Plane sandwich(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Bivector sandwich(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight sandwich(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar sandwich(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr Point sandwich(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ReverseSandwichOpGenerator

        [[nodiscard]] constexpr Motor reverseSandwich(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Plane reverseSandwich(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Bivector reverseSandwich(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint reverseSandwich(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Motor reverseSandwich(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator reverseSandwich(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Translator reverseSandwich(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Vector reverseSandwich(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Point reverseSandwich(const Point& b) const noexcept;
        [[nodiscard]] constexpr Plane reverseSandwich(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Bivector reverseSandwich(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight reverseSandwich(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar reverseSandwich(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr Point reverseSandwich(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.CrossOpGenerator

        [[nodiscard]] constexpr BivectorWeight cross(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Plane cross(const Plane& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight cross(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Vector cross(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight cross(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Vector cross(const Point& b) const noexcept;
        [[nodiscard]] constexpr Plane cross(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight cross(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Vector cross(const PointCenter& b) const noexcept;
    };

    static_assert(std::is_trivially_copyable_v<Translator>);
    static_assert(sizeof(Translator) == 8 * Translator::componentsCount, "Translator must be exactly 24 bytes");
}

// Vector.h

// generated by com.github.kright.pga3d.codegen.cpp.Pga3dCodeGenCpp

namespace pga3d {
    struct Vector {
        // generated by com.github.kright.pga3d.codegen.cpp.ops.StructFieldsGenerator

        double x = 0.0;
        double y = 0.0;
        double z = 0.0;

        static constexpr int componentsCount = 3;

        [[nodiscard]] constexpr double wyz() const noexcept { return -x; }
        [[nodiscard]] constexpr double wxz() const noexcept { return y; }
        [[nodiscard]] constexpr double wxy() const noexcept { return -z; }

        [[nodiscard]] constexpr std::array<double, componentsCount> toArray() const noexcept { return { x, y, z }; }
        [[nodiscard]] static constexpr Vector from(const std::span<double, componentsCount>& values) noexcept { return { .x = values[0], .y = values[1], .z = values[2] }; }

        // generated by com.github.kright.pga3d.codegen.cpp.ops.StructStaticConstructorGenerator

        [[nodiscard]] static constexpr Vector blade3(double wxy = 0.0, double wxz = 0.0, double wyz = 0.0) noexcept { return {.x = -wyz, .y = wxz, .z = -wxy}; }
        [[nodiscard]] static constexpr Vector interpolate(const Vector& a, const Vector& b, double t) noexcept { return {.x = a.x * (1.0 - t) + b.x * t, .y = a.y * (1.0 - t) + b.y * t, .z = a.z * (1.0 - t) + b.z * t}; }
        [[nodiscard]] static constexpr Vector mid(const Vector& a, const Vector& b) noexcept { return {.x = 0.5 * (a.x + b.x), .y = 0.5 * (a.y + b.y), .z = 0.5 * (a.z + b.z)}; }
        [[nodiscard]] static constexpr Vector mid(const Vector& a, const Vector& b, const Vector& c) noexcept { return {.x = (1.0 / 3.0) * (a.x + b.x + c.x), .y = (1.0 / 3.0) * (a.y + b.y + c.y), .z = (1.0 / 3.0) * (a.z + b.z + c.z)}; }

        // generated by com.github.kright.pga3d.codegen.cpp.ops.VectorOpsGenerator

        [[nodiscard]] inline Vector min(const Vector& other) const noexcept;
        [[nodiscard]] inline Vector max(const Vector& other) const noexcept;
        [[nodiscard]] inline Vector clamp(const Vector& minV, const Vector& maxV) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.DualOpGenerator

        [[nodiscard]] constexpr PlaneIdeal dual() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.WeightOpGenerator

        [[nodiscard]] constexpr Vector weight() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ReverseOpGenerator

        [[nodiscard]] constexpr Vector reverse() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiReverseOpGenerator

        [[nodiscard]] constexpr Vector antiReverse() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ConversionOpGenerator

        [[nodiscard]] constexpr Multivector toMultivector() const noexcept;
        [[nodiscard]] constexpr ProjectivePoint toProjectivePoint() const noexcept;
        [[nodiscard]] constexpr Point toPointUnsafe() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ArithmeticsGenerator

        [[nodiscard]] constexpr Vector madd(const Vector& other, double mult) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.NormOpGenerator

        [[nodiscard]] constexpr double normSquare() const noexcept;
        [[nodiscard]] inline double norm() const noexcept;
        [[nodiscard]] inline Vector normalizedByNorm() const noexcept;
        [[nodiscard]] constexpr double weightNormSquare() const noexcept;
        [[nodiscard]] inline double weightNorm() const noexcept;
        [[nodiscard]] inline Vector normalizedByWeight() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.GeometricOpGenerator

        [[nodiscard]] constexpr Multivector geometric(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight geometric(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Vector geometric(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Vector geometric(const Translator& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight geometric(const Point& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight geometric(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiGeometricOpGenerator

        [[nodiscard]] constexpr Multivector antiGeometric(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Motor antiGeometric(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Motor antiGeometric(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Motor antiGeometric(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Motor antiGeometric(const Point& b) const noexcept;
        [[nodiscard]] constexpr Quaternion antiGeometric(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr Vector antiGeometric(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk antiGeometric(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.DotOpGenerator

        [[nodiscard]] constexpr Multivector dot(const Motor& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight dot(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Plane dot(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Multivector dot(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Vector dot(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Vector dot(const Translator& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight dot(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Plane dot(const BivectorBulk& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiDotOpGenerator

        [[nodiscard]] constexpr Multivector antiDot(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Bivector antiDot(const Plane& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiDot(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar antiDot(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiDot(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiDot(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiDot(const Translator& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar antiDot(const Vector& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar antiDot(const Point& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk antiDot(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiDot(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Vector antiDot(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr Vector antiDot(const PseudoScalar& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.WedgeOpGenerator

        [[nodiscard]] constexpr Vector wedge(const Motor& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar wedge(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Vector wedge(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Vector wedge(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Vector wedge(const Translator& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar wedge(const PlaneIdeal& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiWedgeOpGenerator

        [[nodiscard]] constexpr Multivector antiWedge(const Motor& b) const noexcept;
        [[nodiscard]] constexpr double antiWedge(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Plane antiWedge(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Bivector antiWedge(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal antiWedge(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Plane antiWedge(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Plane antiWedge(const Translator& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight antiWedge(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Bivector antiWedge(const Point& b) const noexcept;
        [[nodiscard]] constexpr double antiWedge(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal antiWedge(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Plane antiWedge(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr Vector antiWedge(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk antiWedge(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.CrossOpGenerator

        [[nodiscard]] constexpr Vector cross(const Motor& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar cross(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Vector cross(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight cross(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Vector cross(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight cross(const Point& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar cross(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Vector cross(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight cross(const PointCenter& b) const noexcept;
    };

    static_assert(std::is_trivially_copyable_v<Vector>);
    static_assert(sizeof(Vector) == 8 * Vector::componentsCount, "Vector must be exactly 24 bytes");
}

// Point.h

// generated by com.github.kright.pga3d.codegen.cpp.Pga3dCodeGenCpp

namespace pga3d {
    struct Point {
        // generated by com.github.kright.pga3d.codegen.cpp.ops.StructFieldsGenerator

        double x = 0.0;
        double y = 0.0;
        double z = 0.0;

        static constexpr int componentsCount = 3;

        [[nodiscard]] constexpr double w() const noexcept { return 1.0; }

        [[nodiscard]] constexpr double wyz() const noexcept { return -x; }
        [[nodiscard]] constexpr double wxz() const noexcept { return y; }
        [[nodiscard]] constexpr double wxy() const noexcept { return -z; }
        [[nodiscard]] constexpr double xyz() const noexcept { return 1.0; }

        [[nodiscard]] constexpr std::array<double, componentsCount> toArray() const noexcept { return { x, y, z }; }
        [[nodiscard]] static constexpr Point from(const std::span<double, componentsCount>& values) noexcept { return { .x = values[0], .y = values[1], .z = values[2] }; }

        // generated by com.github.kright.pga3d.codegen.cpp.ops.StructStaticConstructorGenerator

        [[nodiscard]] static constexpr Point blade3(double wxy = 0.0, double wxz = 0.0, double wyz = 0.0) noexcept { return {.x = -wyz, .y = wxz, .z = -wxy}; }
        [[nodiscard]] static constexpr Point interpolate(const Point& a, const Point& b, double t) noexcept { return {.x = a.x * (1.0 - t) + b.x * t, .y = a.y * (1.0 - t) + b.y * t, .z = a.z * (1.0 - t) + b.z * t}; }
        [[nodiscard]] static constexpr Point mid(const Point& a, const Point& b) noexcept { return {.x = 0.5 * (a.x + b.x), .y = 0.5 * (a.y + b.y), .z = 0.5 * (a.z + b.z)}; }
        [[nodiscard]] static constexpr Point mid(const Point& a, const Point& b, const Point& c) noexcept { return {.x = (1.0 / 3.0) * (a.x + b.x + c.x), .y = (1.0 / 3.0) * (a.y + b.y + c.y), .z = (1.0 / 3.0) * (a.z + b.z + c.z)}; }

        // generated by com.github.kright.pga3d.codegen.cpp.ops.PointOpsGenerator

        [[nodiscard]] inline double distanceTo(const Point& other) const noexcept;

        [[nodiscard]] inline Point min(const Point& other) const noexcept;
        [[nodiscard]] inline Point max(const Point& other) const noexcept;
        [[nodiscard]] inline Point clamp(const Point& minV, const Point& maxV) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.DualOpGenerator

        [[nodiscard]] constexpr Plane dual() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.WeightOpGenerator

        [[nodiscard]] constexpr Vector weight() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.BulkOpGenerator

        [[nodiscard]] constexpr PointCenter bulk() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ReverseOpGenerator

        [[nodiscard]] constexpr ProjectivePoint reverse() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiReverseOpGenerator

        [[nodiscard]] constexpr Point antiReverse() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ConversionOpGenerator

        [[nodiscard]] constexpr Multivector toMultivector() const noexcept;
        [[nodiscard]] constexpr ProjectivePoint toProjectivePoint() const noexcept;
        [[nodiscard]] constexpr Vector toVectorUnsafe() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ArithmeticsGenerator

        [[nodiscard]] constexpr Point madd(const Vector& other, double mult) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.NormOpGenerator

        [[nodiscard]] constexpr double normSquare() const noexcept;
        [[nodiscard]] inline double norm() const noexcept;
        [[nodiscard]] inline ProjectivePoint normalizedByNorm() const noexcept;
        [[nodiscard]] constexpr double bulkNormSquare() const noexcept;
        [[nodiscard]] inline double bulkNorm() const noexcept;
        [[nodiscard]] inline ProjectivePoint normalizedByBulk() const noexcept;
        [[nodiscard]] constexpr double weightNormSquare() const noexcept;
        [[nodiscard]] inline double weightNorm() const noexcept;
        [[nodiscard]] inline ProjectivePoint normalizedByWeight() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ProjectionOpsGenerator

        [[nodiscard]] constexpr ProjectivePoint projectOntoPlane(const Plane& plane) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint projectOntoPlane(const PlaneIdeal& plane) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint projectOntoLine(const Bivector& line) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.GeometricOpGenerator

        [[nodiscard]] constexpr Multivector geometric(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator geometric(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint geometric(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Point geometric(const Translator& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight geometric(const Vector& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator geometric(const Point& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Vector geometric(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr Plane geometric(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator geometric(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiGeometricOpGenerator

        [[nodiscard]] constexpr Multivector antiGeometric(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Motor antiGeometric(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Motor antiGeometric(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Motor antiGeometric(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Motor antiGeometric(const Point& b) const noexcept;
        [[nodiscard]] constexpr Quaternion antiGeometric(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiGeometric(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk antiGeometric(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.DotOpGenerator

        [[nodiscard]] constexpr Multivector dot(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Bivector dot(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Plane dot(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr double dot(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Multivector dot(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint dot(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Point dot(const Translator& b) const noexcept;
        [[nodiscard]] constexpr double dot(const Point& b) const noexcept;
        [[nodiscard]] constexpr Bivector dot(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Plane dot(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Plane dot(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr double dot(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiDotOpGenerator

        [[nodiscard]] constexpr Multivector antiDot(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Bivector antiDot(const Plane& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiDot(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar antiDot(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiDot(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiDot(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiDot(const Translator& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar antiDot(const Vector& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar antiDot(const Point& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk antiDot(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiDot(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Vector antiDot(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiDot(const PseudoScalar& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.WedgeOpGenerator

        [[nodiscard]] constexpr ProjectivePoint wedge(const Motor& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar wedge(const Plane& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint wedge(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint wedge(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Point wedge(const Translator& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar wedge(const PlaneIdeal& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiWedgeOpGenerator

        [[nodiscard]] constexpr Multivector antiWedge(const Motor& b) const noexcept;
        [[nodiscard]] constexpr double antiWedge(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Plane antiWedge(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Bivector antiWedge(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal antiWedge(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Plane antiWedge(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Plane antiWedge(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Bivector antiWedge(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Bivector antiWedge(const Point& b) const noexcept;
        [[nodiscard]] constexpr double antiWedge(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal antiWedge(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Plane antiWedge(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiWedge(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk antiWedge(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.SandwichOpGenerator

        [[nodiscard]] constexpr Motor sandwich(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Plane sandwich(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Bivector sandwich(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint sandwich(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Motor sandwich(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator sandwich(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Translator sandwich(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Vector sandwich(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Point sandwich(const Point& b) const noexcept;
        [[nodiscard]] constexpr Plane sandwich(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Bivector sandwich(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight sandwich(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar sandwich(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr Point sandwich(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ReverseSandwichOpGenerator

        [[nodiscard]] constexpr Motor reverseSandwich(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Plane reverseSandwich(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Bivector reverseSandwich(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint reverseSandwich(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Motor reverseSandwich(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator reverseSandwich(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Translator reverseSandwich(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Vector reverseSandwich(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Point reverseSandwich(const Point& b) const noexcept;
        [[nodiscard]] constexpr Plane reverseSandwich(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Bivector reverseSandwich(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight reverseSandwich(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar reverseSandwich(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr Point reverseSandwich(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.CrossOpGenerator

        [[nodiscard]] constexpr Multivector cross(const Motor& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar cross(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Vector cross(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight cross(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Vector cross(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Vector cross(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Vector cross(const Translator& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight cross(const Vector& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight cross(const Point& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar cross(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Vector cross(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Vector cross(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr Plane cross(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight cross(const PointCenter& b) const noexcept;
    };

    static_assert(std::is_trivially_copyable_v<Point>);
    static_assert(sizeof(Point) == 8 * Point::componentsCount, "Point must be exactly 24 bytes");
}

// PlaneIdeal.h

// generated by com.github.kright.pga3d.codegen.cpp.Pga3dCodeGenCpp

namespace pga3d {
    struct PlaneIdeal {
        // generated by com.github.kright.pga3d.codegen.cpp.ops.StructFieldsGenerator

        double x = 0.0;
        double y = 0.0;
        double z = 0.0;

        static constexpr int componentsCount = 3;

        [[nodiscard]] constexpr std::array<double, componentsCount> toArray() const noexcept { return { x, y, z }; }
        [[nodiscard]] static constexpr PlaneIdeal from(const std::span<double, componentsCount>& values) noexcept { return { .x = values[0], .y = values[1], .z = values[2] }; }

        // generated by com.github.kright.pga3d.codegen.cpp.ops.DualOpGenerator

        [[nodiscard]] constexpr Vector dual() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.BulkOpGenerator

        [[nodiscard]] constexpr PlaneIdeal bulk() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ReverseOpGenerator

        [[nodiscard]] constexpr PlaneIdeal reverse() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiReverseOpGenerator

        [[nodiscard]] constexpr PlaneIdeal antiReverse() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ConversionOpGenerator

        [[nodiscard]] constexpr Multivector toMultivector() const noexcept;
        [[nodiscard]] constexpr Plane toPlane() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ArithmeticsGenerator

        [[nodiscard]] constexpr PlaneIdeal madd(const PlaneIdeal& other, double mult) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.NormOpGenerator

        [[nodiscard]] constexpr double normSquare() const noexcept;
        [[nodiscard]] inline double norm() const noexcept;
        [[nodiscard]] inline PlaneIdeal normalizedByNorm() const noexcept;
        [[nodiscard]] constexpr double bulkNormSquare() const noexcept;
        [[nodiscard]] inline double bulkNorm() const noexcept;
        [[nodiscard]] inline PlaneIdeal normalizedByBulk() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.GeometricOpGenerator

        [[nodiscard]] constexpr Multivector geometric(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const Point& b) const noexcept;
        [[nodiscard]] constexpr Quaternion geometric(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr Vector geometric(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk geometric(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiGeometricOpGenerator

        [[nodiscard]] constexpr Multivector antiGeometric(const Motor& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk antiGeometric(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Quaternion antiGeometric(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Quaternion antiGeometric(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Quaternion antiGeometric(const Point& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal antiGeometric(const PseudoScalar& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.DotOpGenerator

        [[nodiscard]] constexpr Multivector dot(const Motor& b) const noexcept;
        [[nodiscard]] constexpr double dot(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Plane dot(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Bivector dot(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal dot(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Plane dot(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Plane dot(const Translator& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight dot(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Bivector dot(const Point& b) const noexcept;
        [[nodiscard]] constexpr double dot(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal dot(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Plane dot(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr Vector dot(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk dot(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiDotOpGenerator

        [[nodiscard]] constexpr Multivector antiDot(const Motor& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiDot(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk antiDot(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiDot(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiDot(const Translator& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk antiDot(const Vector& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk antiDot(const Point& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiDot(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal antiDot(const PseudoScalar& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.WedgeOpGenerator

        [[nodiscard]] constexpr Multivector wedge(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Bivector wedge(const Plane& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint wedge(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar wedge(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Multivector wedge(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Multivector wedge(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Multivector wedge(const Translator& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar wedge(const Vector& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar wedge(const Point& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk wedge(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint wedge(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Vector wedge(const BivectorWeight& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiWedgeOpGenerator

        [[nodiscard]] constexpr PlaneIdeal antiWedge(const Motor& b) const noexcept;
        [[nodiscard]] constexpr double antiWedge(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr double antiWedge(const Vector& b) const noexcept;
        [[nodiscard]] constexpr double antiWedge(const Point& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal antiWedge(const PseudoScalar& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.SandwichOpGenerator

        [[nodiscard]] constexpr Motor sandwich(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Plane sandwich(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Bivector sandwich(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint sandwich(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Quaternion sandwich(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator sandwich(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator sandwich(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Vector sandwich(const Vector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint sandwich(const Point& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal sandwich(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk sandwich(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight sandwich(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar sandwich(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint sandwich(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ReverseSandwichOpGenerator

        [[nodiscard]] constexpr Motor reverseSandwich(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Plane reverseSandwich(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Bivector reverseSandwich(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint reverseSandwich(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Quaternion reverseSandwich(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator reverseSandwich(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator reverseSandwich(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Vector reverseSandwich(const Vector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint reverseSandwich(const Point& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal reverseSandwich(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk reverseSandwich(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight reverseSandwich(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar reverseSandwich(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint reverseSandwich(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.CrossOpGenerator

        [[nodiscard]] constexpr Multivector cross(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Bivector cross(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Plane cross(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar cross(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal cross(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Plane cross(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Plane cross(const Translator& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar cross(const Vector& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar cross(const Point& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk cross(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal cross(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Plane cross(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr Vector cross(const PseudoScalar& b) const noexcept;
    };

    static_assert(std::is_trivially_copyable_v<PlaneIdeal>);
    static_assert(sizeof(PlaneIdeal) == 8 * PlaneIdeal::componentsCount, "PlaneIdeal must be exactly 24 bytes");
}

// BivectorBulk.h

// generated by com.github.kright.pga3d.codegen.cpp.Pga3dCodeGenCpp

namespace pga3d {
    struct BivectorBulk {
        // generated by com.github.kright.pga3d.codegen.cpp.ops.StructFieldsGenerator

        double xy = 0.0;
        double xz = 0.0;
        double yz = 0.0;

        static constexpr int componentsCount = 3;

        [[nodiscard]] constexpr std::array<double, componentsCount> toArray() const noexcept { return { xy, xz, yz }; }
        [[nodiscard]] static constexpr BivectorBulk from(const std::span<double, componentsCount>& values) noexcept { return { .xy = values[0], .xz = values[1], .yz = values[2] }; }

        // generated by com.github.kright.pga3d.codegen.cpp.ops.BivectorBulkOpsGenerator

        [[nodiscard]] inline Quaternion exp() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.DualOpGenerator

        [[nodiscard]] constexpr BivectorWeight dual() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.BulkOpGenerator

        [[nodiscard]] constexpr BivectorBulk bulk() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ReverseOpGenerator

        [[nodiscard]] constexpr BivectorBulk reverse() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiReverseOpGenerator

        [[nodiscard]] constexpr BivectorBulk antiReverse() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ConversionOpGenerator

        [[nodiscard]] constexpr Multivector toMultivector() const noexcept;
        [[nodiscard]] constexpr Motor toMotor() const noexcept;
        [[nodiscard]] constexpr Bivector toBivector() const noexcept;
        [[nodiscard]] constexpr Quaternion toQuaternion() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ArithmeticsGenerator

        [[nodiscard]] constexpr BivectorBulk madd(const BivectorBulk& other, double mult) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.NormOpGenerator

        [[nodiscard]] constexpr double normSquare() const noexcept;
        [[nodiscard]] inline double norm() const noexcept;
        [[nodiscard]] inline BivectorBulk normalizedByNorm() const noexcept;
        [[nodiscard]] constexpr double bulkNormSquare() const noexcept;
        [[nodiscard]] inline double bulkNorm() const noexcept;
        [[nodiscard]] inline BivectorBulk normalizedByBulk() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.GeometricOpGenerator

        [[nodiscard]] constexpr Motor geometric(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Quaternion geometric(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const Point& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Quaternion geometric(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight geometric(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal geometric(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiGeometricOpGenerator

        [[nodiscard]] constexpr Quaternion antiGeometric(const Motor& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal antiGeometric(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Quaternion antiGeometric(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Quaternion antiGeometric(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Quaternion antiGeometric(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const Point& b) const noexcept;
        [[nodiscard]] constexpr Quaternion antiGeometric(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk antiGeometric(const PseudoScalar& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.DotOpGenerator

        [[nodiscard]] constexpr Motor dot(const Motor& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal dot(const Plane& b) const noexcept;
        [[nodiscard]] constexpr double dot(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Plane dot(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Quaternion dot(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk dot(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk dot(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Plane dot(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Plane dot(const Point& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal dot(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr double dot(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight dot(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal dot(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiDotOpGenerator

        [[nodiscard]] constexpr BivectorBulk antiDot(const Motor& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiDot(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiDot(const Vector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiDot(const Point& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk antiDot(const PseudoScalar& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.WedgeOpGenerator

        [[nodiscard]] constexpr Motor wedge(const Motor& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint wedge(const Plane& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar wedge(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk wedge(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Motor wedge(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Motor wedge(const Translator& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint wedge(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar wedge(const BivectorWeight& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiWedgeOpGenerator

        [[nodiscard]] constexpr Quaternion antiWedge(const Motor& b) const noexcept;
        [[nodiscard]] constexpr double antiWedge(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal antiWedge(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr double antiWedge(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr double antiWedge(const Translator& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal antiWedge(const Vector& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal antiWedge(const Point& b) const noexcept;
        [[nodiscard]] constexpr double antiWedge(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk antiWedge(const PseudoScalar& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.SandwichOpGenerator

        [[nodiscard]] constexpr Motor sandwich(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Plane sandwich(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Bivector sandwich(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint sandwich(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Quaternion sandwich(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator sandwich(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator sandwich(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Vector sandwich(const Vector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint sandwich(const Point& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal sandwich(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk sandwich(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight sandwich(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar sandwich(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint sandwich(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ReverseSandwichOpGenerator

        [[nodiscard]] constexpr Motor reverseSandwich(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Plane reverseSandwich(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Bivector reverseSandwich(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint reverseSandwich(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Quaternion reverseSandwich(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator reverseSandwich(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator reverseSandwich(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Vector reverseSandwich(const Vector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint reverseSandwich(const Point& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal reverseSandwich(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk reverseSandwich(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight reverseSandwich(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar reverseSandwich(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint reverseSandwich(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.CrossOpGenerator

        [[nodiscard]] constexpr Bivector cross(const Motor& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal cross(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Bivector cross(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Vector cross(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk cross(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight cross(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight cross(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Vector cross(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Vector cross(const Point& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal cross(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk cross(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight cross(const BivectorWeight& b) const noexcept;
    };

    static_assert(std::is_trivially_copyable_v<BivectorBulk>);
    static_assert(sizeof(BivectorBulk) == 8 * BivectorBulk::componentsCount, "BivectorBulk must be exactly 24 bytes");
}

// BivectorWeight.h

// generated by com.github.kright.pga3d.codegen.cpp.Pga3dCodeGenCpp

namespace pga3d {
    struct BivectorWeight {
        // generated by com.github.kright.pga3d.codegen.cpp.ops.StructFieldsGenerator

        double wx = 0.0;
        double wy = 0.0;
        double wz = 0.0;

        static constexpr int componentsCount = 3;

        [[nodiscard]] constexpr std::array<double, componentsCount> toArray() const noexcept { return { wx, wy, wz }; }
        [[nodiscard]] static constexpr BivectorWeight from(const std::span<double, componentsCount>& values) noexcept { return { .wx = values[0], .wy = values[1], .wz = values[2] }; }

        // generated by com.github.kright.pga3d.codegen.cpp.ops.BivectorWeightOpsGenerator

        [[nodiscard]] constexpr Translator exp() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.DualOpGenerator

        [[nodiscard]] constexpr BivectorBulk dual() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.WeightOpGenerator

        [[nodiscard]] constexpr BivectorWeight weight() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ReverseOpGenerator

        [[nodiscard]] constexpr BivectorWeight reverse() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiReverseOpGenerator

        [[nodiscard]] constexpr BivectorWeight antiReverse() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ConversionOpGenerator

        [[nodiscard]] constexpr Multivector toMultivector() const noexcept;
        [[nodiscard]] constexpr Motor toMotor() const noexcept;
        [[nodiscard]] constexpr Bivector toBivector() const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator toProjectiveTranslator() const noexcept;
        [[nodiscard]] constexpr Translator toTranslatorUnsafe() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ArithmeticsGenerator

        [[nodiscard]] constexpr BivectorWeight madd(const BivectorWeight& other, double mult) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.NormOpGenerator

        [[nodiscard]] constexpr double normSquare() const noexcept;
        [[nodiscard]] inline double norm() const noexcept;
        [[nodiscard]] inline BivectorWeight normalizedByNorm() const noexcept;
        [[nodiscard]] constexpr double weightNormSquare() const noexcept;
        [[nodiscard]] inline double weightNorm() const noexcept;
        [[nodiscard]] inline BivectorWeight normalizedByWeight() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.GeometricOpGenerator

        [[nodiscard]] constexpr Motor geometric(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Vector geometric(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight geometric(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight geometric(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Vector geometric(const Point& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Vector geometric(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiGeometricOpGenerator

        [[nodiscard]] constexpr Motor antiGeometric(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Motor antiGeometric(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Quaternion antiGeometric(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Motor antiGeometric(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Motor antiGeometric(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const Point& b) const noexcept;
        [[nodiscard]] constexpr Multivector antiGeometric(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Quaternion antiGeometric(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Motor antiGeometric(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight antiGeometric(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal antiGeometric(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.DotOpGenerator

        [[nodiscard]] constexpr BivectorWeight dot(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Plane dot(const Plane& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight dot(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight dot(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight dot(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Plane dot(const PlaneIdeal& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiDotOpGenerator

        [[nodiscard]] constexpr Motor antiDot(const Motor& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiDot(const Plane& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar antiDot(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Vector antiDot(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk antiDot(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Motor antiDot(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Motor antiDot(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Vector antiDot(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Vector antiDot(const Point& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiDot(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar antiDot(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight antiDot(const PseudoScalar& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.WedgeOpGenerator

        [[nodiscard]] constexpr Motor wedge(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Vector wedge(const Plane& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar wedge(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Motor wedge(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight wedge(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight wedge(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Vector wedge(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar wedge(const BivectorBulk& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiWedgeOpGenerator

        [[nodiscard]] constexpr ProjectiveTranslator antiWedge(const Motor& b) const noexcept;
        [[nodiscard]] constexpr double antiWedge(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Plane antiWedge(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr double antiWedge(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Plane antiWedge(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Plane antiWedge(const Point& b) const noexcept;
        [[nodiscard]] constexpr double antiWedge(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight antiWedge(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal antiWedge(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.CrossOpGenerator

        [[nodiscard]] constexpr BivectorWeight cross(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Plane cross(const Plane& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight cross(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Vector cross(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight cross(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr Vector cross(const Point& b) const noexcept;
        [[nodiscard]] constexpr Plane cross(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight cross(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Vector cross(const PointCenter& b) const noexcept;
    };

    static_assert(std::is_trivially_copyable_v<BivectorWeight>);
    static_assert(sizeof(BivectorWeight) == 8 * BivectorWeight::componentsCount, "BivectorWeight must be exactly 24 bytes");
}

// PseudoScalar.h

// generated by com.github.kright.pga3d.codegen.cpp.Pga3dCodeGenCpp

namespace pga3d {
    struct PseudoScalar {
        // generated by com.github.kright.pga3d.codegen.cpp.ops.StructFieldsGenerator

        double i = 0.0;

        static constexpr int componentsCount = 1;

        [[nodiscard]] constexpr std::array<double, componentsCount> toArray() const noexcept { return { i }; }
        [[nodiscard]] static constexpr PseudoScalar from(const std::span<double, componentsCount>& values) noexcept { return { .i = values[0] }; }

        // generated by com.github.kright.pga3d.codegen.cpp.ops.DualOpGenerator

        [[nodiscard]] constexpr double dual() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.WeightOpGenerator

        [[nodiscard]] constexpr PseudoScalar weight() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ReverseOpGenerator

        [[nodiscard]] constexpr PseudoScalar reverse() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiReverseOpGenerator

        [[nodiscard]] constexpr PseudoScalar antiReverse() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ConversionOpGenerator

        [[nodiscard]] constexpr Multivector toMultivector() const noexcept;
        [[nodiscard]] constexpr Motor toMotor() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ArithmeticsGenerator

        [[nodiscard]] constexpr PseudoScalar madd(const PseudoScalar& other, double mult) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.NormOpGenerator

        [[nodiscard]] constexpr double normSquare() const noexcept;
        [[nodiscard]] inline double norm() const noexcept;
        [[nodiscard]] inline PseudoScalar normalizedByNorm() const noexcept;
        [[nodiscard]] constexpr double weightNormSquare() const noexcept;
        [[nodiscard]] inline double weightNorm() const noexcept;
        [[nodiscard]] inline PseudoScalar normalizedByWeight() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.GeometricOpGenerator

        [[nodiscard]] constexpr Motor geometric(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Vector geometric(const Plane& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight geometric(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Plane geometric(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar geometric(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar geometric(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Plane geometric(const Point& b) const noexcept;
        [[nodiscard]] constexpr Vector geometric(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight geometric(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Plane geometric(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiGeometricOpGenerator

        [[nodiscard]] constexpr Motor antiGeometric(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Plane antiGeometric(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Bivector antiGeometric(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiGeometric(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Quaternion antiGeometric(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator antiGeometric(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator antiGeometric(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Vector antiGeometric(const Vector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiGeometric(const Point& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal antiGeometric(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk antiGeometric(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight antiGeometric(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar antiGeometric(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiGeometric(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.DotOpGenerator

        [[nodiscard]] constexpr Motor dot(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Vector dot(const Plane& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight dot(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr Plane dot(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Motor dot(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar dot(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar dot(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Plane dot(const Point& b) const noexcept;
        [[nodiscard]] constexpr Vector dot(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight dot(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Plane dot(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiDotOpGenerator

        [[nodiscard]] constexpr Motor antiDot(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Plane antiDot(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Bivector antiDot(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiDot(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Quaternion antiDot(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator antiDot(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator antiDot(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Vector antiDot(const Vector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiDot(const Point& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal antiDot(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk antiDot(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight antiDot(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar antiDot(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiDot(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.WedgeOpGenerator

        [[nodiscard]] constexpr PseudoScalar wedge(const Motor& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar wedge(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar wedge(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar wedge(const Translator& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiWedgeOpGenerator

        [[nodiscard]] constexpr Motor antiWedge(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Plane antiWedge(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Bivector antiWedge(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiWedge(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Quaternion antiWedge(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator antiWedge(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator antiWedge(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Vector antiWedge(const Vector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiWedge(const Point& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal antiWedge(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk antiWedge(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight antiWedge(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar antiWedge(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiWedge(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.CrossOpGenerator

        [[nodiscard]] constexpr Vector cross(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Plane cross(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Plane cross(const Point& b) const noexcept;
        [[nodiscard]] constexpr Vector cross(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr Plane cross(const PointCenter& b) const noexcept;
    };

    static_assert(std::is_trivially_copyable_v<PseudoScalar>);
    static_assert(sizeof(PseudoScalar) == 8 * PseudoScalar::componentsCount, "PseudoScalar must be exactly 8 bytes");
}

// PointCenter.h

// generated by com.github.kright.pga3d.codegen.cpp.Pga3dCodeGenCpp

namespace pga3d {
    struct PointCenter {
        // generated by com.github.kright.pga3d.codegen.cpp.ops.StructFieldsGenerator

        static constexpr int componentsCount = 0;

        [[nodiscard]] constexpr double x() const noexcept { return 0.0; }
        [[nodiscard]] constexpr double y() const noexcept { return 0.0; }
        [[nodiscard]] constexpr double z() const noexcept { return 0.0; }
        [[nodiscard]] constexpr double w() const noexcept { return 1.0; }

        [[nodiscard]] constexpr double wyz() const noexcept { return 0.0; }
        [[nodiscard]] constexpr double wxz() const noexcept { return 0.0; }
        [[nodiscard]] constexpr double wxy() const noexcept { return 0.0; }
        [[nodiscard]] constexpr double xyz() const noexcept { return 1.0; }

        // generated by com.github.kright.pga3d.codegen.cpp.ops.DualOpGenerator

        [[nodiscard]] constexpr Plane dual() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.BulkOpGenerator

        [[nodiscard]] constexpr PointCenter bulk() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ReverseOpGenerator

        [[nodiscard]] constexpr ProjectivePoint reverse() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiReverseOpGenerator

        [[nodiscard]] constexpr PointCenter antiReverse() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ConversionOpGenerator

        [[nodiscard]] constexpr Multivector toMultivector() const noexcept;
        [[nodiscard]] constexpr ProjectivePoint toProjectivePoint() const noexcept;
        [[nodiscard]] constexpr Vector toVectorUnsafe() const noexcept;
        [[nodiscard]] constexpr Point toPoint() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.NormOpGenerator

        [[nodiscard]] constexpr double normSquare() const noexcept;
        [[nodiscard]] inline double norm() const noexcept;
        [[nodiscard]] inline ProjectivePoint normalizedByNorm() const noexcept;
        [[nodiscard]] constexpr double bulkNormSquare() const noexcept;
        [[nodiscard]] inline double bulkNorm() const noexcept;
        [[nodiscard]] inline ProjectivePoint normalizedByBulk() const noexcept;
        [[nodiscard]] constexpr double weightNormSquare() const noexcept;
        [[nodiscard]] inline double weightNorm() const noexcept;
        [[nodiscard]] inline ProjectivePoint normalizedByWeight() const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ProjectionOpsGenerator

        [[nodiscard]] constexpr ProjectivePoint projectOntoPlane(const Plane& plane) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint projectOntoPlane(const PlaneIdeal& plane) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint projectOntoLine(const Bivector& line) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.GeometricOpGenerator

        [[nodiscard]] constexpr Multivector geometric(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Motor geometric(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator geometric(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Multivector geometric(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint geometric(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Point geometric(const Translator& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight geometric(const Vector& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator geometric(const Point& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk geometric(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal geometric(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Vector geometric(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr Plane geometric(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr double geometric(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiGeometricOpGenerator

        [[nodiscard]] constexpr Multivector antiGeometric(const Motor& b) const noexcept;
        [[nodiscard]] constexpr double antiGeometric(const Plane& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal antiGeometric(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk antiGeometric(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal antiGeometric(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal antiGeometric(const Translator& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk antiGeometric(const Vector& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk antiGeometric(const Point& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal antiGeometric(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiGeometric(const PseudoScalar& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.DotOpGenerator

        [[nodiscard]] constexpr Multivector dot(const Motor& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk dot(const Plane& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal dot(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr double dot(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Multivector dot(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint dot(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr PointCenter dot(const Translator& b) const noexcept;
        [[nodiscard]] constexpr double dot(const Point& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk dot(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal dot(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr Plane dot(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr double dot(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiDotOpGenerator

        [[nodiscard]] constexpr ProjectivePoint antiDot(const Motor& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiDot(const PseudoScalar& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.WedgeOpGenerator

        [[nodiscard]] constexpr ProjectivePoint wedge(const Motor& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar wedge(const Plane& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint wedge(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint wedge(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr PointCenter wedge(const Translator& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.AntiWedgeOpGenerator

        [[nodiscard]] constexpr Multivector antiWedge(const Motor& b) const noexcept;
        [[nodiscard]] constexpr double antiWedge(const Plane& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal antiWedge(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk antiWedge(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal antiWedge(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal antiWedge(const Translator& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk antiWedge(const Vector& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk antiWedge(const Point& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal antiWedge(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint antiWedge(const PseudoScalar& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.SandwichOpGenerator

        [[nodiscard]] constexpr Motor sandwich(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Plane sandwich(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Bivector sandwich(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint sandwich(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Quaternion sandwich(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator sandwich(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Translator sandwich(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Vector sandwich(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Point sandwich(const Point& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal sandwich(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk sandwich(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight sandwich(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar sandwich(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr PointCenter sandwich(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.ReverseSandwichOpGenerator

        [[nodiscard]] constexpr Motor reverseSandwich(const Motor& b) const noexcept;
        [[nodiscard]] constexpr Plane reverseSandwich(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Bivector reverseSandwich(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr ProjectivePoint reverseSandwich(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Quaternion reverseSandwich(const Quaternion& b) const noexcept;
        [[nodiscard]] constexpr ProjectiveTranslator reverseSandwich(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Translator reverseSandwich(const Translator& b) const noexcept;
        [[nodiscard]] constexpr Vector reverseSandwich(const Vector& b) const noexcept;
        [[nodiscard]] constexpr Point reverseSandwich(const Point& b) const noexcept;
        [[nodiscard]] constexpr PlaneIdeal reverseSandwich(const PlaneIdeal& b) const noexcept;
        [[nodiscard]] constexpr BivectorBulk reverseSandwich(const BivectorBulk& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight reverseSandwich(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar reverseSandwich(const PseudoScalar& b) const noexcept;
        [[nodiscard]] constexpr PointCenter reverseSandwich(const PointCenter& b) const noexcept;

        // generated by com.github.kright.pga3d.codegen.cpp.ops.CrossOpGenerator

        [[nodiscard]] constexpr Multivector cross(const Motor& b) const noexcept;
        [[nodiscard]] constexpr PseudoScalar cross(const Plane& b) const noexcept;
        [[nodiscard]] constexpr Vector cross(const Bivector& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight cross(const ProjectivePoint& b) const noexcept;
        [[nodiscard]] constexpr Vector cross(const ProjectiveTranslator& b) const noexcept;
        [[nodiscard]] constexpr Vector cross(const Translator& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight cross(const Vector& b) const noexcept;
        [[nodiscard]] constexpr BivectorWeight cross(const Point& b) const noexcept;
        [[nodiscard]] constexpr Vector cross(const BivectorWeight& b) const noexcept;
        [[nodiscard]] constexpr Plane cross(const PseudoScalar& b) const noexcept;
    };

    static_assert(std::is_trivially_copyable_v<PointCenter>);
}

// TranslatorWithQuaternion.h

// generated by com.github.kright.pga3d.codegen.cpp.ops.TranslatorWithQuaternionGenerator

namespace pga3d {

    struct TranslatorWithQuaternion {
        Translator translator;
        Quaternion quaternion;

        [[nodiscard]] constexpr Motor toMotor() const noexcept { return translator.geometric(quaternion); }

        [[nodiscard]] constexpr QuaternionWithTranslator reverse() const noexcept;

        [[nodiscard]] constexpr QuaternionWithTranslator toQuaternionWithTranslator() const noexcept;

        [[nodiscard]] static constexpr TranslatorWithQuaternion id() noexcept { return { .translator = Translator::id(), .quaternion = Quaternion::id() }; }
    };

    struct QuaternionWithTranslator {
        Quaternion quaternion;
        Translator translator;

        [[nodiscard]] constexpr Motor toMotor() const noexcept { return quaternion.geometric(translator); }

        [[nodiscard]] constexpr TranslatorWithQuaternion reverse() const noexcept;

        [[nodiscard]] constexpr TranslatorWithQuaternion toTranslatorWithQuaternion() const noexcept;

        [[nodiscard]] static constexpr QuaternionWithTranslator id() noexcept { return { .quaternion = Quaternion::id(), .translator = Translator::id() }; }
    };

    [[nodiscard]] constexpr QuaternionWithTranslator TranslatorWithQuaternion::reverse() const noexcept { return { .quaternion = quaternion.reverse(), .translator = translator.reverse() }; }
    [[nodiscard]] constexpr QuaternionWithTranslator TranslatorWithQuaternion::toQuaternionWithTranslator() const noexcept { return { .quaternion = quaternion, .translator = quaternion.reverseSandwich(translator).toTranslatorUnsafe() }; };
    [[nodiscard]] constexpr TranslatorWithQuaternion QuaternionWithTranslator::reverse() const noexcept { return { .translator = translator.reverse(), .quaternion = quaternion.reverse() }; }
    [[nodiscard]] constexpr TranslatorWithQuaternion QuaternionWithTranslator::toTranslatorWithQuaternion() const noexcept { return { .translator = quaternion.sandwich(translator).toTranslatorUnsafe(), .quaternion = quaternion }; };
}

// types.h

// generated by com.github.kright.pga3d.codegen.cpp.Pga3dCodeGenCpp

// opsArithmetic.h

// generated by com.github.kright.pga3d.codegen.cpp.ops.ArithmeticsGenerator

namespace pga3d {
    [[nodiscard]] constexpr Multivector operator+(const Multivector& a, const Multivector& b) noexcept { return {.s = (a.s + b.s), .w = (a.w + b.w), .x = (a.x + b.x), .y = (a.y + b.y), .z = (a.z + b.z), .wx = (a.wx + b.wx), .wy = (a.wy + b.wy), .wz = (a.wz + b.wz), .xy = (a.xy + b.xy), .xz = (a.xz + b.xz), .yz = (a.yz + b.yz), .wxy = (a.wxy + b.wxy), .wxz = (a.wxz + b.wxz), .wyz = (a.wyz + b.wyz), .xyz = (a.xyz + b.xyz), .i = (a.i + b.i)}; }
    constexpr Multivector& operator+=(Multivector& a, const Multivector& b) noexcept { a = a + b; return a; }
    [[nodiscard]] constexpr Multivector operator-(const Multivector& a, const Multivector& b) noexcept { return {.s = (a.s - b.s), .w = (a.w - b.w), .x = (a.x - b.x), .y = (a.y - b.y), .z = (a.z - b.z), .wx = (a.wx - b.wx), .wy = (a.wy - b.wy), .wz = (a.wz - b.wz), .xy = (a.xy - b.xy), .xz = (a.xz - b.xz), .yz = (a.yz - b.yz), .wxy = (a.wxy - b.wxy), .wxz = (a.wxz - b.wxz), .wyz = (a.wyz - b.wyz), .xyz = (a.xyz - b.xyz), .i = (a.i - b.i)}; }
    constexpr Multivector& operator-=(Multivector& a, const Multivector& b) noexcept { a = a - b; return a; }

    [[nodiscard]] constexpr Motor operator+(const Motor& a, const Motor& b) noexcept { return {.s = (a.s + b.s), .wx = (a.wx + b.wx), .wy = (a.wy + b.wy), .wz = (a.wz + b.wz), .xy = (a.xy + b.xy), .xz = (a.xz + b.xz), .yz = (a.yz + b.yz), .i = (a.i + b.i)}; }
    constexpr Motor& operator+=(Motor& a, const Motor& b) noexcept { a = a + b; return a; }
    [[nodiscard]] constexpr Motor operator-(const Motor& a, const Motor& b) noexcept { return {.s = (a.s - b.s), .wx = (a.wx - b.wx), .wy = (a.wy - b.wy), .wz = (a.wz - b.wz), .xy = (a.xy - b.xy), .xz = (a.xz - b.xz), .yz = (a.yz - b.yz), .i = (a.i - b.i)}; }
    constexpr Motor& operator-=(Motor& a, const Motor& b) noexcept { a = a - b; return a; }

    [[nodiscard]] constexpr Plane operator+(const Plane& a, const Plane& b) noexcept { return {.x = (a.x + b.x), .y = (a.y + b.y), .z = (a.z + b.z), .w = (a.w + b.w)}; }
    constexpr Plane& operator+=(Plane& a, const Plane& b) noexcept { a = a + b; return a; }
    [[nodiscard]] constexpr Plane operator-(const Plane& a, const Plane& b) noexcept { return {.x = (a.x - b.x), .y = (a.y - b.y), .z = (a.z - b.z), .w = (a.w - b.w)}; }
    constexpr Plane& operator-=(Plane& a, const Plane& b) noexcept { a = a - b; return a; }

    [[nodiscard]] constexpr Bivector operator+(const Bivector& a, const Bivector& b) noexcept { return {.wx = (a.wx + b.wx), .wy = (a.wy + b.wy), .wz = (a.wz + b.wz), .xy = (a.xy + b.xy), .xz = (a.xz + b.xz), .yz = (a.yz + b.yz)}; }
    constexpr Bivector& operator+=(Bivector& a, const Bivector& b) noexcept { a = a + b; return a; }
    [[nodiscard]] constexpr Bivector operator-(const Bivector& a, const Bivector& b) noexcept { return {.wx = (a.wx - b.wx), .wy = (a.wy - b.wy), .wz = (a.wz - b.wz), .xy = (a.xy - b.xy), .xz = (a.xz - b.xz), .yz = (a.yz - b.yz)}; }
    constexpr Bivector& operator-=(Bivector& a, const Bivector& b) noexcept { a = a - b; return a; }
    [[nodiscard]] constexpr Bivector operator+(const Bivector& a, const BivectorBulk& b) noexcept { return {.wx = a.wx, .wy = a.wy, .wz = a.wz, .xy = (a.xy + b.xy), .xz = (a.xz + b.xz), .yz = (a.yz + b.yz)}; }
    constexpr Bivector& operator+=(Bivector& a, const BivectorBulk& b) noexcept { a = a + b; return a; }
    [[nodiscard]] constexpr Bivector operator-(const Bivector& a, const BivectorBulk& b) noexcept { return {.wx = a.wx, .wy = a.wy, .wz = a.wz, .xy = (a.xy - b.xy), .xz = (a.xz - b.xz), .yz = (a.yz - b.yz)}; }
    constexpr Bivector& operator-=(Bivector& a, const BivectorBulk& b) noexcept { a = a - b; return a; }
    [[nodiscard]] constexpr Bivector operator+(const Bivector& a, const BivectorWeight& b) noexcept { return {.wx = (a.wx + b.wx), .wy = (a.wy + b.wy), .wz = (a.wz + b.wz), .xy = a.xy, .xz = a.xz, .yz = a.yz}; }
    constexpr Bivector& operator+=(Bivector& a, const BivectorWeight& b) noexcept { a = a + b; return a; }
    [[nodiscard]] constexpr Bivector operator-(const Bivector& a, const BivectorWeight& b) noexcept { return {.wx = (a.wx - b.wx), .wy = (a.wy - b.wy), .wz = (a.wz - b.wz), .xy = a.xy, .xz = a.xz, .yz = a.yz}; }
    constexpr Bivector& operator-=(Bivector& a, const BivectorWeight& b) noexcept { a = a - b; return a; }

    [[nodiscard]] constexpr ProjectivePoint operator+(const ProjectivePoint& a, const ProjectivePoint& b) noexcept { return {.x = (a.x + b.x), .y = (a.y + b.y), .z = (a.z + b.z), .w = (a.w + b.w)}; }
    constexpr ProjectivePoint& operator+=(ProjectivePoint& a, const ProjectivePoint& b) noexcept { a = a + b; return a; }
    [[nodiscard]] constexpr ProjectivePoint operator-(const ProjectivePoint& a, const ProjectivePoint& b) noexcept { return {.x = (a.x - b.x), .y = (a.y - b.y), .z = (a.z - b.z), .w = (a.w - b.w)}; }
    constexpr ProjectivePoint& operator-=(ProjectivePoint& a, const ProjectivePoint& b) noexcept { a = a - b; return a; }
    [[nodiscard]] constexpr ProjectivePoint operator+(const ProjectivePoint& a, const Point& b) noexcept { return {.x = (a.x + b.x), .y = (a.y + b.y), .z = (a.z + b.z), .w = (1.0 + a.w)}; }
    constexpr ProjectivePoint& operator+=(ProjectivePoint& a, const Point& b) noexcept { a = a + b; return a; }
    [[nodiscard]] constexpr ProjectivePoint operator-(const ProjectivePoint& a, const Point& b) noexcept { return {.x = (a.x - b.x), .y = (a.y - b.y), .z = (a.z - b.z), .w = (-1.0 + a.w)}; }
    constexpr ProjectivePoint& operator-=(ProjectivePoint& a, const Point& b) noexcept { a = a - b; return a; }
    [[nodiscard]] constexpr ProjectivePoint operator+(const ProjectivePoint& a, const Vector& b) noexcept { return {.x = (a.x + b.x), .y = (a.y + b.y), .z = (a.z + b.z), .w = a.w}; }
    constexpr ProjectivePoint& operator+=(ProjectivePoint& a, const Vector& b) noexcept { a = a + b; return a; }
    [[nodiscard]] constexpr ProjectivePoint operator-(const ProjectivePoint& a, const Vector& b) noexcept { return {.x = (a.x - b.x), .y = (a.y - b.y), .z = (a.z - b.z), .w = a.w}; }
    constexpr ProjectivePoint& operator-=(ProjectivePoint& a, const Vector& b) noexcept { a = a - b; return a; }

    [[nodiscard]] constexpr Quaternion operator+(const Quaternion& a, const Quaternion& b) noexcept { return {.s = (a.s + b.s), .xy = (a.xy + b.xy), .xz = (a.xz + b.xz), .yz = (a.yz + b.yz)}; }
    constexpr Quaternion& operator+=(Quaternion& a, const Quaternion& b) noexcept { a = a + b; return a; }
    [[nodiscard]] constexpr Quaternion operator-(const Quaternion& a, const Quaternion& b) noexcept { return {.s = (a.s - b.s), .xy = (a.xy - b.xy), .xz = (a.xz - b.xz), .yz = (a.yz - b.yz)}; }
    constexpr Quaternion& operator-=(Quaternion& a, const Quaternion& b) noexcept { a = a - b; return a; }

    [[nodiscard]] constexpr ProjectiveTranslator operator+(const ProjectiveTranslator& a, const ProjectiveTranslator& b) noexcept { return {.s = (a.s + b.s), .wx = (a.wx + b.wx), .wy = (a.wy + b.wy), .wz = (a.wz + b.wz)}; }
    constexpr ProjectiveTranslator& operator+=(ProjectiveTranslator& a, const ProjectiveTranslator& b) noexcept { a = a + b; return a; }
    [[nodiscard]] constexpr ProjectiveTranslator operator-(const ProjectiveTranslator& a, const ProjectiveTranslator& b) noexcept { return {.s = (a.s - b.s), .wx = (a.wx - b.wx), .wy = (a.wy - b.wy), .wz = (a.wz - b.wz)}; }
    constexpr ProjectiveTranslator& operator-=(ProjectiveTranslator& a, const ProjectiveTranslator& b) noexcept { a = a - b; return a; }

    [[nodiscard]] constexpr ProjectiveTranslator operator+(const Translator& a, const Translator& b) noexcept { return {.s = 2.0, .wx = (a.wx + b.wx), .wy = (a.wy + b.wy), .wz = (a.wz + b.wz)}; }
    [[nodiscard]] constexpr BivectorWeight operator-(const Translator& a, const Translator& b) noexcept { return {.wx = (a.wx - b.wx), .wy = (a.wy - b.wy), .wz = (a.wz - b.wz)}; }

    [[nodiscard]] constexpr ProjectivePoint operator+(const Vector& a, const ProjectivePoint& b) noexcept { return {.x = (a.x + b.x), .y = (a.y + b.y), .z = (a.z + b.z), .w = b.w}; }
    [[nodiscard]] constexpr ProjectivePoint operator-(const Vector& a, const ProjectivePoint& b) noexcept { return {.x = (a.x - b.x), .y = (a.y - b.y), .z = (a.z - b.z), .w = -b.w}; }
    [[nodiscard]] constexpr Point operator+(const Vector& a, const Point& b) noexcept { return {.x = (a.x + b.x), .y = (a.y + b.y), .z = (a.z + b.z)}; }
    [[nodiscard]] constexpr ProjectivePoint operator-(const Vector& a, const Point& b) noexcept { return {.x = (a.x - b.x), .y = (a.y - b.y), .z = (a.z - b.z), .w = -1.0}; }
    [[nodiscard]] constexpr Vector operator+(const Vector& a, const Vector& b) noexcept { return {.x = (a.x + b.x), .y = (a.y + b.y), .z = (a.z + b.z)}; }
    constexpr Vector& operator+=(Vector& a, const Vector& b) noexcept { a = a + b; return a; }
    [[nodiscard]] constexpr Vector operator-(const Vector& a, const Vector& b) noexcept { return {.x = (a.x - b.x), .y = (a.y - b.y), .z = (a.z - b.z)}; }
    constexpr Vector& operator-=(Vector& a, const Vector& b) noexcept { a = a - b; return a; }

    [[nodiscard]] constexpr ProjectivePoint operator+(const Point& a, const ProjectivePoint& b) noexcept { return {.x = (a.x + b.x), .y = (a.y + b.y), .z = (a.z + b.z), .w = (1.0 + b.w)}; }
    [[nodiscard]] constexpr ProjectivePoint operator-(const Point& a, const ProjectivePoint& b) noexcept { return {.x = (a.x - b.x), .y = (a.y - b.y), .z = (a.z - b.z), .w = (1.0 - b.w)}; }
    [[nodiscard]] constexpr ProjectivePoint operator+(const Point& a, const Point& b) noexcept { return {.x = (a.x + b.x), .y = (a.y + b.y), .z = (a.z + b.z), .w = 2.0}; }
    [[nodiscard]] constexpr Vector operator-(const Point& a, const Point& b) noexcept { return {.x = (a.x - b.x), .y = (a.y - b.y), .z = (a.z - b.z)}; }
    [[nodiscard]] constexpr Point operator+(const Point& a, const Vector& b) noexcept { return {.x = (a.x + b.x), .y = (a.y + b.y), .z = (a.z + b.z)}; }
    constexpr Point& operator+=(Point& a, const Vector& b) noexcept { a = a + b; return a; }
    [[nodiscard]] constexpr Point operator-(const Point& a, const Vector& b) noexcept { return {.x = (a.x - b.x), .y = (a.y - b.y), .z = (a.z - b.z)}; }
    constexpr Point& operator-=(Point& a, const Vector& b) noexcept { a = a - b; return a; }

    [[nodiscard]] constexpr PlaneIdeal operator+(const PlaneIdeal& a, const PlaneIdeal& b) noexcept { return {.x = (a.x + b.x), .y = (a.y + b.y), .z = (a.z + b.z)}; }
    constexpr PlaneIdeal& operator+=(PlaneIdeal& a, const PlaneIdeal& b) noexcept { a = a + b; return a; }
    [[nodiscard]] constexpr PlaneIdeal operator-(const PlaneIdeal& a, const PlaneIdeal& b) noexcept { return {.x = (a.x - b.x), .y = (a.y - b.y), .z = (a.z - b.z)}; }
    constexpr PlaneIdeal& operator-=(PlaneIdeal& a, const PlaneIdeal& b) noexcept { a = a - b; return a; }

    [[nodiscard]] constexpr Bivector operator+(const BivectorBulk& a, const Bivector& b) noexcept { return {.wx = b.wx, .wy = b.wy, .wz = b.wz, .xy = (a.xy + b.xy), .xz = (a.xz + b.xz), .yz = (a.yz + b.yz)}; }
    [[nodiscard]] constexpr Bivector operator-(const BivectorBulk& a, const Bivector& b) noexcept { return {.wx = -b.wx, .wy = -b.wy, .wz = -b.wz, .xy = (a.xy - b.xy), .xz = (a.xz - b.xz), .yz = (a.yz - b.yz)}; }
    [[nodiscard]] constexpr BivectorBulk operator+(const BivectorBulk& a, const BivectorBulk& b) noexcept { return {.xy = (a.xy + b.xy), .xz = (a.xz + b.xz), .yz = (a.yz + b.yz)}; }
    constexpr BivectorBulk& operator+=(BivectorBulk& a, const BivectorBulk& b) noexcept { a = a + b; return a; }
    [[nodiscard]] constexpr BivectorBulk operator-(const BivectorBulk& a, const BivectorBulk& b) noexcept { return {.xy = (a.xy - b.xy), .xz = (a.xz - b.xz), .yz = (a.yz - b.yz)}; }
    constexpr BivectorBulk& operator-=(BivectorBulk& a, const BivectorBulk& b) noexcept { a = a - b; return a; }
    [[nodiscard]] constexpr Bivector operator+(const BivectorBulk& a, const BivectorWeight& b) noexcept { return {.wx = b.wx, .wy = b.wy, .wz = b.wz, .xy = a.xy, .xz = a.xz, .yz = a.yz}; }
    [[nodiscard]] constexpr Bivector operator-(const BivectorBulk& a, const BivectorWeight& b) noexcept { return {.wx = -b.wx, .wy = -b.wy, .wz = -b.wz, .xy = a.xy, .xz = a.xz, .yz = a.yz}; }

    [[nodiscard]] constexpr Bivector operator+(const BivectorWeight& a, const Bivector& b) noexcept { return {.wx = (a.wx + b.wx), .wy = (a.wy + b.wy), .wz = (a.wz + b.wz), .xy = b.xy, .xz = b.xz, .yz = b.yz}; }
    [[nodiscard]] constexpr Bivector operator-(const BivectorWeight& a, const Bivector& b) noexcept { return {.wx = (a.wx - b.wx), .wy = (a.wy - b.wy), .wz = (a.wz - b.wz), .xy = -b.xy, .xz = -b.xz, .yz = -b.yz}; }
    [[nodiscard]] constexpr Bivector operator+(const BivectorWeight& a, const BivectorBulk& b) noexcept { return {.wx = a.wx, .wy = a.wy, .wz = a.wz, .xy = b.xy, .xz = b.xz, .yz = b.yz}; }
    [[nodiscard]] constexpr Bivector operator-(const BivectorWeight& a, const BivectorBulk& b) noexcept { return {.wx = a.wx, .wy = a.wy, .wz = a.wz, .xy = -b.xy, .xz = -b.xz, .yz = -b.yz}; }
    [[nodiscard]] constexpr BivectorWeight operator+(const BivectorWeight& a, const BivectorWeight& b) noexcept { return {.wx = (a.wx + b.wx), .wy = (a.wy + b.wy), .wz = (a.wz + b.wz)}; }
    constexpr BivectorWeight& operator+=(BivectorWeight& a, const BivectorWeight& b) noexcept { a = a + b; return a; }
    [[nodiscard]] constexpr BivectorWeight operator-(const BivectorWeight& a, const BivectorWeight& b) noexcept { return {.wx = (a.wx - b.wx), .wy = (a.wy - b.wy), .wz = (a.wz - b.wz)}; }
    constexpr BivectorWeight& operator-=(BivectorWeight& a, const BivectorWeight& b) noexcept { a = a - b; return a; }

    [[nodiscard]] constexpr PseudoScalar operator+(const PseudoScalar& a, const PseudoScalar& b) noexcept { return {.i = (a.i + b.i)}; }
    constexpr PseudoScalar& operator+=(PseudoScalar& a, const PseudoScalar& b) noexcept { a = a + b; return a; }
    [[nodiscard]] constexpr PseudoScalar operator-(const PseudoScalar& a, const PseudoScalar& b) noexcept { return {.i = (a.i - b.i)}; }
    constexpr PseudoScalar& operator-=(PseudoScalar& a, const PseudoScalar& b) noexcept { a = a - b; return a; }

    [[nodiscard]] constexpr ProjectivePoint operator+(const PointCenter& a, const PointCenter& b) noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = 2.0}; }

    [[nodiscard]] constexpr Multivector operator-(const Multivector& a) noexcept { return {.s = -a.s, .w = -a.w, .x = -a.x, .y = -a.y, .z = -a.z, .wx = -a.wx, .wy = -a.wy, .wz = -a.wz, .xy = -a.xy, .xz = -a.xz, .yz = -a.yz, .wxy = -a.wxy, .wxz = -a.wxz, .wyz = -a.wyz, .xyz = -a.xyz, .i = -a.i}; }
    [[nodiscard]] constexpr Motor operator-(const Motor& a) noexcept { return {.s = -a.s, .wx = -a.wx, .wy = -a.wy, .wz = -a.wz, .xy = -a.xy, .xz = -a.xz, .yz = -a.yz, .i = -a.i}; }
    [[nodiscard]] constexpr Plane operator-(const Plane& a) noexcept { return {.x = -a.x, .y = -a.y, .z = -a.z, .w = -a.w}; }
    [[nodiscard]] constexpr Bivector operator-(const Bivector& a) noexcept { return {.wx = -a.wx, .wy = -a.wy, .wz = -a.wz, .xy = -a.xy, .xz = -a.xz, .yz = -a.yz}; }
    [[nodiscard]] constexpr ProjectivePoint operator-(const ProjectivePoint& a) noexcept { return {.x = -a.x, .y = -a.y, .z = -a.z, .w = -a.w}; }
    [[nodiscard]] constexpr Quaternion operator-(const Quaternion& a) noexcept { return {.s = -a.s, .xy = -a.xy, .xz = -a.xz, .yz = -a.yz}; }
    [[nodiscard]] constexpr ProjectiveTranslator operator-(const ProjectiveTranslator& a) noexcept { return {.s = -a.s, .wx = -a.wx, .wy = -a.wy, .wz = -a.wz}; }
    [[nodiscard]] constexpr ProjectiveTranslator operator-(const Translator& a) noexcept { return {.s = -1.0, .wx = -a.wx, .wy = -a.wy, .wz = -a.wz}; }
    [[nodiscard]] constexpr Vector operator-(const Vector& a) noexcept { return {.x = -a.x, .y = -a.y, .z = -a.z}; }
    [[nodiscard]] constexpr ProjectivePoint operator-(const Point& a) noexcept { return {.x = -a.x, .y = -a.y, .z = -a.z, .w = -1.0}; }
    [[nodiscard]] constexpr PlaneIdeal operator-(const PlaneIdeal& a) noexcept { return {.x = -a.x, .y = -a.y, .z = -a.z}; }
    [[nodiscard]] constexpr BivectorBulk operator-(const BivectorBulk& a) noexcept { return {.xy = -a.xy, .xz = -a.xz, .yz = -a.yz}; }
    [[nodiscard]] constexpr BivectorWeight operator-(const BivectorWeight& a) noexcept { return {.wx = -a.wx, .wy = -a.wy, .wz = -a.wz}; }
    [[nodiscard]] constexpr PseudoScalar operator-(const PseudoScalar& a) noexcept { return {.i = -a.i}; }
    [[nodiscard]] constexpr ProjectivePoint operator-(const PointCenter& a) noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = -1.0}; }

    [[nodiscard]] constexpr Multivector operator*(const Multivector& a, double d) noexcept { return {.s = a.s * d, .w = a.w * d, .x = a.x * d, .y = a.y * d, .z = a.z * d, .wx = a.wx * d, .wy = a.wy * d, .wz = a.wz * d, .xy = a.xy * d, .xz = a.xz * d, .yz = a.yz * d, .wxy = a.wxy * d, .wxz = a.wxz * d, .wyz = a.wyz * d, .xyz = a.xyz * d, .i = a.i * d}; }
    [[nodiscard]] constexpr Multivector operator*(double d, const Multivector& a) noexcept { return {.s = a.s * d, .w = a.w * d, .x = a.x * d, .y = a.y * d, .z = a.z * d, .wx = a.wx * d, .wy = a.wy * d, .wz = a.wz * d, .xy = a.xy * d, .xz = a.xz * d, .yz = a.yz * d, .wxy = a.wxy * d, .wxz = a.wxz * d, .wyz = a.wyz * d, .xyz = a.xyz * d, .i = a.i * d}; }
    [[nodiscard]] constexpr Multivector operator/(const Multivector& a, double d) noexcept { return a * (1.0 / d); }
    constexpr Multivector& operator*=(Multivector& a, double d) noexcept { a = a * d; return a; }
    constexpr Multivector& operator/=(Multivector& a, double d) noexcept { a = a / d; return a; }

    [[nodiscard]] constexpr Motor operator*(const Motor& a, double d) noexcept { return {.s = a.s * d, .wx = a.wx * d, .wy = a.wy * d, .wz = a.wz * d, .xy = a.xy * d, .xz = a.xz * d, .yz = a.yz * d, .i = a.i * d}; }
    [[nodiscard]] constexpr Motor operator*(double d, const Motor& a) noexcept { return {.s = a.s * d, .wx = a.wx * d, .wy = a.wy * d, .wz = a.wz * d, .xy = a.xy * d, .xz = a.xz * d, .yz = a.yz * d, .i = a.i * d}; }
    [[nodiscard]] constexpr Motor operator/(const Motor& a, double d) noexcept { return a * (1.0 / d); }
    constexpr Motor& operator*=(Motor& a, double d) noexcept { a = a * d; return a; }
    constexpr Motor& operator/=(Motor& a, double d) noexcept { a = a / d; return a; }

    [[nodiscard]] constexpr Plane operator*(const Plane& a, double d) noexcept { return {.x = a.x * d, .y = a.y * d, .z = a.z * d, .w = a.w * d}; }
    [[nodiscard]] constexpr Plane operator*(double d, const Plane& a) noexcept { return {.x = a.x * d, .y = a.y * d, .z = a.z * d, .w = a.w * d}; }
    [[nodiscard]] constexpr Plane operator/(const Plane& a, double d) noexcept { return a * (1.0 / d); }
    constexpr Plane& operator*=(Plane& a, double d) noexcept { a = a * d; return a; }
    constexpr Plane& operator/=(Plane& a, double d) noexcept { a = a / d; return a; }

    [[nodiscard]] constexpr Bivector operator*(const Bivector& a, double d) noexcept { return {.wx = a.wx * d, .wy = a.wy * d, .wz = a.wz * d, .xy = a.xy * d, .xz = a.xz * d, .yz = a.yz * d}; }
    [[nodiscard]] constexpr Bivector operator*(double d, const Bivector& a) noexcept { return {.wx = a.wx * d, .wy = a.wy * d, .wz = a.wz * d, .xy = a.xy * d, .xz = a.xz * d, .yz = a.yz * d}; }
    [[nodiscard]] constexpr Bivector operator/(const Bivector& a, double d) noexcept { return a * (1.0 / d); }
    constexpr Bivector& operator*=(Bivector& a, double d) noexcept { a = a * d; return a; }
    constexpr Bivector& operator/=(Bivector& a, double d) noexcept { a = a / d; return a; }

    [[nodiscard]] constexpr ProjectivePoint operator*(const ProjectivePoint& a, double d) noexcept { return {.x = a.x * d, .y = a.y * d, .z = a.z * d, .w = a.w * d}; }
    [[nodiscard]] constexpr ProjectivePoint operator*(double d, const ProjectivePoint& a) noexcept { return {.x = a.x * d, .y = a.y * d, .z = a.z * d, .w = a.w * d}; }
    [[nodiscard]] constexpr ProjectivePoint operator/(const ProjectivePoint& a, double d) noexcept { return a * (1.0 / d); }
    constexpr ProjectivePoint& operator*=(ProjectivePoint& a, double d) noexcept { a = a * d; return a; }
    constexpr ProjectivePoint& operator/=(ProjectivePoint& a, double d) noexcept { a = a / d; return a; }

    [[nodiscard]] constexpr Quaternion operator*(const Quaternion& a, double d) noexcept { return {.s = a.s * d, .xy = a.xy * d, .xz = a.xz * d, .yz = a.yz * d}; }
    [[nodiscard]] constexpr Quaternion operator*(double d, const Quaternion& a) noexcept { return {.s = a.s * d, .xy = a.xy * d, .xz = a.xz * d, .yz = a.yz * d}; }
    [[nodiscard]] constexpr Quaternion operator/(const Quaternion& a, double d) noexcept { return a * (1.0 / d); }
    constexpr Quaternion& operator*=(Quaternion& a, double d) noexcept { a = a * d; return a; }
    constexpr Quaternion& operator/=(Quaternion& a, double d) noexcept { a = a / d; return a; }

    [[nodiscard]] constexpr ProjectiveTranslator operator*(const ProjectiveTranslator& a, double d) noexcept { return {.s = a.s * d, .wx = a.wx * d, .wy = a.wy * d, .wz = a.wz * d}; }
    [[nodiscard]] constexpr ProjectiveTranslator operator*(double d, const ProjectiveTranslator& a) noexcept { return {.s = a.s * d, .wx = a.wx * d, .wy = a.wy * d, .wz = a.wz * d}; }
    [[nodiscard]] constexpr ProjectiveTranslator operator/(const ProjectiveTranslator& a, double d) noexcept { return a * (1.0 / d); }
    constexpr ProjectiveTranslator& operator*=(ProjectiveTranslator& a, double d) noexcept { a = a * d; return a; }
    constexpr ProjectiveTranslator& operator/=(ProjectiveTranslator& a, double d) noexcept { a = a / d; return a; }

    [[nodiscard]] constexpr ProjectiveTranslator operator*(const Translator& a, double d) noexcept { return {.s = d, .wx = a.wx * d, .wy = a.wy * d, .wz = a.wz * d}; }
    [[nodiscard]] constexpr ProjectiveTranslator operator*(double d, const Translator& a) noexcept { return {.s = d, .wx = a.wx * d, .wy = a.wy * d, .wz = a.wz * d}; }
    [[nodiscard]] constexpr ProjectiveTranslator operator/(const Translator& a, double d) noexcept { return a * (1.0 / d); }

    [[nodiscard]] constexpr Vector operator*(const Vector& a, double d) noexcept { return {.x = a.x * d, .y = a.y * d, .z = a.z * d}; }
    [[nodiscard]] constexpr Vector operator*(double d, const Vector& a) noexcept { return {.x = a.x * d, .y = a.y * d, .z = a.z * d}; }
    [[nodiscard]] constexpr Vector operator/(const Vector& a, double d) noexcept { return a * (1.0 / d); }
    constexpr Vector& operator*=(Vector& a, double d) noexcept { a = a * d; return a; }
    constexpr Vector& operator/=(Vector& a, double d) noexcept { a = a / d; return a; }

    [[nodiscard]] constexpr ProjectivePoint operator*(const Point& a, double d) noexcept { return {.x = a.x * d, .y = a.y * d, .z = a.z * d, .w = d}; }
    [[nodiscard]] constexpr ProjectivePoint operator*(double d, const Point& a) noexcept { return {.x = a.x * d, .y = a.y * d, .z = a.z * d, .w = d}; }
    [[nodiscard]] constexpr ProjectivePoint operator/(const Point& a, double d) noexcept { return a * (1.0 / d); }

    [[nodiscard]] constexpr PlaneIdeal operator*(const PlaneIdeal& a, double d) noexcept { return {.x = a.x * d, .y = a.y * d, .z = a.z * d}; }
    [[nodiscard]] constexpr PlaneIdeal operator*(double d, const PlaneIdeal& a) noexcept { return {.x = a.x * d, .y = a.y * d, .z = a.z * d}; }
    [[nodiscard]] constexpr PlaneIdeal operator/(const PlaneIdeal& a, double d) noexcept { return a * (1.0 / d); }
    constexpr PlaneIdeal& operator*=(PlaneIdeal& a, double d) noexcept { a = a * d; return a; }
    constexpr PlaneIdeal& operator/=(PlaneIdeal& a, double d) noexcept { a = a / d; return a; }

    [[nodiscard]] constexpr BivectorBulk operator*(const BivectorBulk& a, double d) noexcept { return {.xy = a.xy * d, .xz = a.xz * d, .yz = a.yz * d}; }
    [[nodiscard]] constexpr BivectorBulk operator*(double d, const BivectorBulk& a) noexcept { return {.xy = a.xy * d, .xz = a.xz * d, .yz = a.yz * d}; }
    [[nodiscard]] constexpr BivectorBulk operator/(const BivectorBulk& a, double d) noexcept { return a * (1.0 / d); }
    constexpr BivectorBulk& operator*=(BivectorBulk& a, double d) noexcept { a = a * d; return a; }
    constexpr BivectorBulk& operator/=(BivectorBulk& a, double d) noexcept { a = a / d; return a; }

    [[nodiscard]] constexpr BivectorWeight operator*(const BivectorWeight& a, double d) noexcept { return {.wx = a.wx * d, .wy = a.wy * d, .wz = a.wz * d}; }
    [[nodiscard]] constexpr BivectorWeight operator*(double d, const BivectorWeight& a) noexcept { return {.wx = a.wx * d, .wy = a.wy * d, .wz = a.wz * d}; }
    [[nodiscard]] constexpr BivectorWeight operator/(const BivectorWeight& a, double d) noexcept { return a * (1.0 / d); }
    constexpr BivectorWeight& operator*=(BivectorWeight& a, double d) noexcept { a = a * d; return a; }
    constexpr BivectorWeight& operator/=(BivectorWeight& a, double d) noexcept { a = a / d; return a; }

    [[nodiscard]] constexpr PseudoScalar operator*(const PseudoScalar& a, double d) noexcept { return {.i = a.i * d}; }
    [[nodiscard]] constexpr PseudoScalar operator*(double d, const PseudoScalar& a) noexcept { return {.i = a.i * d}; }
    [[nodiscard]] constexpr PseudoScalar operator/(const PseudoScalar& a, double d) noexcept { return a * (1.0 / d); }
    constexpr PseudoScalar& operator*=(PseudoScalar& a, double d) noexcept { a = a * d; return a; }
    constexpr PseudoScalar& operator/=(PseudoScalar& a, double d) noexcept { a = a / d; return a; }

    [[nodiscard]] constexpr ProjectivePoint operator*(const PointCenter& a, double d) noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = d}; }
    [[nodiscard]] constexpr ProjectivePoint operator*(double d, const PointCenter& a) noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = d}; }
    [[nodiscard]] constexpr ProjectivePoint operator/(const PointCenter& a, double d) noexcept { return a * (1.0 / d); }

    constexpr Multivector Multivector::madd(const Multivector& other, double mult) const noexcept { return {.s = std::fma(other.s, mult, s), .w = std::fma(other.w, mult, w), .x = std::fma(other.x, mult, x), .y = std::fma(other.y, mult, y), .z = std::fma(other.z, mult, z), .wx = std::fma(other.wx, mult, wx), .wy = std::fma(other.wy, mult, wy), .wz = std::fma(other.wz, mult, wz), .xy = std::fma(other.xy, mult, xy), .xz = std::fma(other.xz, mult, xz), .yz = std::fma(other.yz, mult, yz), .wxy = std::fma(other.wxy, mult, wxy), .wxz = std::fma(other.wxz, mult, wxz), .wyz = std::fma(other.wyz, mult, wyz), .xyz = std::fma(other.xyz, mult, xyz), .i = std::fma(other.i, mult, i)}; }
    constexpr Motor Motor::madd(const Motor& other, double mult) const noexcept { return {.s = std::fma(other.s, mult, s), .wx = std::fma(other.wx, mult, wx), .wy = std::fma(other.wy, mult, wy), .wz = std::fma(other.wz, mult, wz), .xy = std::fma(other.xy, mult, xy), .xz = std::fma(other.xz, mult, xz), .yz = std::fma(other.yz, mult, yz), .i = std::fma(other.i, mult, i)}; }
    constexpr Plane Plane::madd(const Plane& other, double mult) const noexcept { return {.x = std::fma(other.x, mult, x), .y = std::fma(other.y, mult, y), .z = std::fma(other.z, mult, z), .w = std::fma(other.w, mult, w)}; }
    constexpr Bivector Bivector::madd(const Bivector& other, double mult) const noexcept { return {.wx = std::fma(other.wx, mult, wx), .wy = std::fma(other.wy, mult, wy), .wz = std::fma(other.wz, mult, wz), .xy = std::fma(other.xy, mult, xy), .xz = std::fma(other.xz, mult, xz), .yz = std::fma(other.yz, mult, yz)}; }
    constexpr ProjectivePoint ProjectivePoint::madd(const ProjectivePoint& other, double mult) const noexcept { return {.x = std::fma(-other.x, mult, -x), .y = std::fma(other.y, mult, y), .z = std::fma(-other.z, mult, -z), .w = std::fma(other.w, mult, w)}; }
    constexpr Quaternion Quaternion::madd(const Quaternion& other, double mult) const noexcept { return {.s = std::fma(other.s, mult, s), .xy = std::fma(other.xy, mult, xy), .xz = std::fma(other.xz, mult, xz), .yz = std::fma(other.yz, mult, yz)}; }
    constexpr ProjectiveTranslator ProjectiveTranslator::madd(const ProjectiveTranslator& other, double mult) const noexcept { return {.s = std::fma(other.s, mult, s), .wx = std::fma(other.wx, mult, wx), .wy = std::fma(other.wy, mult, wy), .wz = std::fma(other.wz, mult, wz)}; }
    constexpr Vector Vector::madd(const Vector& other, double mult) const noexcept { return {.x = std::fma(-other.x, mult, -x), .y = std::fma(other.y, mult, y), .z = std::fma(-other.z, mult, -z)}; }
    constexpr Point Point::madd(const Vector& other, double mult) const noexcept { return {.x = std::fma(-other.x, mult, -x), .y = std::fma(other.y, mult, y), .z = std::fma(-other.z, mult, -z)}; }
    constexpr PlaneIdeal PlaneIdeal::madd(const PlaneIdeal& other, double mult) const noexcept { return {.x = std::fma(other.x, mult, x), .y = std::fma(other.y, mult, y), .z = std::fma(other.z, mult, z)}; }
    constexpr BivectorBulk BivectorBulk::madd(const BivectorBulk& other, double mult) const noexcept { return {.xy = std::fma(other.xy, mult, xy), .xz = std::fma(other.xz, mult, xz), .yz = std::fma(other.yz, mult, yz)}; }
    constexpr BivectorWeight BivectorWeight::madd(const BivectorWeight& other, double mult) const noexcept { return {.wx = std::fma(other.wx, mult, wx), .wy = std::fma(other.wy, mult, wy), .wz = std::fma(other.wz, mult, wz)}; }
    constexpr PseudoScalar PseudoScalar::madd(const PseudoScalar& other, double mult) const noexcept { return {.i = std::fma(other.i, mult, i)}; }

    [[nodiscard]] constexpr bool operator==(const Multivector& a, const Multivector& b) noexcept { return a.s == b.s && a.w == b.w && a.x == b.x && a.y == b.y && a.z == b.z && a.wx == b.wx && a.wy == b.wy && a.wz == b.wz && a.xy == b.xy && a.xz == b.xz && a.yz == b.yz && a.wxy == b.wxy && a.wxz == b.wxz && a.wyz == b.wyz && a.xyz == b.xyz && a.i == b.i; }
    [[nodiscard]] constexpr bool operator==(const Motor& a, const Motor& b) noexcept { return a.s == b.s && a.wx == b.wx && a.wy == b.wy && a.wz == b.wz && a.xy == b.xy && a.xz == b.xz && a.yz == b.yz && a.i == b.i; }
    [[nodiscard]] constexpr bool operator==(const Plane& a, const Plane& b) noexcept { return a.x == b.x && a.y == b.y && a.z == b.z && a.w == b.w; }
    [[nodiscard]] constexpr bool operator==(const Bivector& a, const Bivector& b) noexcept { return a.wx == b.wx && a.wy == b.wy && a.wz == b.wz && a.xy == b.xy && a.xz == b.xz && a.yz == b.yz; }
    [[nodiscard]] constexpr bool operator==(const ProjectivePoint& a, const ProjectivePoint& b) noexcept { return a.x == b.x && a.y == b.y && a.z == b.z && a.w == b.w; }
    [[nodiscard]] constexpr bool operator==(const Quaternion& a, const Quaternion& b) noexcept { return a.s == b.s && a.xy == b.xy && a.xz == b.xz && a.yz == b.yz; }
    [[nodiscard]] constexpr bool operator==(const ProjectiveTranslator& a, const ProjectiveTranslator& b) noexcept { return a.s == b.s && a.wx == b.wx && a.wy == b.wy && a.wz == b.wz; }
    [[nodiscard]] constexpr bool operator==(const Translator& a, const Translator& b) noexcept { return a.wx == b.wx && a.wy == b.wy && a.wz == b.wz; }
    [[nodiscard]] constexpr bool operator==(const Vector& a, const Vector& b) noexcept { return a.x == b.x && a.y == b.y && a.z == b.z; }
    [[nodiscard]] constexpr bool operator==(const Point& a, const Point& b) noexcept { return a.x == b.x && a.y == b.y && a.z == b.z; }
    [[nodiscard]] constexpr bool operator==(const PlaneIdeal& a, const PlaneIdeal& b) noexcept { return a.x == b.x && a.y == b.y && a.z == b.z; }
    [[nodiscard]] constexpr bool operator==(const BivectorBulk& a, const BivectorBulk& b) noexcept { return a.xy == b.xy && a.xz == b.xz && a.yz == b.yz; }
    [[nodiscard]] constexpr bool operator==(const BivectorWeight& a, const BivectorWeight& b) noexcept { return a.wx == b.wx && a.wy == b.wy && a.wz == b.wz; }
    [[nodiscard]] constexpr bool operator==(const PseudoScalar& a, const PseudoScalar& b) noexcept { return a.i == b.i; }
}

// opsNorm.h

// generated by com.github.kright.pga3d.codegen.cpp.ops.NormOpGenerator

namespace pga3d {
    constexpr double Multivector::normSquare() const noexcept { return (i * i + s * s + w * w + wx * wx + wxy * wxy + wxz * wxz + wy * wy + wyz * wyz + wz * wz + x * x + xy * xy + xyz * xyz + xz * xz + y * y + yz * yz + z * z); }
    inline double Multivector::norm() const noexcept { return std::sqrt(normSquare()); }
    inline Multivector Multivector::normalizedByNorm() const noexcept { return *this / norm(); }

    constexpr double Multivector::bulkNormSquare() const noexcept { return (s * s + x * x + xy * xy + xyz * xyz + xz * xz + y * y + yz * yz + z * z); }
    inline double Multivector::bulkNorm() const noexcept { return std::sqrt(bulkNormSquare()); }
    inline Multivector Multivector::normalizedByBulk() const noexcept { return *this / bulkNorm(); }

    constexpr double Multivector::weightNormSquare() const noexcept { return (i * i + w * w + wx * wx + wxy * wxy + wxz * wxz + wy * wy + wyz * wyz + wz * wz); }
    inline double Multivector::weightNorm() const noexcept { return std::sqrt(weightNormSquare()); }
    inline Multivector Multivector::normalizedByWeight() const noexcept { return *this / weightNorm(); }

    constexpr double Motor::normSquare() const noexcept { return (i * i + s * s + wx * wx + wy * wy + wz * wz + xy * xy + xz * xz + yz * yz); }
    inline double Motor::norm() const noexcept { return std::sqrt(normSquare()); }
    inline Motor Motor::normalizedByNorm() const noexcept { return *this / norm(); }

    constexpr double Motor::bulkNormSquare() const noexcept { return (s * s + xy * xy + xz * xz + yz * yz); }
    inline double Motor::bulkNorm() const noexcept { return std::sqrt(bulkNormSquare()); }
    inline Motor Motor::normalizedByBulk() const noexcept { return *this / bulkNorm(); }

    constexpr double Motor::weightNormSquare() const noexcept { return (i * i + wx * wx + wy * wy + wz * wz); }
    inline double Motor::weightNorm() const noexcept { return std::sqrt(weightNormSquare()); }
    inline Motor Motor::normalizedByWeight() const noexcept { return *this / weightNorm(); }

    constexpr double Plane::normSquare() const noexcept { return (w * w + x * x + y * y + z * z); }
    inline double Plane::norm() const noexcept { return std::sqrt(normSquare()); }
    inline Plane Plane::normalizedByNorm() const noexcept { return *this / norm(); }

    constexpr double Plane::bulkNormSquare() const noexcept { return (x * x + y * y + z * z); }
    inline double Plane::bulkNorm() const noexcept { return std::sqrt(bulkNormSquare()); }
    inline Plane Plane::normalizedByBulk() const noexcept { return *this / bulkNorm(); }

    constexpr double Plane::weightNormSquare() const noexcept { return w * w; }
    inline double Plane::weightNorm() const noexcept { return std::sqrt(weightNormSquare()); }
    inline Plane Plane::normalizedByWeight() const noexcept { return *this / weightNorm(); }

    constexpr double Bivector::normSquare() const noexcept { return (wx * wx + wy * wy + wz * wz + xy * xy + xz * xz + yz * yz); }
    inline double Bivector::norm() const noexcept { return std::sqrt(normSquare()); }
    inline Bivector Bivector::normalizedByNorm() const noexcept { return *this / norm(); }

    constexpr double Bivector::bulkNormSquare() const noexcept { return (xy * xy + xz * xz + yz * yz); }
    inline double Bivector::bulkNorm() const noexcept { return std::sqrt(bulkNormSquare()); }
    inline Bivector Bivector::normalizedByBulk() const noexcept { return *this / bulkNorm(); }

    constexpr double Bivector::weightNormSquare() const noexcept { return (wx * wx + wy * wy + wz * wz); }
    inline double Bivector::weightNorm() const noexcept { return std::sqrt(weightNormSquare()); }
    inline Bivector Bivector::normalizedByWeight() const noexcept { return *this / weightNorm(); }

    constexpr double ProjectivePoint::normSquare() const noexcept { return (w * w + x * x + y * y + z * z); }
    inline double ProjectivePoint::norm() const noexcept { return std::sqrt(normSquare()); }
    inline ProjectivePoint ProjectivePoint::normalizedByNorm() const noexcept { return *this / norm(); }

    constexpr double ProjectivePoint::bulkNormSquare() const noexcept { return w * w; }
    inline double ProjectivePoint::bulkNorm() const noexcept { return std::sqrt(bulkNormSquare()); }
    inline ProjectivePoint ProjectivePoint::normalizedByBulk() const noexcept { return *this / bulkNorm(); }

    constexpr double ProjectivePoint::weightNormSquare() const noexcept { return (x * x + y * y + z * z); }
    inline double ProjectivePoint::weightNorm() const noexcept { return std::sqrt(weightNormSquare()); }
    inline ProjectivePoint ProjectivePoint::normalizedByWeight() const noexcept { return *this / weightNorm(); }

    constexpr double Quaternion::normSquare() const noexcept { return (s * s + xy * xy + xz * xz + yz * yz); }
    inline double Quaternion::norm() const noexcept { return std::sqrt(normSquare()); }
    inline Quaternion Quaternion::normalizedByNorm() const noexcept { return *this / norm(); }

    constexpr double Quaternion::bulkNormSquare() const noexcept { return (s * s + xy * xy + xz * xz + yz * yz); }
    inline double Quaternion::bulkNorm() const noexcept { return std::sqrt(bulkNormSquare()); }
    inline Quaternion Quaternion::normalizedByBulk() const noexcept { return *this / bulkNorm(); }

    constexpr double ProjectiveTranslator::normSquare() const noexcept { return (s * s + wx * wx + wy * wy + wz * wz); }
    inline double ProjectiveTranslator::norm() const noexcept { return std::sqrt(normSquare()); }
    inline ProjectiveTranslator ProjectiveTranslator::normalizedByNorm() const noexcept { return *this / norm(); }

    constexpr double ProjectiveTranslator::bulkNormSquare() const noexcept { return s * s; }
    inline double ProjectiveTranslator::bulkNorm() const noexcept { return std::sqrt(bulkNormSquare()); }
    inline ProjectiveTranslator ProjectiveTranslator::normalizedByBulk() const noexcept { return *this / bulkNorm(); }

    constexpr double ProjectiveTranslator::weightNormSquare() const noexcept { return (wx * wx + wy * wy + wz * wz); }
    inline double ProjectiveTranslator::weightNorm() const noexcept { return std::sqrt(weightNormSquare()); }
    inline ProjectiveTranslator ProjectiveTranslator::normalizedByWeight() const noexcept { return *this / weightNorm(); }

    constexpr double Translator::normSquare() const noexcept { return (1.0 + wx * wx + wy * wy + wz * wz); }
    inline double Translator::norm() const noexcept { return std::sqrt(normSquare()); }
    inline ProjectiveTranslator Translator::normalizedByNorm() const noexcept { return *this / norm(); }

    constexpr double Translator::bulkNormSquare() const noexcept { return 1.0; }
    inline double Translator::bulkNorm() const noexcept { return std::sqrt(bulkNormSquare()); }
    inline ProjectiveTranslator Translator::normalizedByBulk() const noexcept { return *this / bulkNorm(); }

    constexpr double Translator::weightNormSquare() const noexcept { return (wx * wx + wy * wy + wz * wz); }
    inline double Translator::weightNorm() const noexcept { return std::sqrt(weightNormSquare()); }
    inline ProjectiveTranslator Translator::normalizedByWeight() const noexcept { return *this / weightNorm(); }

    constexpr double Vector::normSquare() const noexcept { return (x * x + y * y + z * z); }
    inline double Vector::norm() const noexcept { return std::sqrt(normSquare()); }
    inline Vector Vector::normalizedByNorm() const noexcept { return *this / norm(); }

    constexpr double Vector::weightNormSquare() const noexcept { return (x * x + y * y + z * z); }
    inline double Vector::weightNorm() const noexcept { return std::sqrt(weightNormSquare()); }
    inline Vector Vector::normalizedByWeight() const noexcept { return *this / weightNorm(); }

    constexpr double Point::normSquare() const noexcept { return (1.0 + x * x + y * y + z * z); }
    inline double Point::norm() const noexcept { return std::sqrt(normSquare()); }
    inline ProjectivePoint Point::normalizedByNorm() const noexcept { return *this / norm(); }

    constexpr double Point::bulkNormSquare() const noexcept { return 1.0; }
    inline double Point::bulkNorm() const noexcept { return std::sqrt(bulkNormSquare()); }
    inline ProjectivePoint Point::normalizedByBulk() const noexcept { return *this / bulkNorm(); }

    constexpr double Point::weightNormSquare() const noexcept { return (x * x + y * y + z * z); }
    inline double Point::weightNorm() const noexcept { return std::sqrt(weightNormSquare()); }
    inline ProjectivePoint Point::normalizedByWeight() const noexcept { return *this / weightNorm(); }

    constexpr double PlaneIdeal::normSquare() const noexcept { return (x * x + y * y + z * z); }
    inline double PlaneIdeal::norm() const noexcept { return std::sqrt(normSquare()); }
    inline PlaneIdeal PlaneIdeal::normalizedByNorm() const noexcept { return *this / norm(); }

    constexpr double PlaneIdeal::bulkNormSquare() const noexcept { return (x * x + y * y + z * z); }
    inline double PlaneIdeal::bulkNorm() const noexcept { return std::sqrt(bulkNormSquare()); }
    inline PlaneIdeal PlaneIdeal::normalizedByBulk() const noexcept { return *this / bulkNorm(); }

    constexpr double BivectorBulk::normSquare() const noexcept { return (xy * xy + xz * xz + yz * yz); }
    inline double BivectorBulk::norm() const noexcept { return std::sqrt(normSquare()); }
    inline BivectorBulk BivectorBulk::normalizedByNorm() const noexcept { return *this / norm(); }

    constexpr double BivectorBulk::bulkNormSquare() const noexcept { return (xy * xy + xz * xz + yz * yz); }
    inline double BivectorBulk::bulkNorm() const noexcept { return std::sqrt(bulkNormSquare()); }
    inline BivectorBulk BivectorBulk::normalizedByBulk() const noexcept { return *this / bulkNorm(); }

    constexpr double BivectorWeight::normSquare() const noexcept { return (wx * wx + wy * wy + wz * wz); }
    inline double BivectorWeight::norm() const noexcept { return std::sqrt(normSquare()); }
    inline BivectorWeight BivectorWeight::normalizedByNorm() const noexcept { return *this / norm(); }

    constexpr double BivectorWeight::weightNormSquare() const noexcept { return (wx * wx + wy * wy + wz * wz); }
    inline double BivectorWeight::weightNorm() const noexcept { return std::sqrt(weightNormSquare()); }
    inline BivectorWeight BivectorWeight::normalizedByWeight() const noexcept { return *this / weightNorm(); }

    constexpr double PseudoScalar::normSquare() const noexcept { return i * i; }
    inline double PseudoScalar::norm() const noexcept { return std::sqrt(normSquare()); }
    inline PseudoScalar PseudoScalar::normalizedByNorm() const noexcept { return *this / norm(); }

    constexpr double PseudoScalar::weightNormSquare() const noexcept { return i * i; }
    inline double PseudoScalar::weightNorm() const noexcept { return std::sqrt(weightNormSquare()); }
    inline PseudoScalar PseudoScalar::normalizedByWeight() const noexcept { return *this / weightNorm(); }

    constexpr double PointCenter::normSquare() const noexcept { return 1.0; }
    inline double PointCenter::norm() const noexcept { return std::sqrt(normSquare()); }
    inline ProjectivePoint PointCenter::normalizedByNorm() const noexcept { return *this / norm(); }

    constexpr double PointCenter::bulkNormSquare() const noexcept { return 1.0; }
    inline double PointCenter::bulkNorm() const noexcept { return std::sqrt(bulkNormSquare()); }
    inline ProjectivePoint PointCenter::normalizedByBulk() const noexcept { return *this / bulkNorm(); }

    constexpr double PointCenter::weightNormSquare() const noexcept { return 0.0; }
    inline double PointCenter::weightNorm() const noexcept { return std::sqrt(weightNormSquare()); }
    inline ProjectivePoint PointCenter::normalizedByWeight() const noexcept { return *this / weightNorm(); }

}

// opsGeometric.h

// generated by com.github.kright.pga3d.codegen.cpp.ops.GeometricOpGenerator

namespace pga3d {
    constexpr Multivector Multivector::geometric(const Multivector& b) const noexcept { return {.s = (b.s * s + b.x * x + b.y * y + b.z * z - b.xy * xy - b.xyz * xyz - b.xz * xz - b.yz * yz), .w = (b.i * xyz + b.s * w + b.w * s + b.x * wx + b.y * wy + b.z * wz - b.wx * x - b.wxy * xy - b.wxz * xz - b.wy * y - b.wyz * yz - b.wz * z - b.xy * wxy - b.xyz * i - b.xz * wxz - b.yz * wyz), .x = (b.s * x + b.x * s + b.y * xy + b.z * xz - b.xy * y - b.xyz * yz - b.xz * z - b.yz * xyz), .y = (b.s * y + b.xy * x + b.xyz * xz + b.xz * xyz + b.y * s + b.z * yz - b.x * xy - b.yz * z), .z = (b.s * z + b.xz * x + b.yz * y + b.z * s - b.x * xz - b.xy * xyz - b.xyz * xy - b.y * yz), .wx = (b.s * wx + b.wx * s + b.wxy * y + b.wxz * z + b.wy * xy + b.wyz * xyz + b.wz * xz + b.x * w + b.y * wxy + b.z * wxz - b.i * yz - b.w * x - b.xy * wy - b.xyz * wyz - b.xz * wz - b.yz * i), .wy = (b.i * xz + b.s * wy + b.wy * s + b.wyz * z + b.wz * yz + b.xy * wx + b.xyz * wxz + b.xz * i + b.y * w + b.z * wyz - b.w * y - b.wx * xy - b.wxy * x - b.wxz * xyz - b.x * wxy - b.yz * wz), .wz = (b.s * wz + b.wxy * xyz + b.wz * s + b.xz * wx + b.yz * wy + b.z * w - b.i * xy - b.w * z - b.wx * xz - b.wxz * x - b.wy * yz - b.wyz * y - b.x * wxz - b.xy * i - b.xyz * wxy - b.y * wyz), .xy = (b.s * xy + b.xy * s + b.xyz * z + b.xz * yz + b.y * x + b.z * xyz - b.x * y - b.yz * xz), .xz = (b.s * xz + b.xz * s + b.yz * xy + b.z * x - b.x * z - b.xy * yz - b.xyz * y - b.y * xyz), .yz = (b.s * yz + b.x * xyz + b.xy * xz + b.xyz * x + b.yz * s + b.z * y - b.xz * xy - b.y * z), .wxy = (b.s * wxy + b.w * xy + b.wx * y + b.wxy * s + b.wxz * yz + b.xy * w + b.xyz * wz + b.xz * wyz + b.y * wx + b.z * i - b.i * z - b.wy * x - b.wyz * xz - b.wz * xyz - b.x * wy - b.yz * wxz), .wxz = (b.i * y + b.s * wxz + b.w * xz + b.wx * z + b.wxz * s + b.wy * xyz + b.wyz * xy + b.xz * w + b.yz * wxy + b.z * wx - b.wxy * yz - b.wz * x - b.x * wz - b.xy * wyz - b.xyz * wy - b.y * i), .wyz = (b.s * wyz + b.w * yz + b.wxy * xz + b.wy * z + b.wyz * s + b.x * i + b.xy * wxz + b.xyz * wx + b.yz * w + b.z * wy - b.i * x - b.wx * xyz - b.wxz * xy - b.wz * y - b.xz * wxy - b.y * wz), .xyz = (b.s * xyz + b.x * yz + b.xy * z + b.xyz * s + b.yz * x + b.z * xy - b.xz * y - b.y * xz), .i = (b.i * s + b.s * i + b.wx * yz + b.wxz * y + b.wz * xy + b.x * wyz + b.xy * wz + b.xyz * w + b.yz * wx + b.z * wxy - b.w * xyz - b.wxy * z - b.wy * xz - b.wyz * x - b.xz * wy - b.y * wxz)}; }

    constexpr Motor Motor::geometric(const Motor& b) const noexcept { return {.s = (b.s * s - b.xy * xy - b.xz * xz - b.yz * yz), .wx = (b.s * wx + b.wx * s + b.wy * xy + b.wz * xz - b.i * yz - b.xy * wy - b.xz * wz - b.yz * i), .wy = (b.i * xz + b.s * wy + b.wy * s + b.wz * yz + b.xy * wx + b.xz * i - b.wx * xy - b.yz * wz), .wz = (b.s * wz + b.wz * s + b.xz * wx + b.yz * wy - b.i * xy - b.wx * xz - b.wy * yz - b.xy * i), .xy = (b.s * xy + b.xy * s + b.xz * yz - b.yz * xz), .xz = (b.s * xz + b.xz * s + b.yz * xy - b.xy * yz), .yz = (b.s * yz + b.xy * xz + b.yz * s - b.xz * xy), .i = (b.i * s + b.s * i + b.wx * yz + b.wz * xy + b.xy * wz + b.yz * wx - b.wy * xz - b.xz * wy)}; }
    constexpr Multivector Motor::geometric(const Plane& b) const noexcept { return {.s = 0.0, .w = (b.w * s + b.x * wx + b.y * wy + b.z * wz), .x = (b.x * s + b.y * xy + b.z * xz), .y = (b.y * s + b.z * yz - b.x * xy), .z = (b.z * s - b.x * xz - b.y * yz), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.w * xy + b.y * wx + b.z * i - b.x * wy), .wxz = (b.w * xz + b.z * wx - b.x * wz - b.y * i), .wyz = (b.w * yz + b.x * i + b.z * wy - b.y * wz), .xyz = (b.x * yz + b.z * xy - b.y * xz), .i = 0.0}; }
    constexpr Motor Motor::geometric(const Bivector& b) const noexcept { return {.s = (-b.xy * xy - b.xz * xz - b.yz * yz), .wx = (b.wx * s + b.wy * xy + b.wz * xz - b.xy * wy - b.xz * wz - b.yz * i), .wy = (b.wy * s + b.wz * yz + b.xy * wx + b.xz * i - b.wx * xy - b.yz * wz), .wz = (b.wz * s + b.xz * wx + b.yz * wy - b.wx * xz - b.wy * yz - b.xy * i), .xy = (b.xy * s + b.xz * yz - b.yz * xz), .xz = (b.xz * s + b.yz * xy - b.xy * yz), .yz = (b.xy * xz + b.yz * s - b.xz * xy), .i = (b.wx * yz + b.wz * xy + b.xy * wz + b.yz * wx - b.wy * xz - b.xz * wy)}; }
    constexpr Multivector Motor::geometric(const ProjectivePoint& b) const noexcept { return {.s = 0.0, .w = (b.x * yz + b.z * xy - b.w * i - b.y * xz), .x = -b.w * yz, .y = b.w * xz, .z = -b.w * xy, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.w * wz + b.x * xz + b.y * yz - b.z * s), .wxz = (b.y * s + b.z * yz - b.w * wy - b.x * xy), .wyz = (b.w * wx - b.x * s - b.y * xy - b.z * xz), .xyz = b.w * s, .i = 0.0}; }
    constexpr Motor Motor::geometric(const Quaternion& b) const noexcept { return {.s = (b.s * s - b.xy * xy - b.xz * xz - b.yz * yz), .wx = (b.s * wx - b.xy * wy - b.xz * wz - b.yz * i), .wy = (b.s * wy + b.xy * wx + b.xz * i - b.yz * wz), .wz = (b.s * wz + b.xz * wx + b.yz * wy - b.xy * i), .xy = (b.s * xy + b.xy * s + b.xz * yz - b.yz * xz), .xz = (b.s * xz + b.xz * s + b.yz * xy - b.xy * yz), .yz = (b.s * yz + b.xy * xz + b.yz * s - b.xz * xy), .i = (b.s * i + b.xy * wz + b.yz * wx - b.xz * wy)}; }
    constexpr Motor Motor::geometric(const ProjectiveTranslator& b) const noexcept { return {.s = b.s * s, .wx = (b.s * wx + b.wx * s + b.wy * xy + b.wz * xz), .wy = (b.s * wy + b.wy * s + b.wz * yz - b.wx * xy), .wz = (b.s * wz + b.wz * s - b.wx * xz - b.wy * yz), .xy = b.s * xy, .xz = b.s * xz, .yz = b.s * yz, .i = (b.s * i + b.wx * yz + b.wz * xy - b.wy * xz)}; }
    constexpr Motor Motor::geometric(const Translator& b) const noexcept { return {.s = s, .wx = (wx + b.wx * s + b.wy * xy + b.wz * xz), .wy = (wy + b.wy * s + b.wz * yz - b.wx * xy), .wz = (wz + b.wz * s - b.wx * xz - b.wy * yz), .xy = xy, .xz = xz, .yz = yz, .i = (i + b.wx * yz + b.wz * xy - b.wy * xz)}; }
    constexpr Multivector Motor::geometric(const Vector& b) const noexcept { return {.s = 0.0, .w = (b.x * yz + b.z * xy - b.y * xz), .x = 0.0, .y = 0.0, .z = 0.0, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.x * xz + b.y * yz - b.z * s), .wxz = (b.y * s + b.z * yz - b.x * xy), .wyz = (-b.x * s - b.y * xy - b.z * xz), .xyz = 0.0, .i = 0.0}; }
    constexpr Multivector Motor::geometric(const Point& b) const noexcept { return {.s = 0.0, .w = (-i + b.x * yz + b.z * xy - b.y * xz), .x = -yz, .y = xz, .z = -xy, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (wz + b.x * xz + b.y * yz - b.z * s), .wxz = (-wy + b.y * s + b.z * yz - b.x * xy), .wyz = (wx - b.x * s - b.y * xy - b.z * xz), .xyz = s, .i = 0.0}; }
    constexpr Multivector Motor::geometric(const PlaneIdeal& b) const noexcept { return {.s = 0.0, .w = (b.x * wx + b.y * wy + b.z * wz), .x = (b.x * s + b.y * xy + b.z * xz), .y = (b.y * s + b.z * yz - b.x * xy), .z = (b.z * s - b.x * xz - b.y * yz), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.y * wx + b.z * i - b.x * wy), .wxz = (b.z * wx - b.x * wz - b.y * i), .wyz = (b.x * i + b.z * wy - b.y * wz), .xyz = (b.x * yz + b.z * xy - b.y * xz), .i = 0.0}; }
    constexpr Motor Motor::geometric(const BivectorBulk& b) const noexcept { return {.s = (-b.xy * xy - b.xz * xz - b.yz * yz), .wx = (-b.xy * wy - b.xz * wz - b.yz * i), .wy = (b.xy * wx + b.xz * i - b.yz * wz), .wz = (b.xz * wx + b.yz * wy - b.xy * i), .xy = (b.xy * s + b.xz * yz - b.yz * xz), .xz = (b.xz * s + b.yz * xy - b.xy * yz), .yz = (b.xy * xz + b.yz * s - b.xz * xy), .i = (b.xy * wz + b.yz * wx - b.xz * wy)}; }
    constexpr Motor Motor::geometric(const BivectorWeight& b) const noexcept { return {.s = 0.0, .wx = (b.wx * s + b.wy * xy + b.wz * xz), .wy = (b.wy * s + b.wz * yz - b.wx * xy), .wz = (b.wz * s - b.wx * xz - b.wy * yz), .xy = 0.0, .xz = 0.0, .yz = 0.0, .i = (b.wx * yz + b.wz * xy - b.wy * xz)}; }
    constexpr Motor Motor::geometric(const PseudoScalar& b) const noexcept { return {.s = 0.0, .wx = -b.i * yz, .wy = b.i * xz, .wz = -b.i * xy, .xy = 0.0, .xz = 0.0, .yz = 0.0, .i = b.i * s}; }
    constexpr Multivector Motor::geometric(const PointCenter& b) const noexcept { return {.s = 0.0, .w = -i, .x = -yz, .y = xz, .z = -xy, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = wz, .wxz = -wy, .wyz = wx, .xyz = s, .i = 0.0}; }

    constexpr Multivector Plane::geometric(const Motor& b) const noexcept { return {.s = 0.0, .w = (b.s * w - b.wx * x - b.wy * y - b.wz * z), .x = (b.s * x - b.xy * y - b.xz * z), .y = (b.s * y + b.xy * x - b.yz * z), .z = (b.s * z + b.xz * x + b.yz * y), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.wx * y + b.xy * w - b.i * z - b.wy * x), .wxz = (b.i * y + b.wx * z + b.xz * w - b.wz * x), .wyz = (b.wy * z + b.yz * w - b.i * x - b.wz * y), .xyz = (b.xy * z + b.yz * x - b.xz * y), .i = 0.0}; }
    constexpr Motor Plane::geometric(const Plane& b) const noexcept { return {.s = (b.x * x + b.y * y + b.z * z), .wx = (b.x * w - b.w * x), .wy = (b.y * w - b.w * y), .wz = (b.z * w - b.w * z), .xy = (b.y * x - b.x * y), .xz = (b.z * x - b.x * z), .yz = (b.z * y - b.y * z), .i = 0.0}; }
    constexpr Multivector Plane::geometric(const Bivector& b) const noexcept { return {.s = 0.0, .w = (-b.wx * x - b.wy * y - b.wz * z), .x = (-b.xy * y - b.xz * z), .y = (b.xy * x - b.yz * z), .z = (b.xz * x + b.yz * y), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.wx * y + b.xy * w - b.wy * x), .wxz = (b.wx * z + b.xz * w - b.wz * x), .wyz = (b.wy * z + b.yz * w - b.wz * y), .xyz = (b.xy * z + b.yz * x - b.xz * y), .i = 0.0}; }
    constexpr Motor Plane::geometric(const ProjectivePoint& b) const noexcept { return {.s = 0.0, .wx = (b.y * z - b.z * y), .wy = (b.z * x - b.x * z), .wz = (b.x * y - b.y * x), .xy = b.w * z, .xz = -b.w * y, .yz = b.w * x, .i = (b.w * w + b.x * x + b.y * y + b.z * z)}; }
    constexpr Multivector Plane::geometric(const Quaternion& b) const noexcept { return {.s = 0.0, .w = b.s * w, .x = (b.s * x - b.xy * y - b.xz * z), .y = (b.s * y + b.xy * x - b.yz * z), .z = (b.s * z + b.xz * x + b.yz * y), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = b.xy * w, .wxz = b.xz * w, .wyz = b.yz * w, .xyz = (b.xy * z + b.yz * x - b.xz * y), .i = 0.0}; }
    constexpr Multivector Plane::geometric(const ProjectiveTranslator& b) const noexcept { return {.s = 0.0, .w = (b.s * w - b.wx * x - b.wy * y - b.wz * z), .x = b.s * x, .y = b.s * y, .z = b.s * z, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.wx * y - b.wy * x), .wxz = (b.wx * z - b.wz * x), .wyz = (b.wy * z - b.wz * y), .xyz = 0.0, .i = 0.0}; }
    constexpr Multivector Plane::geometric(const Translator& b) const noexcept { return {.s = 0.0, .w = (w - b.wx * x - b.wy * y - b.wz * z), .x = x, .y = y, .z = z, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.wx * y - b.wy * x), .wxz = (b.wx * z - b.wz * x), .wyz = (b.wy * z - b.wz * y), .xyz = 0.0, .i = 0.0}; }
    constexpr Motor Plane::geometric(const Vector& b) const noexcept { return {.s = 0.0, .wx = (b.y * z - b.z * y), .wy = (b.z * x - b.x * z), .wz = (b.x * y - b.y * x), .xy = 0.0, .xz = 0.0, .yz = 0.0, .i = (b.x * x + b.y * y + b.z * z)}; }
    constexpr Motor Plane::geometric(const Point& b) const noexcept { return {.s = 0.0, .wx = (b.y * z - b.z * y), .wy = (b.z * x - b.x * z), .wz = (b.x * y - b.y * x), .xy = z, .xz = -y, .yz = x, .i = (w + b.x * x + b.y * y + b.z * z)}; }
    constexpr Motor Plane::geometric(const PlaneIdeal& b) const noexcept { return {.s = (b.x * x + b.y * y + b.z * z), .wx = b.x * w, .wy = b.y * w, .wz = b.z * w, .xy = (b.y * x - b.x * y), .xz = (b.z * x - b.x * z), .yz = (b.z * y - b.y * z), .i = 0.0}; }
    constexpr Multivector Plane::geometric(const BivectorBulk& b) const noexcept { return {.s = 0.0, .w = 0.0, .x = (-b.xy * y - b.xz * z), .y = (b.xy * x - b.yz * z), .z = (b.xz * x + b.yz * y), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = b.xy * w, .wxz = b.xz * w, .wyz = b.yz * w, .xyz = (b.xy * z + b.yz * x - b.xz * y), .i = 0.0}; }
    constexpr Multivector Plane::geometric(const BivectorWeight& b) const noexcept { return {.s = 0.0, .w = (-b.wx * x - b.wy * y - b.wz * z), .x = 0.0, .y = 0.0, .z = 0.0, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.wx * y - b.wy * x), .wxz = (b.wx * z - b.wz * x), .wyz = (b.wy * z - b.wz * y), .xyz = 0.0, .i = 0.0}; }
    constexpr Vector Plane::geometric(const PseudoScalar& b) const noexcept { return {.x = b.i * x, .y = b.i * y, .z = b.i * z}; }
    constexpr Motor Plane::geometric(const PointCenter& b) const noexcept { return {.s = 0.0, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = z, .xz = -y, .yz = x, .i = w}; }

    constexpr Motor Bivector::geometric(const Motor& b) const noexcept { return {.s = (-b.xy * xy - b.xz * xz - b.yz * yz), .wx = (b.s * wx + b.wy * xy + b.wz * xz - b.i * yz - b.xy * wy - b.xz * wz), .wy = (b.i * xz + b.s * wy + b.wz * yz + b.xy * wx - b.wx * xy - b.yz * wz), .wz = (b.s * wz + b.xz * wx + b.yz * wy - b.i * xy - b.wx * xz - b.wy * yz), .xy = (b.s * xy + b.xz * yz - b.yz * xz), .xz = (b.s * xz + b.yz * xy - b.xy * yz), .yz = (b.s * yz + b.xy * xz - b.xz * xy), .i = (b.wx * yz + b.wz * xy + b.xy * wz + b.yz * wx - b.wy * xz - b.xz * wy)}; }
    constexpr Multivector Bivector::geometric(const Plane& b) const noexcept { return {.s = 0.0, .w = (b.x * wx + b.y * wy + b.z * wz), .x = (b.y * xy + b.z * xz), .y = (b.z * yz - b.x * xy), .z = (-b.x * xz - b.y * yz), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.w * xy + b.y * wx - b.x * wy), .wxz = (b.w * xz + b.z * wx - b.x * wz), .wyz = (b.w * yz + b.z * wy - b.y * wz), .xyz = (b.x * yz + b.z * xy - b.y * xz), .i = 0.0}; }
    constexpr Motor Bivector::geometric(const Bivector& b) const noexcept { return {.s = (-b.xy * xy - b.xz * xz - b.yz * yz), .wx = (b.wy * xy + b.wz * xz - b.xy * wy - b.xz * wz), .wy = (b.wz * yz + b.xy * wx - b.wx * xy - b.yz * wz), .wz = (b.xz * wx + b.yz * wy - b.wx * xz - b.wy * yz), .xy = (b.xz * yz - b.yz * xz), .xz = (b.yz * xy - b.xy * yz), .yz = (b.xy * xz - b.xz * xy), .i = (b.wx * yz + b.wz * xy + b.xy * wz + b.yz * wx - b.wy * xz - b.xz * wy)}; }
    constexpr Multivector Bivector::geometric(const ProjectivePoint& b) const noexcept { return {.s = 0.0, .w = (b.x * yz + b.z * xy - b.y * xz), .x = -b.w * yz, .y = b.w * xz, .z = -b.w * xy, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.w * wz + b.x * xz + b.y * yz), .wxz = (b.z * yz - b.w * wy - b.x * xy), .wyz = (b.w * wx - b.y * xy - b.z * xz), .xyz = 0.0, .i = 0.0}; }
    constexpr Motor Bivector::geometric(const Quaternion& b) const noexcept { return {.s = (-b.xy * xy - b.xz * xz - b.yz * yz), .wx = (b.s * wx - b.xy * wy - b.xz * wz), .wy = (b.s * wy + b.xy * wx - b.yz * wz), .wz = (b.s * wz + b.xz * wx + b.yz * wy), .xy = (b.s * xy + b.xz * yz - b.yz * xz), .xz = (b.s * xz + b.yz * xy - b.xy * yz), .yz = (b.s * yz + b.xy * xz - b.xz * xy), .i = (b.xy * wz + b.yz * wx - b.xz * wy)}; }
    constexpr Motor Bivector::geometric(const ProjectiveTranslator& b) const noexcept { return {.s = 0.0, .wx = (b.s * wx + b.wy * xy + b.wz * xz), .wy = (b.s * wy + b.wz * yz - b.wx * xy), .wz = (b.s * wz - b.wx * xz - b.wy * yz), .xy = b.s * xy, .xz = b.s * xz, .yz = b.s * yz, .i = (b.wx * yz + b.wz * xy - b.wy * xz)}; }
    constexpr Motor Bivector::geometric(const Translator& b) const noexcept { return {.s = 0.0, .wx = (wx + b.wy * xy + b.wz * xz), .wy = (wy + b.wz * yz - b.wx * xy), .wz = (wz - b.wx * xz - b.wy * yz), .xy = xy, .xz = xz, .yz = yz, .i = (b.wx * yz + b.wz * xy - b.wy * xz)}; }
    constexpr Multivector Bivector::geometric(const Vector& b) const noexcept { return {.s = 0.0, .w = (b.x * yz + b.z * xy - b.y * xz), .x = 0.0, .y = 0.0, .z = 0.0, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.x * xz + b.y * yz), .wxz = (b.z * yz - b.x * xy), .wyz = (-b.y * xy - b.z * xz), .xyz = 0.0, .i = 0.0}; }
    constexpr Multivector Bivector::geometric(const Point& b) const noexcept { return {.s = 0.0, .w = (b.x * yz + b.z * xy - b.y * xz), .x = -yz, .y = xz, .z = -xy, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (wz + b.x * xz + b.y * yz), .wxz = (-wy + b.z * yz - b.x * xy), .wyz = (wx - b.y * xy - b.z * xz), .xyz = 0.0, .i = 0.0}; }
    constexpr Multivector Bivector::geometric(const PlaneIdeal& b) const noexcept { return {.s = 0.0, .w = (b.x * wx + b.y * wy + b.z * wz), .x = (b.y * xy + b.z * xz), .y = (b.z * yz - b.x * xy), .z = (-b.x * xz - b.y * yz), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.y * wx - b.x * wy), .wxz = (b.z * wx - b.x * wz), .wyz = (b.z * wy - b.y * wz), .xyz = (b.x * yz + b.z * xy - b.y * xz), .i = 0.0}; }
    constexpr Motor Bivector::geometric(const BivectorBulk& b) const noexcept { return {.s = (-b.xy * xy - b.xz * xz - b.yz * yz), .wx = (-b.xy * wy - b.xz * wz), .wy = (b.xy * wx - b.yz * wz), .wz = (b.xz * wx + b.yz * wy), .xy = (b.xz * yz - b.yz * xz), .xz = (b.yz * xy - b.xy * yz), .yz = (b.xy * xz - b.xz * xy), .i = (b.xy * wz + b.yz * wx - b.xz * wy)}; }
    constexpr Motor Bivector::geometric(const BivectorWeight& b) const noexcept { return {.s = 0.0, .wx = (b.wy * xy + b.wz * xz), .wy = (b.wz * yz - b.wx * xy), .wz = (-b.wx * xz - b.wy * yz), .xy = 0.0, .xz = 0.0, .yz = 0.0, .i = (b.wx * yz + b.wz * xy - b.wy * xz)}; }
    constexpr BivectorWeight Bivector::geometric(const PseudoScalar& b) const noexcept { return {.wx = -b.i * yz, .wy = b.i * xz, .wz = -b.i * xy}; }
    constexpr Multivector Bivector::geometric(const PointCenter& b) const noexcept { return {.s = 0.0, .w = 0.0, .x = -yz, .y = xz, .z = -xy, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = wz, .wxz = -wy, .wyz = wx, .xyz = 0.0, .i = 0.0}; }

    constexpr Multivector ProjectivePoint::geometric(const Motor& b) const noexcept { return {.s = 0.0, .w = (b.i * w + b.xy * z + b.yz * x - b.xz * y), .x = -b.yz * w, .y = b.xz * w, .z = -b.xy * w, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (-b.s * z - b.wz * w - b.xz * x - b.yz * y), .wxz = (b.s * y + b.wy * w + b.xy * x - b.yz * z), .wyz = (b.xy * y + b.xz * z - b.s * x - b.wx * w), .xyz = b.s * w, .i = 0.0}; }
    constexpr Motor ProjectivePoint::geometric(const Plane& b) const noexcept { return {.s = 0.0, .wx = (b.z * y - b.y * z), .wy = (b.x * z - b.z * x), .wz = (b.y * x - b.x * y), .xy = b.z * w, .xz = -b.y * w, .yz = b.x * w, .i = (-b.w * w - b.x * x - b.y * y - b.z * z)}; }
    constexpr Multivector ProjectivePoint::geometric(const Bivector& b) const noexcept { return {.s = 0.0, .w = (b.xy * z + b.yz * x - b.xz * y), .x = -b.yz * w, .y = b.xz * w, .z = -b.xy * w, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (-b.wz * w - b.xz * x - b.yz * y), .wxz = (b.wy * w + b.xy * x - b.yz * z), .wyz = (b.xy * y + b.xz * z - b.wx * w), .xyz = 0.0, .i = 0.0}; }
    constexpr ProjectiveTranslator ProjectivePoint::geometric(const ProjectivePoint& b) const noexcept { return {.s = -b.w * w, .wx = (b.w * x - b.x * w), .wy = (b.w * y - b.y * w), .wz = (b.w * z - b.z * w)}; }
    constexpr Multivector ProjectivePoint::geometric(const Quaternion& b) const noexcept { return {.s = 0.0, .w = (b.xy * z + b.yz * x - b.xz * y), .x = -b.yz * w, .y = b.xz * w, .z = -b.xy * w, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (-b.s * z - b.xz * x - b.yz * y), .wxz = (b.s * y + b.xy * x - b.yz * z), .wyz = (b.xy * y + b.xz * z - b.s * x), .xyz = b.s * w, .i = 0.0}; }
    constexpr ProjectivePoint ProjectivePoint::geometric(const ProjectiveTranslator& b) const noexcept { return {.x = (b.s * x + b.wx * w), .y = (b.s * y + b.wy * w), .z = (b.s * z + b.wz * w), .w = b.s * w}; }
    constexpr ProjectivePoint ProjectivePoint::geometric(const Translator& b) const noexcept { return {.x = (x + b.wx * w), .y = (y + b.wy * w), .z = (z + b.wz * w), .w = w}; }
    constexpr BivectorWeight ProjectivePoint::geometric(const Vector& b) const noexcept { return {.wx = -b.x * w, .wy = -b.y * w, .wz = -b.z * w}; }
    constexpr ProjectiveTranslator ProjectivePoint::geometric(const Point& b) const noexcept { return {.s = -w, .wx = (x - b.x * w), .wy = (y - b.y * w), .wz = (z - b.z * w)}; }
    constexpr Motor ProjectivePoint::geometric(const PlaneIdeal& b) const noexcept { return {.s = 0.0, .wx = (b.z * y - b.y * z), .wy = (b.x * z - b.z * x), .wz = (b.y * x - b.x * y), .xy = b.z * w, .xz = -b.y * w, .yz = b.x * w, .i = (-b.x * x - b.y * y - b.z * z)}; }
    constexpr Multivector ProjectivePoint::geometric(const BivectorBulk& b) const noexcept { return {.s = 0.0, .w = (b.xy * z + b.yz * x - b.xz * y), .x = -b.yz * w, .y = b.xz * w, .z = -b.xy * w, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (-b.xz * x - b.yz * y), .wxz = (b.xy * x - b.yz * z), .wyz = (b.xy * y + b.xz * z), .xyz = 0.0, .i = 0.0}; }
    constexpr Vector ProjectivePoint::geometric(const BivectorWeight& b) const noexcept { return {.x = b.wx * w, .y = b.wy * w, .z = b.wz * w}; }
    constexpr Plane ProjectivePoint::geometric(const PseudoScalar& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = b.i * w}; }
    constexpr ProjectiveTranslator ProjectivePoint::geometric(const PointCenter& b) const noexcept { return {.s = -w, .wx = x, .wy = y, .wz = z}; }

    constexpr Motor Quaternion::geometric(const Motor& b) const noexcept { return {.s = (b.s * s - b.xy * xy - b.xz * xz - b.yz * yz), .wx = (b.wx * s + b.wy * xy + b.wz * xz - b.i * yz), .wy = (b.i * xz + b.wy * s + b.wz * yz - b.wx * xy), .wz = (b.wz * s - b.i * xy - b.wx * xz - b.wy * yz), .xy = (b.s * xy + b.xy * s + b.xz * yz - b.yz * xz), .xz = (b.s * xz + b.xz * s + b.yz * xy - b.xy * yz), .yz = (b.s * yz + b.xy * xz + b.yz * s - b.xz * xy), .i = (b.i * s + b.wx * yz + b.wz * xy - b.wy * xz)}; }
    constexpr Multivector Quaternion::geometric(const Plane& b) const noexcept { return {.s = 0.0, .w = b.w * s, .x = (b.x * s + b.y * xy + b.z * xz), .y = (b.y * s + b.z * yz - b.x * xy), .z = (b.z * s - b.x * xz - b.y * yz), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = b.w * xy, .wxz = b.w * xz, .wyz = b.w * yz, .xyz = (b.x * yz + b.z * xy - b.y * xz), .i = 0.0}; }
    constexpr Motor Quaternion::geometric(const Bivector& b) const noexcept { return {.s = (-b.xy * xy - b.xz * xz - b.yz * yz), .wx = (b.wx * s + b.wy * xy + b.wz * xz), .wy = (b.wy * s + b.wz * yz - b.wx * xy), .wz = (b.wz * s - b.wx * xz - b.wy * yz), .xy = (b.xy * s + b.xz * yz - b.yz * xz), .xz = (b.xz * s + b.yz * xy - b.xy * yz), .yz = (b.xy * xz + b.yz * s - b.xz * xy), .i = (b.wx * yz + b.wz * xy - b.wy * xz)}; }
    constexpr Multivector Quaternion::geometric(const ProjectivePoint& b) const noexcept { return {.s = 0.0, .w = (b.x * yz + b.z * xy - b.y * xz), .x = -b.w * yz, .y = b.w * xz, .z = -b.w * xy, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.x * xz + b.y * yz - b.z * s), .wxz = (b.y * s + b.z * yz - b.x * xy), .wyz = (-b.x * s - b.y * xy - b.z * xz), .xyz = b.w * s, .i = 0.0}; }
    constexpr Quaternion Quaternion::geometric(const Quaternion& b) const noexcept { return {.s = (b.s * s - b.xy * xy - b.xz * xz - b.yz * yz), .xy = (b.s * xy + b.xy * s + b.xz * yz - b.yz * xz), .xz = (b.s * xz + b.xz * s + b.yz * xy - b.xy * yz), .yz = (b.s * yz + b.xy * xz + b.yz * s - b.xz * xy)}; }
    constexpr Motor Quaternion::geometric(const ProjectiveTranslator& b) const noexcept { return {.s = b.s * s, .wx = (b.wx * s + b.wy * xy + b.wz * xz), .wy = (b.wy * s + b.wz * yz - b.wx * xy), .wz = (b.wz * s - b.wx * xz - b.wy * yz), .xy = b.s * xy, .xz = b.s * xz, .yz = b.s * yz, .i = (b.wx * yz + b.wz * xy - b.wy * xz)}; }
    constexpr Motor Quaternion::geometric(const Translator& b) const noexcept { return {.s = s, .wx = (b.wx * s + b.wy * xy + b.wz * xz), .wy = (b.wy * s + b.wz * yz - b.wx * xy), .wz = (b.wz * s - b.wx * xz - b.wy * yz), .xy = xy, .xz = xz, .yz = yz, .i = (b.wx * yz + b.wz * xy - b.wy * xz)}; }
    constexpr Multivector Quaternion::geometric(const Vector& b) const noexcept { return {.s = 0.0, .w = (b.x * yz + b.z * xy - b.y * xz), .x = 0.0, .y = 0.0, .z = 0.0, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.x * xz + b.y * yz - b.z * s), .wxz = (b.y * s + b.z * yz - b.x * xy), .wyz = (-b.x * s - b.y * xy - b.z * xz), .xyz = 0.0, .i = 0.0}; }
    constexpr Multivector Quaternion::geometric(const Point& b) const noexcept { return {.s = 0.0, .w = (b.x * yz + b.z * xy - b.y * xz), .x = -yz, .y = xz, .z = -xy, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.x * xz + b.y * yz - b.z * s), .wxz = (b.y * s + b.z * yz - b.x * xy), .wyz = (-b.x * s - b.y * xy - b.z * xz), .xyz = s, .i = 0.0}; }
    constexpr Multivector Quaternion::geometric(const PlaneIdeal& b) const noexcept { return {.s = 0.0, .w = 0.0, .x = (b.x * s + b.y * xy + b.z * xz), .y = (b.y * s + b.z * yz - b.x * xy), .z = (b.z * s - b.x * xz - b.y * yz), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = 0.0, .wxz = 0.0, .wyz = 0.0, .xyz = (b.x * yz + b.z * xy - b.y * xz), .i = 0.0}; }
    constexpr Quaternion Quaternion::geometric(const BivectorBulk& b) const noexcept { return {.s = (-b.xy * xy - b.xz * xz - b.yz * yz), .xy = (b.xy * s + b.xz * yz - b.yz * xz), .xz = (b.xz * s + b.yz * xy - b.xy * yz), .yz = (b.xy * xz + b.yz * s - b.xz * xy)}; }
    constexpr Motor Quaternion::geometric(const BivectorWeight& b) const noexcept { return {.s = 0.0, .wx = (b.wx * s + b.wy * xy + b.wz * xz), .wy = (b.wy * s + b.wz * yz - b.wx * xy), .wz = (b.wz * s - b.wx * xz - b.wy * yz), .xy = 0.0, .xz = 0.0, .yz = 0.0, .i = (b.wx * yz + b.wz * xy - b.wy * xz)}; }
    constexpr Motor Quaternion::geometric(const PseudoScalar& b) const noexcept { return {.s = 0.0, .wx = -b.i * yz, .wy = b.i * xz, .wz = -b.i * xy, .xy = 0.0, .xz = 0.0, .yz = 0.0, .i = b.i * s}; }
    constexpr Multivector Quaternion::geometric(const PointCenter& b) const noexcept { return {.s = 0.0, .w = 0.0, .x = -yz, .y = xz, .z = -xy, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = 0.0, .wxz = 0.0, .wyz = 0.0, .xyz = s, .i = 0.0}; }

    constexpr Motor ProjectiveTranslator::geometric(const Motor& b) const noexcept { return {.s = b.s * s, .wx = (b.s * wx + b.wx * s - b.xy * wy - b.xz * wz), .wy = (b.s * wy + b.wy * s + b.xy * wx - b.yz * wz), .wz = (b.s * wz + b.wz * s + b.xz * wx + b.yz * wy), .xy = b.xy * s, .xz = b.xz * s, .yz = b.yz * s, .i = (b.i * s + b.xy * wz + b.yz * wx - b.xz * wy)}; }
    constexpr Multivector ProjectiveTranslator::geometric(const Plane& b) const noexcept { return {.s = 0.0, .w = (b.w * s + b.x * wx + b.y * wy + b.z * wz), .x = b.x * s, .y = b.y * s, .z = b.z * s, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.y * wx - b.x * wy), .wxz = (b.z * wx - b.x * wz), .wyz = (b.z * wy - b.y * wz), .xyz = 0.0, .i = 0.0}; }
    constexpr Motor ProjectiveTranslator::geometric(const Bivector& b) const noexcept { return {.s = 0.0, .wx = (b.wx * s - b.xy * wy - b.xz * wz), .wy = (b.wy * s + b.xy * wx - b.yz * wz), .wz = (b.wz * s + b.xz * wx + b.yz * wy), .xy = b.xy * s, .xz = b.xz * s, .yz = b.yz * s, .i = (b.xy * wz + b.yz * wx - b.xz * wy)}; }
    constexpr ProjectivePoint ProjectiveTranslator::geometric(const ProjectivePoint& b) const noexcept { return {.x = (b.x * s - b.w * wx), .y = (b.y * s - b.w * wy), .z = (b.z * s - b.w * wz), .w = b.w * s}; }
    constexpr Motor ProjectiveTranslator::geometric(const Quaternion& b) const noexcept { return {.s = b.s * s, .wx = (b.s * wx - b.xy * wy - b.xz * wz), .wy = (b.s * wy + b.xy * wx - b.yz * wz), .wz = (b.s * wz + b.xz * wx + b.yz * wy), .xy = b.xy * s, .xz = b.xz * s, .yz = b.yz * s, .i = (b.xy * wz + b.yz * wx - b.xz * wy)}; }
    constexpr ProjectiveTranslator ProjectiveTranslator::geometric(const ProjectiveTranslator& b) const noexcept { return {.s = b.s * s, .wx = (b.s * wx + b.wx * s), .wy = (b.s * wy + b.wy * s), .wz = (b.s * wz + b.wz * s)}; }
    constexpr ProjectiveTranslator ProjectiveTranslator::geometric(const Translator& b) const noexcept { return {.s = s, .wx = (wx + b.wx * s), .wy = (wy + b.wy * s), .wz = (wz + b.wz * s)}; }
    constexpr Vector ProjectiveTranslator::geometric(const Vector& b) const noexcept { return {.x = b.x * s, .y = b.y * s, .z = b.z * s}; }
    constexpr ProjectivePoint ProjectiveTranslator::geometric(const Point& b) const noexcept { return {.x = (-wx + b.x * s), .y = (-wy + b.y * s), .z = (-wz + b.z * s), .w = s}; }
    constexpr Multivector ProjectiveTranslator::geometric(const PlaneIdeal& b) const noexcept { return {.s = 0.0, .w = (b.x * wx + b.y * wy + b.z * wz), .x = b.x * s, .y = b.y * s, .z = b.z * s, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.y * wx - b.x * wy), .wxz = (b.z * wx - b.x * wz), .wyz = (b.z * wy - b.y * wz), .xyz = 0.0, .i = 0.0}; }
    constexpr Motor ProjectiveTranslator::geometric(const BivectorBulk& b) const noexcept { return {.s = 0.0, .wx = (-b.xy * wy - b.xz * wz), .wy = (b.xy * wx - b.yz * wz), .wz = (b.xz * wx + b.yz * wy), .xy = b.xy * s, .xz = b.xz * s, .yz = b.yz * s, .i = (b.xy * wz + b.yz * wx - b.xz * wy)}; }
    constexpr BivectorWeight ProjectiveTranslator::geometric(const BivectorWeight& b) const noexcept { return {.wx = b.wx * s, .wy = b.wy * s, .wz = b.wz * s}; }
    constexpr PseudoScalar ProjectiveTranslator::geometric(const PseudoScalar& b) const noexcept { return {.i = b.i * s}; }
    constexpr ProjectivePoint ProjectiveTranslator::geometric(const PointCenter& b) const noexcept { return {.x = -wx, .y = -wy, .z = -wz, .w = s}; }

    constexpr Motor Translator::geometric(const Motor& b) const noexcept { return {.s = b.s, .wx = (b.wx + b.s * wx - b.xy * wy - b.xz * wz), .wy = (b.wy + b.s * wy + b.xy * wx - b.yz * wz), .wz = (b.wz + b.s * wz + b.xz * wx + b.yz * wy), .xy = b.xy, .xz = b.xz, .yz = b.yz, .i = (b.i + b.xy * wz + b.yz * wx - b.xz * wy)}; }
    constexpr Multivector Translator::geometric(const Plane& b) const noexcept { return {.s = 0.0, .w = (b.w + b.x * wx + b.y * wy + b.z * wz), .x = b.x, .y = b.y, .z = b.z, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.y * wx - b.x * wy), .wxz = (b.z * wx - b.x * wz), .wyz = (b.z * wy - b.y * wz), .xyz = 0.0, .i = 0.0}; }
    constexpr Motor Translator::geometric(const Bivector& b) const noexcept { return {.s = 0.0, .wx = (b.wx - b.xy * wy - b.xz * wz), .wy = (b.wy + b.xy * wx - b.yz * wz), .wz = (b.wz + b.xz * wx + b.yz * wy), .xy = b.xy, .xz = b.xz, .yz = b.yz, .i = (b.xy * wz + b.yz * wx - b.xz * wy)}; }
    constexpr ProjectivePoint Translator::geometric(const ProjectivePoint& b) const noexcept { return {.x = (b.x - b.w * wx), .y = (b.y - b.w * wy), .z = (b.z - b.w * wz), .w = b.w}; }
    constexpr Motor Translator::geometric(const Quaternion& b) const noexcept { return {.s = b.s, .wx = (b.s * wx - b.xy * wy - b.xz * wz), .wy = (b.s * wy + b.xy * wx - b.yz * wz), .wz = (b.s * wz + b.xz * wx + b.yz * wy), .xy = b.xy, .xz = b.xz, .yz = b.yz, .i = (b.xy * wz + b.yz * wx - b.xz * wy)}; }
    constexpr ProjectiveTranslator Translator::geometric(const ProjectiveTranslator& b) const noexcept { return {.s = b.s, .wx = (b.wx + b.s * wx), .wy = (b.wy + b.s * wy), .wz = (b.wz + b.s * wz)}; }
    constexpr Translator Translator::geometric(const Translator& b) const noexcept { return {.wx = (b.wx + wx), .wy = (b.wy + wy), .wz = (b.wz + wz)}; }
    constexpr Vector Translator::geometric(const Vector& b) const noexcept { return {.x = b.x, .y = b.y, .z = b.z}; }
    constexpr Point Translator::geometric(const Point& b) const noexcept { return {.x = (b.x - wx), .y = (b.y - wy), .z = (b.z - wz)}; }
    constexpr Multivector Translator::geometric(const PlaneIdeal& b) const noexcept { return {.s = 0.0, .w = (b.x * wx + b.y * wy + b.z * wz), .x = b.x, .y = b.y, .z = b.z, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.y * wx - b.x * wy), .wxz = (b.z * wx - b.x * wz), .wyz = (b.z * wy - b.y * wz), .xyz = 0.0, .i = 0.0}; }
    constexpr Motor Translator::geometric(const BivectorBulk& b) const noexcept { return {.s = 0.0, .wx = (-b.xy * wy - b.xz * wz), .wy = (b.xy * wx - b.yz * wz), .wz = (b.xz * wx + b.yz * wy), .xy = b.xy, .xz = b.xz, .yz = b.yz, .i = (b.xy * wz + b.yz * wx - b.xz * wy)}; }
    constexpr BivectorWeight Translator::geometric(const BivectorWeight& b) const noexcept { return {.wx = b.wx, .wy = b.wy, .wz = b.wz}; }
    constexpr PseudoScalar Translator::geometric(const PseudoScalar& b) const noexcept { return {.i = b.i}; }
    constexpr Point Translator::geometric(const PointCenter& b) const noexcept { return {.x = -wx, .y = -wy, .z = -wz}; }

    constexpr Multivector Vector::geometric(const Motor& b) const noexcept { return {.s = 0.0, .w = (b.xy * z + b.yz * x - b.xz * y), .x = 0.0, .y = 0.0, .z = 0.0, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (-b.s * z - b.xz * x - b.yz * y), .wxz = (b.s * y + b.xy * x - b.yz * z), .wyz = (b.xy * y + b.xz * z - b.s * x), .xyz = 0.0, .i = 0.0}; }
    constexpr Motor Vector::geometric(const Plane& b) const noexcept { return {.s = 0.0, .wx = (b.z * y - b.y * z), .wy = (b.x * z - b.z * x), .wz = (b.y * x - b.x * y), .xy = 0.0, .xz = 0.0, .yz = 0.0, .i = (-b.x * x - b.y * y - b.z * z)}; }
    constexpr Multivector Vector::geometric(const Bivector& b) const noexcept { return {.s = 0.0, .w = (b.xy * z + b.yz * x - b.xz * y), .x = 0.0, .y = 0.0, .z = 0.0, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (-b.xz * x - b.yz * y), .wxz = (b.xy * x - b.yz * z), .wyz = (b.xy * y + b.xz * z), .xyz = 0.0, .i = 0.0}; }
    constexpr BivectorWeight Vector::geometric(const ProjectivePoint& b) const noexcept { return {.wx = b.w * x, .wy = b.w * y, .wz = b.w * z}; }
    constexpr Multivector Vector::geometric(const Quaternion& b) const noexcept { return {.s = 0.0, .w = (b.xy * z + b.yz * x - b.xz * y), .x = 0.0, .y = 0.0, .z = 0.0, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (-b.s * z - b.xz * x - b.yz * y), .wxz = (b.s * y + b.xy * x - b.yz * z), .wyz = (b.xy * y + b.xz * z - b.s * x), .xyz = 0.0, .i = 0.0}; }
    constexpr Vector Vector::geometric(const ProjectiveTranslator& b) const noexcept { return {.x = b.s * x, .y = b.s * y, .z = b.s * z}; }
    constexpr Vector Vector::geometric(const Translator& b) const noexcept { return {.x = x, .y = y, .z = z}; }
    constexpr BivectorWeight Vector::geometric(const Point& b) const noexcept { return {.wx = x, .wy = y, .wz = z}; }
    constexpr Motor Vector::geometric(const PlaneIdeal& b) const noexcept { return {.s = 0.0, .wx = (b.z * y - b.y * z), .wy = (b.x * z - b.z * x), .wz = (b.y * x - b.x * y), .xy = 0.0, .xz = 0.0, .yz = 0.0, .i = (-b.x * x - b.y * y - b.z * z)}; }
    constexpr Multivector Vector::geometric(const BivectorBulk& b) const noexcept { return {.s = 0.0, .w = (b.xy * z + b.yz * x - b.xz * y), .x = 0.0, .y = 0.0, .z = 0.0, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (-b.xz * x - b.yz * y), .wxz = (b.xy * x - b.yz * z), .wyz = (b.xy * y + b.xz * z), .xyz = 0.0, .i = 0.0}; }
    constexpr BivectorWeight Vector::geometric(const PointCenter& b) const noexcept { return {.wx = x, .wy = y, .wz = z}; }

    constexpr Multivector Point::geometric(const Motor& b) const noexcept { return {.s = 0.0, .w = (b.i + b.xy * z + b.yz * x - b.xz * y), .x = -b.yz, .y = b.xz, .z = -b.xy, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (-b.wz - b.s * z - b.xz * x - b.yz * y), .wxz = (b.wy + b.s * y + b.xy * x - b.yz * z), .wyz = (-b.wx + b.xy * y + b.xz * z - b.s * x), .xyz = b.s, .i = 0.0}; }
    constexpr Motor Point::geometric(const Plane& b) const noexcept { return {.s = 0.0, .wx = (b.z * y - b.y * z), .wy = (b.x * z - b.z * x), .wz = (b.y * x - b.x * y), .xy = b.z, .xz = -b.y, .yz = b.x, .i = (-b.w - b.x * x - b.y * y - b.z * z)}; }
    constexpr Multivector Point::geometric(const Bivector& b) const noexcept { return {.s = 0.0, .w = (b.xy * z + b.yz * x - b.xz * y), .x = -b.yz, .y = b.xz, .z = -b.xy, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (-b.wz - b.xz * x - b.yz * y), .wxz = (b.wy + b.xy * x - b.yz * z), .wyz = (-b.wx + b.xy * y + b.xz * z), .xyz = 0.0, .i = 0.0}; }
    constexpr ProjectiveTranslator Point::geometric(const ProjectivePoint& b) const noexcept { return {.s = -b.w, .wx = (-b.x + b.w * x), .wy = (-b.y + b.w * y), .wz = (-b.z + b.w * z)}; }
    constexpr Multivector Point::geometric(const Quaternion& b) const noexcept { return {.s = 0.0, .w = (b.xy * z + b.yz * x - b.xz * y), .x = -b.yz, .y = b.xz, .z = -b.xy, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (-b.s * z - b.xz * x - b.yz * y), .wxz = (b.s * y + b.xy * x - b.yz * z), .wyz = (b.xy * y + b.xz * z - b.s * x), .xyz = b.s, .i = 0.0}; }
    constexpr ProjectivePoint Point::geometric(const ProjectiveTranslator& b) const noexcept { return {.x = (b.wx + b.s * x), .y = (b.wy + b.s * y), .z = (b.wz + b.s * z), .w = b.s}; }
    constexpr Point Point::geometric(const Translator& b) const noexcept { return {.x = (b.wx + x), .y = (b.wy + y), .z = (b.wz + z)}; }
    constexpr BivectorWeight Point::geometric(const Vector& b) const noexcept { return {.wx = -b.x, .wy = -b.y, .wz = -b.z}; }
    constexpr ProjectiveTranslator Point::geometric(const Point& b) const noexcept { return {.s = -1.0, .wx = (x - b.x), .wy = (y - b.y), .wz = (z - b.z)}; }
    constexpr Motor Point::geometric(const PlaneIdeal& b) const noexcept { return {.s = 0.0, .wx = (b.z * y - b.y * z), .wy = (b.x * z - b.z * x), .wz = (b.y * x - b.x * y), .xy = b.z, .xz = -b.y, .yz = b.x, .i = (-b.x * x - b.y * y - b.z * z)}; }
    constexpr Multivector Point::geometric(const BivectorBulk& b) const noexcept { return {.s = 0.0, .w = (b.xy * z + b.yz * x - b.xz * y), .x = -b.yz, .y = b.xz, .z = -b.xy, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (-b.xz * x - b.yz * y), .wxz = (b.xy * x - b.yz * z), .wyz = (b.xy * y + b.xz * z), .xyz = 0.0, .i = 0.0}; }
    constexpr Vector Point::geometric(const BivectorWeight& b) const noexcept { return {.x = b.wx, .y = b.wy, .z = b.wz}; }
    constexpr Plane Point::geometric(const PseudoScalar& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = b.i}; }
    constexpr ProjectiveTranslator Point::geometric(const PointCenter& b) const noexcept { return {.s = -1.0, .wx = x, .wy = y, .wz = z}; }

    constexpr Multivector PlaneIdeal::geometric(const Motor& b) const noexcept { return {.s = 0.0, .w = (-b.wx * x - b.wy * y - b.wz * z), .x = (b.s * x - b.xy * y - b.xz * z), .y = (b.s * y + b.xy * x - b.yz * z), .z = (b.s * z + b.xz * x + b.yz * y), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.wx * y - b.i * z - b.wy * x), .wxz = (b.i * y + b.wx * z - b.wz * x), .wyz = (b.wy * z - b.i * x - b.wz * y), .xyz = (b.xy * z + b.yz * x - b.xz * y), .i = 0.0}; }
    constexpr Motor PlaneIdeal::geometric(const Plane& b) const noexcept { return {.s = (b.x * x + b.y * y + b.z * z), .wx = -b.w * x, .wy = -b.w * y, .wz = -b.w * z, .xy = (b.y * x - b.x * y), .xz = (b.z * x - b.x * z), .yz = (b.z * y - b.y * z), .i = 0.0}; }
    constexpr Multivector PlaneIdeal::geometric(const Bivector& b) const noexcept { return {.s = 0.0, .w = (-b.wx * x - b.wy * y - b.wz * z), .x = (-b.xy * y - b.xz * z), .y = (b.xy * x - b.yz * z), .z = (b.xz * x + b.yz * y), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.wx * y - b.wy * x), .wxz = (b.wx * z - b.wz * x), .wyz = (b.wy * z - b.wz * y), .xyz = (b.xy * z + b.yz * x - b.xz * y), .i = 0.0}; }
    constexpr Motor PlaneIdeal::geometric(const ProjectivePoint& b) const noexcept { return {.s = 0.0, .wx = (b.y * z - b.z * y), .wy = (b.z * x - b.x * z), .wz = (b.x * y - b.y * x), .xy = b.w * z, .xz = -b.w * y, .yz = b.w * x, .i = (b.x * x + b.y * y + b.z * z)}; }
    constexpr Multivector PlaneIdeal::geometric(const Quaternion& b) const noexcept { return {.s = 0.0, .w = 0.0, .x = (b.s * x - b.xy * y - b.xz * z), .y = (b.s * y + b.xy * x - b.yz * z), .z = (b.s * z + b.xz * x + b.yz * y), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = 0.0, .wxz = 0.0, .wyz = 0.0, .xyz = (b.xy * z + b.yz * x - b.xz * y), .i = 0.0}; }
    constexpr Multivector PlaneIdeal::geometric(const ProjectiveTranslator& b) const noexcept { return {.s = 0.0, .w = (-b.wx * x - b.wy * y - b.wz * z), .x = b.s * x, .y = b.s * y, .z = b.s * z, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.wx * y - b.wy * x), .wxz = (b.wx * z - b.wz * x), .wyz = (b.wy * z - b.wz * y), .xyz = 0.0, .i = 0.0}; }
    constexpr Multivector PlaneIdeal::geometric(const Translator& b) const noexcept { return {.s = 0.0, .w = (-b.wx * x - b.wy * y - b.wz * z), .x = x, .y = y, .z = z, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.wx * y - b.wy * x), .wxz = (b.wx * z - b.wz * x), .wyz = (b.wy * z - b.wz * y), .xyz = 0.0, .i = 0.0}; }
    constexpr Motor PlaneIdeal::geometric(const Vector& b) const noexcept { return {.s = 0.0, .wx = (b.y * z - b.z * y), .wy = (b.z * x - b.x * z), .wz = (b.x * y - b.y * x), .xy = 0.0, .xz = 0.0, .yz = 0.0, .i = (b.x * x + b.y * y + b.z * z)}; }
    constexpr Motor PlaneIdeal::geometric(const Point& b) const noexcept { return {.s = 0.0, .wx = (b.y * z - b.z * y), .wy = (b.z * x - b.x * z), .wz = (b.x * y - b.y * x), .xy = z, .xz = -y, .yz = x, .i = (b.x * x + b.y * y + b.z * z)}; }
    constexpr Quaternion PlaneIdeal::geometric(const PlaneIdeal& b) const noexcept { return {.s = (b.x * x + b.y * y + b.z * z), .xy = (b.y * x - b.x * y), .xz = (b.z * x - b.x * z), .yz = (b.z * y - b.y * z)}; }
    constexpr Multivector PlaneIdeal::geometric(const BivectorBulk& b) const noexcept { return {.s = 0.0, .w = 0.0, .x = (-b.xy * y - b.xz * z), .y = (b.xy * x - b.yz * z), .z = (b.xz * x + b.yz * y), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = 0.0, .wxz = 0.0, .wyz = 0.0, .xyz = (b.xy * z + b.yz * x - b.xz * y), .i = 0.0}; }
    constexpr Multivector PlaneIdeal::geometric(const BivectorWeight& b) const noexcept { return {.s = 0.0, .w = (-b.wx * x - b.wy * y - b.wz * z), .x = 0.0, .y = 0.0, .z = 0.0, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.wx * y - b.wy * x), .wxz = (b.wx * z - b.wz * x), .wyz = (b.wy * z - b.wz * y), .xyz = 0.0, .i = 0.0}; }
    constexpr Vector PlaneIdeal::geometric(const PseudoScalar& b) const noexcept { return {.x = b.i * x, .y = b.i * y, .z = b.i * z}; }
    constexpr BivectorBulk PlaneIdeal::geometric(const PointCenter& b) const noexcept { return {.xy = z, .xz = -y, .yz = x}; }

    constexpr Motor BivectorBulk::geometric(const Motor& b) const noexcept { return {.s = (-b.xy * xy - b.xz * xz - b.yz * yz), .wx = (b.wy * xy + b.wz * xz - b.i * yz), .wy = (b.i * xz + b.wz * yz - b.wx * xy), .wz = (-b.i * xy - b.wx * xz - b.wy * yz), .xy = (b.s * xy + b.xz * yz - b.yz * xz), .xz = (b.s * xz + b.yz * xy - b.xy * yz), .yz = (b.s * yz + b.xy * xz - b.xz * xy), .i = (b.wx * yz + b.wz * xy - b.wy * xz)}; }
    constexpr Multivector BivectorBulk::geometric(const Plane& b) const noexcept { return {.s = 0.0, .w = 0.0, .x = (b.y * xy + b.z * xz), .y = (b.z * yz - b.x * xy), .z = (-b.x * xz - b.y * yz), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = b.w * xy, .wxz = b.w * xz, .wyz = b.w * yz, .xyz = (b.x * yz + b.z * xy - b.y * xz), .i = 0.0}; }
    constexpr Motor BivectorBulk::geometric(const Bivector& b) const noexcept { return {.s = (-b.xy * xy - b.xz * xz - b.yz * yz), .wx = (b.wy * xy + b.wz * xz), .wy = (b.wz * yz - b.wx * xy), .wz = (-b.wx * xz - b.wy * yz), .xy = (b.xz * yz - b.yz * xz), .xz = (b.yz * xy - b.xy * yz), .yz = (b.xy * xz - b.xz * xy), .i = (b.wx * yz + b.wz * xy - b.wy * xz)}; }
    constexpr Multivector BivectorBulk::geometric(const ProjectivePoint& b) const noexcept { return {.s = 0.0, .w = (b.x * yz + b.z * xy - b.y * xz), .x = -b.w * yz, .y = b.w * xz, .z = -b.w * xy, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.x * xz + b.y * yz), .wxz = (b.z * yz - b.x * xy), .wyz = (-b.y * xy - b.z * xz), .xyz = 0.0, .i = 0.0}; }
    constexpr Quaternion BivectorBulk::geometric(const Quaternion& b) const noexcept { return {.s = (-b.xy * xy - b.xz * xz - b.yz * yz), .xy = (b.s * xy + b.xz * yz - b.yz * xz), .xz = (b.s * xz + b.yz * xy - b.xy * yz), .yz = (b.s * yz + b.xy * xz - b.xz * xy)}; }
    constexpr Motor BivectorBulk::geometric(const ProjectiveTranslator& b) const noexcept { return {.s = 0.0, .wx = (b.wy * xy + b.wz * xz), .wy = (b.wz * yz - b.wx * xy), .wz = (-b.wx * xz - b.wy * yz), .xy = b.s * xy, .xz = b.s * xz, .yz = b.s * yz, .i = (b.wx * yz + b.wz * xy - b.wy * xz)}; }
    constexpr Motor BivectorBulk::geometric(const Translator& b) const noexcept { return {.s = 0.0, .wx = (b.wy * xy + b.wz * xz), .wy = (b.wz * yz - b.wx * xy), .wz = (-b.wx * xz - b.wy * yz), .xy = xy, .xz = xz, .yz = yz, .i = (b.wx * yz + b.wz * xy - b.wy * xz)}; }
    constexpr Multivector BivectorBulk::geometric(const Vector& b) const noexcept { return {.s = 0.0, .w = (b.x * yz + b.z * xy - b.y * xz), .x = 0.0, .y = 0.0, .z = 0.0, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.x * xz + b.y * yz), .wxz = (b.z * yz - b.x * xy), .wyz = (-b.y * xy - b.z * xz), .xyz = 0.0, .i = 0.0}; }
    constexpr Multivector BivectorBulk::geometric(const Point& b) const noexcept { return {.s = 0.0, .w = (b.x * yz + b.z * xy - b.y * xz), .x = -yz, .y = xz, .z = -xy, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.x * xz + b.y * yz), .wxz = (b.z * yz - b.x * xy), .wyz = (-b.y * xy - b.z * xz), .xyz = 0.0, .i = 0.0}; }
    constexpr Multivector BivectorBulk::geometric(const PlaneIdeal& b) const noexcept { return {.s = 0.0, .w = 0.0, .x = (b.y * xy + b.z * xz), .y = (b.z * yz - b.x * xy), .z = (-b.x * xz - b.y * yz), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = 0.0, .wxz = 0.0, .wyz = 0.0, .xyz = (b.x * yz + b.z * xy - b.y * xz), .i = 0.0}; }
    constexpr Quaternion BivectorBulk::geometric(const BivectorBulk& b) const noexcept { return {.s = (-b.xy * xy - b.xz * xz - b.yz * yz), .xy = (b.xz * yz - b.yz * xz), .xz = (b.yz * xy - b.xy * yz), .yz = (b.xy * xz - b.xz * xy)}; }
    constexpr Motor BivectorBulk::geometric(const BivectorWeight& b) const noexcept { return {.s = 0.0, .wx = (b.wy * xy + b.wz * xz), .wy = (b.wz * yz - b.wx * xy), .wz = (-b.wx * xz - b.wy * yz), .xy = 0.0, .xz = 0.0, .yz = 0.0, .i = (b.wx * yz + b.wz * xy - b.wy * xz)}; }
    constexpr BivectorWeight BivectorBulk::geometric(const PseudoScalar& b) const noexcept { return {.wx = -b.i * yz, .wy = b.i * xz, .wz = -b.i * xy}; }
    constexpr PlaneIdeal BivectorBulk::geometric(const PointCenter& b) const noexcept { return {.x = -yz, .y = xz, .z = -xy}; }

    constexpr Motor BivectorWeight::geometric(const Motor& b) const noexcept { return {.s = 0.0, .wx = (b.s * wx - b.xy * wy - b.xz * wz), .wy = (b.s * wy + b.xy * wx - b.yz * wz), .wz = (b.s * wz + b.xz * wx + b.yz * wy), .xy = 0.0, .xz = 0.0, .yz = 0.0, .i = (b.xy * wz + b.yz * wx - b.xz * wy)}; }
    constexpr Multivector BivectorWeight::geometric(const Plane& b) const noexcept { return {.s = 0.0, .w = (b.x * wx + b.y * wy + b.z * wz), .x = 0.0, .y = 0.0, .z = 0.0, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.y * wx - b.x * wy), .wxz = (b.z * wx - b.x * wz), .wyz = (b.z * wy - b.y * wz), .xyz = 0.0, .i = 0.0}; }
    constexpr Motor BivectorWeight::geometric(const Bivector& b) const noexcept { return {.s = 0.0, .wx = (-b.xy * wy - b.xz * wz), .wy = (b.xy * wx - b.yz * wz), .wz = (b.xz * wx + b.yz * wy), .xy = 0.0, .xz = 0.0, .yz = 0.0, .i = (b.xy * wz + b.yz * wx - b.xz * wy)}; }
    constexpr Vector BivectorWeight::geometric(const ProjectivePoint& b) const noexcept { return {.x = -b.w * wx, .y = -b.w * wy, .z = -b.w * wz}; }
    constexpr Motor BivectorWeight::geometric(const Quaternion& b) const noexcept { return {.s = 0.0, .wx = (b.s * wx - b.xy * wy - b.xz * wz), .wy = (b.s * wy + b.xy * wx - b.yz * wz), .wz = (b.s * wz + b.xz * wx + b.yz * wy), .xy = 0.0, .xz = 0.0, .yz = 0.0, .i = (b.xy * wz + b.yz * wx - b.xz * wy)}; }
    constexpr BivectorWeight BivectorWeight::geometric(const ProjectiveTranslator& b) const noexcept { return {.wx = b.s * wx, .wy = b.s * wy, .wz = b.s * wz}; }
    constexpr BivectorWeight BivectorWeight::geometric(const Translator& b) const noexcept { return {.wx = wx, .wy = wy, .wz = wz}; }
    constexpr Vector BivectorWeight::geometric(const Point& b) const noexcept { return {.x = -wx, .y = -wy, .z = -wz}; }
    constexpr Multivector BivectorWeight::geometric(const PlaneIdeal& b) const noexcept { return {.s = 0.0, .w = (b.x * wx + b.y * wy + b.z * wz), .x = 0.0, .y = 0.0, .z = 0.0, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.y * wx - b.x * wy), .wxz = (b.z * wx - b.x * wz), .wyz = (b.z * wy - b.y * wz), .xyz = 0.0, .i = 0.0}; }
    constexpr Motor BivectorWeight::geometric(const BivectorBulk& b) const noexcept { return {.s = 0.0, .wx = (-b.xy * wy - b.xz * wz), .wy = (b.xy * wx - b.yz * wz), .wz = (b.xz * wx + b.yz * wy), .xy = 0.0, .xz = 0.0, .yz = 0.0, .i = (b.xy * wz + b.yz * wx - b.xz * wy)}; }
    constexpr Vector BivectorWeight::geometric(const PointCenter& b) const noexcept { return {.x = -wx, .y = -wy, .z = -wz}; }

    constexpr Motor PseudoScalar::geometric(const Motor& b) const noexcept { return {.s = 0.0, .wx = -b.yz * i, .wy = b.xz * i, .wz = -b.xy * i, .xy = 0.0, .xz = 0.0, .yz = 0.0, .i = b.s * i}; }
    constexpr Vector PseudoScalar::geometric(const Plane& b) const noexcept { return {.x = -b.x * i, .y = -b.y * i, .z = -b.z * i}; }
    constexpr BivectorWeight PseudoScalar::geometric(const Bivector& b) const noexcept { return {.wx = -b.yz * i, .wy = b.xz * i, .wz = -b.xy * i}; }
    constexpr Plane PseudoScalar::geometric(const ProjectivePoint& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = -b.w * i}; }
    constexpr Motor PseudoScalar::geometric(const Quaternion& b) const noexcept { return {.s = 0.0, .wx = -b.yz * i, .wy = b.xz * i, .wz = -b.xy * i, .xy = 0.0, .xz = 0.0, .yz = 0.0, .i = b.s * i}; }
    constexpr PseudoScalar PseudoScalar::geometric(const ProjectiveTranslator& b) const noexcept { return {.i = b.s * i}; }
    constexpr PseudoScalar PseudoScalar::geometric(const Translator& b) const noexcept { return {.i = i}; }
    constexpr Plane PseudoScalar::geometric(const Point& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = -i}; }
    constexpr Vector PseudoScalar::geometric(const PlaneIdeal& b) const noexcept { return {.x = -b.x * i, .y = -b.y * i, .z = -b.z * i}; }
    constexpr BivectorWeight PseudoScalar::geometric(const BivectorBulk& b) const noexcept { return {.wx = -b.yz * i, .wy = b.xz * i, .wz = -b.xy * i}; }
    constexpr Plane PseudoScalar::geometric(const PointCenter& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = -i}; }

    constexpr Multivector PointCenter::geometric(const Motor& b) const noexcept { return {.s = 0.0, .w = b.i, .x = -b.yz, .y = b.xz, .z = -b.xy, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = -b.wz, .wxz = b.wy, .wyz = -b.wx, .xyz = b.s, .i = 0.0}; }
    constexpr Motor PointCenter::geometric(const Plane& b) const noexcept { return {.s = 0.0, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = b.z, .xz = -b.y, .yz = b.x, .i = -b.w}; }
    constexpr Multivector PointCenter::geometric(const Bivector& b) const noexcept { return {.s = 0.0, .w = 0.0, .x = -b.yz, .y = b.xz, .z = -b.xy, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = -b.wz, .wxz = b.wy, .wyz = -b.wx, .xyz = 0.0, .i = 0.0}; }
    constexpr ProjectiveTranslator PointCenter::geometric(const ProjectivePoint& b) const noexcept { return {.s = -b.w, .wx = -b.x, .wy = -b.y, .wz = -b.z}; }
    constexpr Multivector PointCenter::geometric(const Quaternion& b) const noexcept { return {.s = 0.0, .w = 0.0, .x = -b.yz, .y = b.xz, .z = -b.xy, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = 0.0, .wxz = 0.0, .wyz = 0.0, .xyz = b.s, .i = 0.0}; }
    constexpr ProjectivePoint PointCenter::geometric(const ProjectiveTranslator& b) const noexcept { return {.x = b.wx, .y = b.wy, .z = b.wz, .w = b.s}; }
    constexpr Point PointCenter::geometric(const Translator& b) const noexcept { return {.x = b.wx, .y = b.wy, .z = b.wz}; }
    constexpr BivectorWeight PointCenter::geometric(const Vector& b) const noexcept { return {.wx = -b.x, .wy = -b.y, .wz = -b.z}; }
    constexpr ProjectiveTranslator PointCenter::geometric(const Point& b) const noexcept { return {.s = -1.0, .wx = -b.x, .wy = -b.y, .wz = -b.z}; }
    constexpr BivectorBulk PointCenter::geometric(const PlaneIdeal& b) const noexcept { return {.xy = b.z, .xz = -b.y, .yz = b.x}; }
    constexpr PlaneIdeal PointCenter::geometric(const BivectorBulk& b) const noexcept { return {.x = -b.yz, .y = b.xz, .z = -b.xy}; }
    constexpr Vector PointCenter::geometric(const BivectorWeight& b) const noexcept { return {.x = b.wx, .y = b.wy, .z = b.wz}; }
    constexpr Plane PointCenter::geometric(const PseudoScalar& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = b.i}; }
    constexpr double PointCenter::geometric(const PointCenter& b) const noexcept { return -1.0; }

}

// opsQuaternion.h

// generated by com.github.kright.pga3d.codegen.cpp.ops.QuaternionOpsGenerator

namespace pga3d {
    [[nodiscard]] inline Quaternion Quaternion::rotation(const Vector& from, const Vector& to) noexcept {
        return rotation(from.dual(), to.dual());
    }

    [[nodiscard]] inline Quaternion Quaternion::rotation(const PlaneIdeal& from, const PlaneIdeal& to) noexcept {
        const double norm = std::sqrt(from.normSquare() * to.normSquare());
        const Quaternion q2a = to.geometric(from) / norm;
        const double dot = q2a.s;

        if (dot > -1.0 + 1e-6) {
            const double newCos = std::sqrt((1.0 + dot) / 2);
            const double newSinDivSin2 = 0.5 / newCos;
            return Quaternion(newCos, q2a.xy * newSinDivSin2, q2a.xz * newSinDivSin2, q2a.yz * newSinDivSin2);
        }

        const double sin2a = std::sqrt(q2a.xy * q2a.xy + q2a.xz * q2a.xz + q2a.yz * q2a.yz);

        if (sin2a > 1e-8) {
            const double angle2 = std::atan2(sin2a, q2a.s);
            const double propAngle = angle2 * 0.5;
            const double mult = std::sin(propAngle) / sin2a;
            return Quaternion(std::cos(propAngle), q2a.xy * mult, q2a.xz * mult, q2a.yz * mult).normalizedByNorm();
        }

        // choose any axis
        const PlaneIdeal orthogonalPlane =
            (std::abs(from.x) > std::abs(from.z)) ? PlaneIdeal{-from.y, from.x, 0} : PlaneIdeal{0, -from.z, from.y};

        return Quaternion(0, orthogonalPlane.z, -orthogonalPlane.y, orthogonalPlane.x).normalizedByNorm();
    }

    [[nodiscard]] inline BivectorBulk Quaternion::log() const noexcept {
        const double scalar = s;
        if (s < 0.0) return (-(*this)).log();

        const double lenXYZ = std::sqrt(xy * xy + xz * xz + yz * yz);
        const double angle = std::atan2(lenXYZ, scalar);

         // 1 / sin^2
        const double a = 1.0 / (1.0 - scalar * scalar);

        // angle / sin(angle)
        const double b = (std::abs(angle) > 1e-5) ? angle * std::sqrt(a) : (1.0 + angle * angle / 6.0);

        return BivectorBulk {
            .xy = b * xy,
            .xz = b * xz,
            .yz = b * yz,
        };
    }

    [[nodiscard]] inline Quaternion Quaternion::pow(double p) const noexcept {
       return (log() * p).exp();
    }

    [[nodiscard]] inline Quaternion Quaternion::projectToRotationInPlane(const PlaneIdeal& plane) const noexcept {
        const Quaternion q = normalizedByNorm();
        const Quaternion qPart = Quaternion::rotation(q.sandwich(plane), plane);
        return qPart.geometric(q);
    }

    [[nodiscard]] inline double Quaternion::restoreRotationInPlane(const PlaneIdeal& plane) const noexcept {
        const Quaternion q0 = projectToRotationInPlane(plane);
        const BivectorWeight logDual = q0.log().dual();
        const double currentAngle = 2.0 * (logDual.wx * plane.x + logDual.wy * plane.y + logDual.wz * plane.z) / plane.norm();
        return currentAngle;
    }

    [[nodiscard]] constexpr Vector Quaternion::axisX() const noexcept { return {.x = (s * s + yz * yz - xy * xy - xz * xz), .y = 2.0 * (-s * xy - xz * yz), .z = (-2.0 * s * xz + 2.0 * xy * yz)}; }
    [[nodiscard]] constexpr Vector Quaternion::axisY() const noexcept { return {.x = (-2.0 * xz * yz + 2.0 * s * xy), .y = (s * s + xz * xz - xy * xy - yz * yz), .z = (-2.0 * s * yz - 2.0 * xy * xz)}; }
    [[nodiscard]] constexpr Vector Quaternion::axisZ() const noexcept { return {.x = (2.0 * s * xz + 2.0 * xy * yz), .y = 2.0 * (s * yz - xy * xz), .z = (s * s + xy * xy - xz * xz - yz * yz)}; }
}

// opsTranslator.h

// generated by com.github.kright.pga3d.codegen.cpp.ops.TranslatorOpsGenerator

namespace pga3d {

    [[nodiscard]] constexpr Translator Translator::addVector(const Vector& v) noexcept { return {.wx = v.x, .wy = v.y, .wz = v.z}; }

    [[nodiscard]] constexpr BivectorWeight Translator::log() const noexcept {
        return BivectorWeight {
            .wx = wx,
            .wy = wy,
            .wz = wz,
        };
    }

    [[nodiscard]] constexpr Translator Translator::pow(double p) const noexcept {
       return (log() * p).exp();
    }
}

// opsMotor.h

// generated by com.github.kright.pga3d.codegen.cpp.ops.MotorOpsGenerator

namespace pga3d {

    [[nodiscard]] constexpr Motor Motor::addVector(const Vector& v) noexcept { return {.s = 1.0, .wx = v.x, .wy = v.y, .wz = v.z}; }

    [[nodiscard]] inline Bivector Motor::log() const noexcept {
        const double scalar = s;
        if (s < 0.0) return (-(*this)).log();

        const double lenXYZ = std::sqrt(xy * xy + xz * xz + yz * yz);
        const double angle = std::atan2(lenXYZ, scalar);

        // 1 / sin^2
        const double a = 1.0 / (1.0 - scalar * scalar);

        // angle / sin(angle)
        const double b = (std::abs(angle) > 1e-5)
            ? (angle * std::sqrt(a))
            : (1.0 + angle * angle / 6.0);

        const double c = (std::abs(angle) > 1e-5)
            ? (a * i * (1.0 - scalar * b))
            : ((1.0 + angle * angle / 2.0) * i / 3.0);

        return Bivector {
            .wx = (b * wx + c * yz),
            .wy = (b * wy - c * xz),
            .wz = (b * wz + c * xy),
            .xy = b * xy,
            .xz = b * xz,
            .yz = b * yz,
        };
    }

    [[nodiscard]] inline Motor Motor::pow(double p) const noexcept {
       return (log() * p).exp();
    }

    [[nodiscard]] constexpr QuaternionWithTranslator Motor::toQuaternionWithTranslator() const noexcept {
        return toTranslatorWithQuaternion().toQuaternionWithTranslator();
    }

    [[nodiscard]] constexpr TranslatorWithQuaternion Motor::toTranslatorWithQuaternion() const noexcept {
        const Quaternion q = toQuaternionUnsafe();
        const Vector shift = sandwich(PointCenter{}).toPoint().toVectorUnsafe();
        const Translator t = Translator::addVector(shift);
        return { t, q };
    }

    /**
     * see [[https://arxiv.org/abs/2206.07496]], page 14
     * and [[https://https://bivector.net/PGAdyn.pdf.net/PGAdyn.pdf]], page 42
     */
    [[nodiscard]] inline Motor Motor::renormalized() const noexcept {
        const double a2 = 1.0 / (s * s + xy * xy + xz * xz + yz * yz);
        const double a = std::sqrt(a2);
        const double b = (s * i - wx * yz + wy * xz - wz * xy) * a * a2;
        return Motor {
            .s = a * s,
            .wx = a * wx + b * yz,
            .wy = a * wy - b * xz,
            .wz = a * wz + b * xy,
            .xy = a * xy,
            .xz = a * xz,
            .yz = a * yz,
            .i = a * i - b * s,
        };
    }

    [[nodiscard]] constexpr Vector Motor::axisX() const noexcept { return toQuaternionUnsafe().axisX(); }
    [[nodiscard]] constexpr Vector Motor::axisY() const noexcept { return toQuaternionUnsafe().axisY(); }
    [[nodiscard]] constexpr Vector Motor::axisZ() const noexcept { return toQuaternionUnsafe().axisZ(); }
}

// opsBivector.h

// generated by com.github.kright.pga3d.codegen.cpp.ops.BivectorOpsGenerator

namespace pga3d {

    inline std::pair<Bivector, BivectorWeight> Bivector::split() const noexcept {
        const double div = bulkNormSquare();
        if (div < 1e-100) {
            return {
                Bivector{ .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = xy, .xz = xz, .yz = yz },
                BivectorWeight{ .wx = wx, .wy = wy, .wz = wz }
            };
        }

        const double pseudoScalar = (wy * xz - wx * yz - wz * xy) / div;
        const BivectorWeight shiftAlongLine{
            .wx = -pseudoScalar * yz,
            .wy = pseudoScalar * xz,
            .wz = -pseudoScalar * xy
        };

        const Bivector line = (*this) - shiftAlongLine;
        return {line, shiftAlongLine};
    }

    inline Motor Bivector::exp() const noexcept {
        const double len = bulkNorm();
        const double cos = std::cos(len);

        const double sinDivLen = (len > 1e-5) ?
            (std::sin(len) / len) :
            (1.0 - (len * len) / 6.0);

        const double sinMinusCosDivLen2 = (len > 1e-5) ?
            (sinDivLen - cos) / (len * len) :
            (1.0 / 3.0) * (1.0 + 0.8 * len * len);

        return Motor {
          .s = cos,
          .wx = (sinDivLen * wx + sinMinusCosDivLen2 * yz * (wy * xz - wx * yz - wz * xy)),
          .wy = (sinDivLen * wy + sinMinusCosDivLen2 * xz * (wx * yz + wz * xy - wy * xz)),
          .wz = (sinDivLen * wz + sinMinusCosDivLen2 * xy * (wy * xz - wx * yz - wz * xy)),
          .xy = sinDivLen * xy,
          .xz = sinDivLen * xz,
          .yz = sinDivLen * yz,
          .i = sinDivLen * (wx * yz + wz * xy - wy * xz),
        };
    }
}

// opsBivectorBulk.h

// generated by com.github.kright.pga3d.codegen.cpp.ops.BivectorBulkOpsGenerator

namespace pga3d {

    [[nodiscard]] inline Quaternion BivectorBulk::exp() const noexcept {
        const double len = bulkNorm();
        const double cos = std::cos(len);

        const double sinDivLen = (len > 1e-5)
            ? (std::sin(len) / len)
            : (1.0 - (len * len) / 6.0);

        return Quaternion{
            .s = cos,
            .xy = sinDivLen * xy,
            .xz = sinDivLen * xz,
            .yz = sinDivLen * yz,
        };
    }
}

// opsBivectorWeight.h

// generated by com.github.kright.pga3d.codegen.cpp.ops.BivectorWeightOpsGenerator

namespace pga3d {

    [[nodiscard]] constexpr Translator BivectorWeight::exp() const noexcept {
        return Translator{
            .wx = wx,
            .wy = wy,
            .wz = wz,
        };
    }
}

// opsPoint.h

// generated by com.github.kright.pga3d.codegen.cpp.ops.PointOpsGenerator

namespace pga3d {

    [[nodiscard]] inline double Point::distanceTo(const Point& other) const noexcept {
        return ((*this) - other).norm();
    }

    [[nodiscard]] inline Point Point::min(const Point& other) const noexcept {
        return Point{
            .x = std::min(x, other.x),
            .y = std::min(y, other.y),
            .z = std::min(z, other.z),
        };
    }

    [[nodiscard]] inline Point Point::max(const Point& other) const noexcept {
        return Point{
            .x = std::max(x, other.x),
            .y = std::max(y, other.y),
            .z = std::max(z, other.z),
        };
    }

    [[nodiscard]] inline Point Point::clamp(const Point& minV, const Point& maxV) const noexcept {
        return Point{
            .x = std::clamp(x, minV.x, maxV.x),
            .y = std::clamp(y, minV.y, maxV.y),
            .z = std::clamp(z, minV.z, maxV.z),
        };
    }
}

// opsVector.h

// generated by com.github.kright.pga3d.codegen.cpp.ops.VectorOpsGenerator

namespace pga3d {

    [[nodiscard]] inline Vector Vector::min(const Vector& other) const noexcept {
        return Vector{
            .x = std::min(x, other.x),
            .y = std::min(y, other.y),
            .z = std::min(z, other.z),
        };
    }

    [[nodiscard]] inline Vector Vector::max(const Vector& other) const noexcept {
        return Vector{
            .x = std::max(x, other.x),
            .y = std::max(y, other.y),
            .z = std::max(z, other.z),
        };
    }

    [[nodiscard]] inline Vector Vector::clamp(const Vector& minV, const Vector& maxV) const noexcept {
        return Vector{
            .x = std::clamp(x, minV.x, maxV.x),
            .y = std::clamp(y, minV.y, maxV.y),
            .z = std::clamp(z, minV.z, maxV.z),
        };
    }
}

// opsDual.h

// generated by com.github.kright.pga3d.codegen.cpp.ops.DualOpGenerator

namespace pga3d {
    constexpr Multivector Multivector::dual() const noexcept { return {.s = i, .w = xyz, .x = -wyz, .y = wxz, .z = -wxy, .wx = yz, .wy = -xz, .wz = xy, .xy = wz, .xz = -wy, .yz = wx, .wxy = -z, .wxz = y, .wyz = -x, .xyz = w, .i = s}; }
    constexpr Motor Motor::dual() const noexcept { return {.s = i, .wx = yz, .wy = -xz, .wz = xy, .xy = wz, .xz = -wy, .yz = wx, .i = s}; }
    constexpr ProjectivePoint Plane::dual() const noexcept { return {.x = x, .y = y, .z = z, .w = w}; }
    constexpr Bivector Bivector::dual() const noexcept { return {.wx = yz, .wy = -xz, .wz = xy, .xy = wz, .xz = -wy, .yz = wx}; }
    constexpr Plane ProjectivePoint::dual() const noexcept { return {.x = x, .y = y, .z = z, .w = w}; }
    constexpr Motor Quaternion::dual() const noexcept { return {.s = 0.0, .wx = yz, .wy = -xz, .wz = xy, .xy = 0.0, .xz = 0.0, .yz = 0.0, .i = s}; }
    constexpr Motor ProjectiveTranslator::dual() const noexcept { return {.s = 0.0, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = wz, .xz = -wy, .yz = wx, .i = s}; }
    constexpr Motor Translator::dual() const noexcept { return {.s = 0.0, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = wz, .xz = -wy, .yz = wx, .i = 1.0}; }
    constexpr PlaneIdeal Vector::dual() const noexcept { return {.x = x, .y = y, .z = z}; }
    constexpr Plane Point::dual() const noexcept { return {.x = x, .y = y, .z = z, .w = 1.0}; }
    constexpr Vector PlaneIdeal::dual() const noexcept { return {.x = x, .y = y, .z = z}; }
    constexpr BivectorWeight BivectorBulk::dual() const noexcept { return {.wx = yz, .wy = -xz, .wz = xy}; }
    constexpr BivectorBulk BivectorWeight::dual() const noexcept { return {.xy = wz, .xz = -wy, .yz = wx}; }
    constexpr double PseudoScalar::dual() const noexcept { return i; }
    constexpr Plane PointCenter::dual() const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = 1.0}; }
}

// opsWeight.h

// generated by com.github.kright.pga3d.codegen.cpp.ops.WeightOpGenerator

namespace pga3d {
    constexpr Multivector Multivector::weight() const noexcept { return {.s = 0.0, .w = w, .x = 0.0, .y = 0.0, .z = 0.0, .wx = wx, .wy = wy, .wz = wz, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = wxy, .wxz = wxz, .wyz = wyz, .xyz = 0.0, .i = i}; }
    constexpr Motor Motor::weight() const noexcept { return {.s = 0.0, .wx = wx, .wy = wy, .wz = wz, .xy = 0.0, .xz = 0.0, .yz = 0.0, .i = i}; }
    constexpr Plane Plane::weight() const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = w}; }
    constexpr BivectorWeight Bivector::weight() const noexcept { return {.wx = wx, .wy = wy, .wz = wz}; }
    constexpr Vector ProjectivePoint::weight() const noexcept { return {.x = x, .y = y, .z = z}; }
    constexpr BivectorWeight ProjectiveTranslator::weight() const noexcept { return {.wx = wx, .wy = wy, .wz = wz}; }
    constexpr BivectorWeight Translator::weight() const noexcept { return {.wx = wx, .wy = wy, .wz = wz}; }
    constexpr Vector Vector::weight() const noexcept { return {.x = x, .y = y, .z = z}; }
    constexpr Vector Point::weight() const noexcept { return {.x = x, .y = y, .z = z}; }
    constexpr BivectorWeight BivectorWeight::weight() const noexcept { return {.wx = wx, .wy = wy, .wz = wz}; }
    constexpr PseudoScalar PseudoScalar::weight() const noexcept { return {.i = i}; }
}

// opsBulk.h

// generated by com.github.kright.pga3d.codegen.cpp.ops.BulkOpGenerator

namespace pga3d {
    constexpr Multivector Multivector::bulk() const noexcept { return {.s = s, .w = 0.0, .x = x, .y = y, .z = z, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = xy, .xz = xz, .yz = yz, .wxy = 0.0, .wxz = 0.0, .wyz = 0.0, .xyz = xyz, .i = 0.0}; }
    constexpr Quaternion Motor::bulk() const noexcept { return {.s = s, .xy = xy, .xz = xz, .yz = yz}; }
    constexpr PlaneIdeal Plane::bulk() const noexcept { return {.x = x, .y = y, .z = z}; }
    constexpr BivectorBulk Bivector::bulk() const noexcept { return {.xy = xy, .xz = xz, .yz = yz}; }
    constexpr ProjectivePoint ProjectivePoint::bulk() const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = w}; }
    constexpr Quaternion Quaternion::bulk() const noexcept { return {.s = s, .xy = xy, .xz = xz, .yz = yz}; }
    constexpr double ProjectiveTranslator::bulk() const noexcept { return s; }
    constexpr double Translator::bulk() const noexcept { return 1.0; }
    constexpr PointCenter Point::bulk() const noexcept { return {}; }
    constexpr PlaneIdeal PlaneIdeal::bulk() const noexcept { return {.x = x, .y = y, .z = z}; }
    constexpr BivectorBulk BivectorBulk::bulk() const noexcept { return {.xy = xy, .xz = xz, .yz = yz}; }
    constexpr PointCenter PointCenter::bulk() const noexcept { return {}; }
}

// opsReverse.h

// generated by com.github.kright.pga3d.codegen.cpp.ops.ReverseOpGenerator

namespace pga3d {
    constexpr Multivector Multivector::reverse() const noexcept { return {.s = s, .w = w, .x = x, .y = y, .z = z, .wx = -wx, .wy = -wy, .wz = -wz, .xy = -xy, .xz = -xz, .yz = -yz, .wxy = -wxy, .wxz = -wxz, .wyz = -wyz, .xyz = -xyz, .i = i}; }
    constexpr Motor Motor::reverse() const noexcept { return {.s = s, .wx = -wx, .wy = -wy, .wz = -wz, .xy = -xy, .xz = -xz, .yz = -yz, .i = i}; }
    constexpr Plane Plane::reverse() const noexcept { return {.x = x, .y = y, .z = z, .w = w}; }
    constexpr Bivector Bivector::reverse() const noexcept { return {.wx = -wx, .wy = -wy, .wz = -wz, .xy = -xy, .xz = -xz, .yz = -yz}; }
    constexpr ProjectivePoint ProjectivePoint::reverse() const noexcept { return {.x = -x, .y = -y, .z = -z, .w = -w}; }
    constexpr Quaternion Quaternion::reverse() const noexcept { return {.s = s, .xy = -xy, .xz = -xz, .yz = -yz}; }
    constexpr ProjectiveTranslator ProjectiveTranslator::reverse() const noexcept { return {.s = s, .wx = -wx, .wy = -wy, .wz = -wz}; }
    constexpr Translator Translator::reverse() const noexcept { return {.wx = -wx, .wy = -wy, .wz = -wz}; }
    constexpr Vector Vector::reverse() const noexcept { return {.x = -x, .y = -y, .z = -z}; }
    constexpr ProjectivePoint Point::reverse() const noexcept { return {.x = -x, .y = -y, .z = -z, .w = -1.0}; }
    constexpr PlaneIdeal PlaneIdeal::reverse() const noexcept { return {.x = x, .y = y, .z = z}; }
    constexpr BivectorBulk BivectorBulk::reverse() const noexcept { return {.xy = -xy, .xz = -xz, .yz = -yz}; }
    constexpr BivectorWeight BivectorWeight::reverse() const noexcept { return {.wx = -wx, .wy = -wy, .wz = -wz}; }
    constexpr PseudoScalar PseudoScalar::reverse() const noexcept { return {.i = i}; }
    constexpr ProjectivePoint PointCenter::reverse() const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = -1.0}; }
}

// opsAntiReverse.h

// generated by com.github.kright.pga3d.codegen.cpp.ops.AntiReverseOpGenerator

namespace pga3d {
    constexpr Multivector Multivector::antiReverse() const noexcept { return {.s = s, .w = -w, .x = -x, .y = -y, .z = -z, .wx = -wx, .wy = -wy, .wz = -wz, .xy = -xy, .xz = -xz, .yz = -yz, .wxy = wxy, .wxz = wxz, .wyz = wyz, .xyz = xyz, .i = i}; }
    constexpr Motor Motor::antiReverse() const noexcept { return {.s = s, .wx = -wx, .wy = -wy, .wz = -wz, .xy = -xy, .xz = -xz, .yz = -yz, .i = i}; }
    constexpr Plane Plane::antiReverse() const noexcept { return {.x = -x, .y = -y, .z = -z, .w = -w}; }
    constexpr Bivector Bivector::antiReverse() const noexcept { return {.wx = -wx, .wy = -wy, .wz = -wz, .xy = -xy, .xz = -xz, .yz = -yz}; }
    constexpr ProjectivePoint ProjectivePoint::antiReverse() const noexcept { return {.x = x, .y = y, .z = z, .w = w}; }
    constexpr Quaternion Quaternion::antiReverse() const noexcept { return {.s = s, .xy = -xy, .xz = -xz, .yz = -yz}; }
    constexpr ProjectiveTranslator ProjectiveTranslator::antiReverse() const noexcept { return {.s = s, .wx = -wx, .wy = -wy, .wz = -wz}; }
    constexpr Translator Translator::antiReverse() const noexcept { return {.wx = -wx, .wy = -wy, .wz = -wz}; }
    constexpr Vector Vector::antiReverse() const noexcept { return {.x = x, .y = y, .z = z}; }
    constexpr Point Point::antiReverse() const noexcept { return {.x = x, .y = y, .z = z}; }
    constexpr PlaneIdeal PlaneIdeal::antiReverse() const noexcept { return {.x = -x, .y = -y, .z = -z}; }
    constexpr BivectorBulk BivectorBulk::antiReverse() const noexcept { return {.xy = -xy, .xz = -xz, .yz = -yz}; }
    constexpr BivectorWeight BivectorWeight::antiReverse() const noexcept { return {.wx = -wx, .wy = -wy, .wz = -wz}; }
    constexpr PseudoScalar PseudoScalar::antiReverse() const noexcept { return {.i = i}; }
    constexpr PointCenter PointCenter::antiReverse() const noexcept { return {}; }
}

// opsTo.h

// generated by com.github.kright.pga3d.codegen.cpp.ops.ConversionOpGenerator

namespace pga3d {
    constexpr Motor Multivector::toMotorUnsafe() const noexcept { return {.s = s, .wx = wx, .wy = wy, .wz = wz, .xy = xy, .xz = xz, .yz = yz, .i = i}; }
    constexpr Plane Multivector::toPlaneUnsafe() const noexcept { return {.x = x, .y = y, .z = z, .w = w}; }
    constexpr Bivector Multivector::toBivectorUnsafe() const noexcept { return {.wx = wx, .wy = wy, .wz = wz, .xy = xy, .xz = xz, .yz = yz}; }
    constexpr ProjectivePoint Multivector::toProjectivePointUnsafe() const noexcept { return {.x = -wyz, .y = wxz, .z = -wxy, .w = xyz}; }
    constexpr Quaternion Multivector::toQuaternionUnsafe() const noexcept { return {.s = s, .xy = xy, .xz = xz, .yz = yz}; }
    constexpr ProjectiveTranslator Multivector::toProjectiveTranslatorUnsafe() const noexcept { return {.s = s, .wx = wx, .wy = wy, .wz = wz}; }
    constexpr Translator Multivector::toTranslatorUnsafe() const noexcept { return {.wx = wx, .wy = wy, .wz = wz}; }
    constexpr Vector Multivector::toVectorUnsafe() const noexcept { return {.x = -wyz, .y = wxz, .z = -wxy}; }
    constexpr Point Multivector::toPointUnsafe() const noexcept { return {.x = -wyz, .y = wxz, .z = -wxy}; }
    constexpr PlaneIdeal Multivector::toPlaneIdealUnsafe() const noexcept { return {.x = x, .y = y, .z = z}; }
    constexpr BivectorBulk Multivector::toBivectorBulkUnsafe() const noexcept { return {.xy = xy, .xz = xz, .yz = yz}; }
    constexpr BivectorWeight Multivector::toBivectorWeightUnsafe() const noexcept { return {.wx = wx, .wy = wy, .wz = wz}; }

    constexpr Multivector Motor::toMultivector() const noexcept { return {.s = s, .w = 0.0, .x = 0.0, .y = 0.0, .z = 0.0, .wx = wx, .wy = wy, .wz = wz, .xy = xy, .xz = xz, .yz = yz, .wxy = 0.0, .wxz = 0.0, .wyz = 0.0, .xyz = 0.0, .i = i}; }
    constexpr Bivector Motor::toBivectorUnsafe() const noexcept { return {.wx = wx, .wy = wy, .wz = wz, .xy = xy, .xz = xz, .yz = yz}; }
    constexpr Quaternion Motor::toQuaternionUnsafe() const noexcept { return {.s = s, .xy = xy, .xz = xz, .yz = yz}; }
    constexpr ProjectiveTranslator Motor::toProjectiveTranslatorUnsafe() const noexcept { return {.s = s, .wx = wx, .wy = wy, .wz = wz}; }
    constexpr Translator Motor::toTranslatorUnsafe() const noexcept { return {.wx = wx, .wy = wy, .wz = wz}; }
    constexpr BivectorBulk Motor::toBivectorBulkUnsafe() const noexcept { return {.xy = xy, .xz = xz, .yz = yz}; }
    constexpr BivectorWeight Motor::toBivectorWeightUnsafe() const noexcept { return {.wx = wx, .wy = wy, .wz = wz}; }

    constexpr Multivector Plane::toMultivector() const noexcept { return {.s = 0.0, .w = w, .x = x, .y = y, .z = z, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = 0.0, .wxz = 0.0, .wyz = 0.0, .xyz = 0.0, .i = 0.0}; }
    constexpr PlaneIdeal Plane::toPlaneIdealUnsafe() const noexcept { return {.x = x, .y = y, .z = z}; }

    constexpr Multivector Bivector::toMultivector() const noexcept { return {.s = 0.0, .w = 0.0, .x = 0.0, .y = 0.0, .z = 0.0, .wx = wx, .wy = wy, .wz = wz, .xy = xy, .xz = xz, .yz = yz, .wxy = 0.0, .wxz = 0.0, .wyz = 0.0, .xyz = 0.0, .i = 0.0}; }
    constexpr Motor Bivector::toMotor() const noexcept { return {.s = 0.0, .wx = wx, .wy = wy, .wz = wz, .xy = xy, .xz = xz, .yz = yz, .i = 0.0}; }
    constexpr Quaternion Bivector::toQuaternionUnsafe() const noexcept { return {.s = 0.0, .xy = xy, .xz = xz, .yz = yz}; }
    constexpr ProjectiveTranslator Bivector::toProjectiveTranslatorUnsafe() const noexcept { return {.s = 0.0, .wx = wx, .wy = wy, .wz = wz}; }
    constexpr Translator Bivector::toTranslatorUnsafe() const noexcept { return {.wx = wx, .wy = wy, .wz = wz}; }
    constexpr BivectorBulk Bivector::toBivectorBulkUnsafe() const noexcept { return {.xy = xy, .xz = xz, .yz = yz}; }
    constexpr BivectorWeight Bivector::toBivectorWeightUnsafe() const noexcept { return {.wx = wx, .wy = wy, .wz = wz}; }

    constexpr Multivector ProjectivePoint::toMultivector() const noexcept { return {.s = 0.0, .w = 0.0, .x = 0.0, .y = 0.0, .z = 0.0, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = -z, .wxz = y, .wyz = -x, .xyz = w, .i = 0.0}; }
    constexpr Vector ProjectivePoint::toVectorUnsafe() const noexcept { return {.x = x, .y = y, .z = z}; }
    constexpr Point ProjectivePoint::toPointUnsafe() const noexcept { return {.x = x, .y = y, .z = z}; }

    constexpr Point ProjectivePoint::toPoint() const noexcept { const double inv = 1.0 / w; return { .x = x * inv, .y = y * inv, .z = z * inv }; }
    constexpr Multivector Quaternion::toMultivector() const noexcept { return {.s = s, .w = 0.0, .x = 0.0, .y = 0.0, .z = 0.0, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = xy, .xz = xz, .yz = yz, .wxy = 0.0, .wxz = 0.0, .wyz = 0.0, .xyz = 0.0, .i = 0.0}; }
    constexpr Motor Quaternion::toMotor() const noexcept { return {.s = s, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = xy, .xz = xz, .yz = yz, .i = 0.0}; }
    constexpr Bivector Quaternion::toBivectorUnsafe() const noexcept { return {.wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = xy, .xz = xz, .yz = yz}; }
    constexpr ProjectiveTranslator Quaternion::toProjectiveTranslatorUnsafe() const noexcept { return {.s = s, .wx = 0.0, .wy = 0.0, .wz = 0.0}; }
    constexpr BivectorBulk Quaternion::toBivectorBulkUnsafe() const noexcept { return {.xy = xy, .xz = xz, .yz = yz}; }

    constexpr Multivector ProjectiveTranslator::toMultivector() const noexcept { return {.s = s, .w = 0.0, .x = 0.0, .y = 0.0, .z = 0.0, .wx = wx, .wy = wy, .wz = wz, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = 0.0, .wxz = 0.0, .wyz = 0.0, .xyz = 0.0, .i = 0.0}; }
    constexpr Motor ProjectiveTranslator::toMotor() const noexcept { return {.s = s, .wx = wx, .wy = wy, .wz = wz, .xy = 0.0, .xz = 0.0, .yz = 0.0, .i = 0.0}; }
    constexpr Bivector ProjectiveTranslator::toBivectorUnsafe() const noexcept { return {.wx = wx, .wy = wy, .wz = wz, .xy = 0.0, .xz = 0.0, .yz = 0.0}; }
    constexpr Quaternion ProjectiveTranslator::toQuaternionUnsafe() const noexcept { return {.s = s, .xy = 0.0, .xz = 0.0, .yz = 0.0}; }
    constexpr Translator ProjectiveTranslator::toTranslatorUnsafe() const noexcept { return {.wx = wx, .wy = wy, .wz = wz}; }
    constexpr BivectorWeight ProjectiveTranslator::toBivectorWeightUnsafe() const noexcept { return {.wx = wx, .wy = wy, .wz = wz}; }

    constexpr Translator ProjectiveTranslator::toTranslator() const noexcept { const double inv = 1.0 / s; return Translator{ .wx = wx * inv, .wy = wy * inv, .wz = wz * inv }; }
    constexpr Multivector Translator::toMultivector() const noexcept { return {.s = 1.0, .w = 0.0, .x = 0.0, .y = 0.0, .z = 0.0, .wx = wx, .wy = wy, .wz = wz, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = 0.0, .wxz = 0.0, .wyz = 0.0, .xyz = 0.0, .i = 0.0}; }
    constexpr Motor Translator::toMotor() const noexcept { return {.s = 1.0, .wx = wx, .wy = wy, .wz = wz, .xy = 0.0, .xz = 0.0, .yz = 0.0, .i = 0.0}; }
    constexpr Bivector Translator::toBivectorUnsafe() const noexcept { return {.wx = wx, .wy = wy, .wz = wz, .xy = 0.0, .xz = 0.0, .yz = 0.0}; }
    constexpr Quaternion Translator::toQuaternionUnsafe() const noexcept { return {.s = 1.0, .xy = 0.0, .xz = 0.0, .yz = 0.0}; }
    constexpr ProjectiveTranslator Translator::toProjectiveTranslator() const noexcept { return {.s = 1.0, .wx = wx, .wy = wy, .wz = wz}; }
    constexpr BivectorWeight Translator::toBivectorWeightUnsafe() const noexcept { return {.wx = wx, .wy = wy, .wz = wz}; }

    constexpr Multivector Vector::toMultivector() const noexcept { return {.s = 0.0, .w = 0.0, .x = 0.0, .y = 0.0, .z = 0.0, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = -z, .wxz = y, .wyz = -x, .xyz = 0.0, .i = 0.0}; }
    constexpr ProjectivePoint Vector::toProjectivePoint() const noexcept { return {.x = x, .y = y, .z = z, .w = 0.0}; }
    constexpr Point Vector::toPointUnsafe() const noexcept { return {.x = x, .y = y, .z = z}; }

    constexpr Multivector Point::toMultivector() const noexcept { return {.s = 0.0, .w = 0.0, .x = 0.0, .y = 0.0, .z = 0.0, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = -z, .wxz = y, .wyz = -x, .xyz = 1.0, .i = 0.0}; }
    constexpr ProjectivePoint Point::toProjectivePoint() const noexcept { return {.x = x, .y = y, .z = z, .w = 1.0}; }
    constexpr Vector Point::toVectorUnsafe() const noexcept { return {.x = x, .y = y, .z = z}; }

    constexpr Multivector PlaneIdeal::toMultivector() const noexcept { return {.s = 0.0, .w = 0.0, .x = x, .y = y, .z = z, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = 0.0, .wxz = 0.0, .wyz = 0.0, .xyz = 0.0, .i = 0.0}; }
    constexpr Plane PlaneIdeal::toPlane() const noexcept { return {.x = x, .y = y, .z = z, .w = 0.0}; }

    constexpr Multivector BivectorBulk::toMultivector() const noexcept { return {.s = 0.0, .w = 0.0, .x = 0.0, .y = 0.0, .z = 0.0, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = xy, .xz = xz, .yz = yz, .wxy = 0.0, .wxz = 0.0, .wyz = 0.0, .xyz = 0.0, .i = 0.0}; }
    constexpr Motor BivectorBulk::toMotor() const noexcept { return {.s = 0.0, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = xy, .xz = xz, .yz = yz, .i = 0.0}; }
    constexpr Bivector BivectorBulk::toBivector() const noexcept { return {.wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = xy, .xz = xz, .yz = yz}; }
    constexpr Quaternion BivectorBulk::toQuaternion() const noexcept { return {.s = 0.0, .xy = xy, .xz = xz, .yz = yz}; }

    constexpr Multivector BivectorWeight::toMultivector() const noexcept { return {.s = 0.0, .w = 0.0, .x = 0.0, .y = 0.0, .z = 0.0, .wx = wx, .wy = wy, .wz = wz, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = 0.0, .wxz = 0.0, .wyz = 0.0, .xyz = 0.0, .i = 0.0}; }
    constexpr Motor BivectorWeight::toMotor() const noexcept { return {.s = 0.0, .wx = wx, .wy = wy, .wz = wz, .xy = 0.0, .xz = 0.0, .yz = 0.0, .i = 0.0}; }
    constexpr Bivector BivectorWeight::toBivector() const noexcept { return {.wx = wx, .wy = wy, .wz = wz, .xy = 0.0, .xz = 0.0, .yz = 0.0}; }
    constexpr ProjectiveTranslator BivectorWeight::toProjectiveTranslator() const noexcept { return {.s = 0.0, .wx = wx, .wy = wy, .wz = wz}; }
    constexpr Translator BivectorWeight::toTranslatorUnsafe() const noexcept { return {.wx = wx, .wy = wy, .wz = wz}; }

    constexpr Multivector PseudoScalar::toMultivector() const noexcept { return {.s = 0.0, .w = 0.0, .x = 0.0, .y = 0.0, .z = 0.0, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = 0.0, .wxz = 0.0, .wyz = 0.0, .xyz = 0.0, .i = i}; }
    constexpr Motor PseudoScalar::toMotor() const noexcept { return {.s = 0.0, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .i = i}; }

    constexpr Multivector PointCenter::toMultivector() const noexcept { return {.s = 0.0, .w = 0.0, .x = 0.0, .y = 0.0, .z = 0.0, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = 0.0, .wxz = 0.0, .wyz = 0.0, .xyz = 1.0, .i = 0.0}; }
    constexpr ProjectivePoint PointCenter::toProjectivePoint() const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = 1.0}; }
    constexpr Vector PointCenter::toVectorUnsafe() const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0}; }
    constexpr Point PointCenter::toPoint() const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0}; }

}

// opsStr.h

// generated by com.github.kright.pga3d.codegen.cpp.ops.ToStreamOpGenerator

namespace pga3d {
    inline std::ostream &operator<<(std::ostream &os, const Multivector &v) {
        return os << "Multivector{" << ".s = " << v.s << ", "".w = " << v.w << ", "".x = " << v.x << ", "".y = " << v.y << ", "".z = " << v.z << ", "".wx = " << v.wx << ", "".wy = " << v.wy << ", "".wz = " << v.wz << ", "".xy = " << v.xy << ", "".xz = " << v.xz << ", "".yz = " << v.yz << ", "".wxy = " << v.wxy << ", "".wxz = " << v.wxz << ", "".wyz = " << v.wyz << ", "".xyz = " << v.xyz << ", "".i = " << v.i << "}";
    }
    inline std::ostream &operator<<(std::ostream &os, const Motor &v) {
        return os << "Motor{" << ".s = " << v.s << ", "".wx = " << v.wx << ", "".wy = " << v.wy << ", "".wz = " << v.wz << ", "".xy = " << v.xy << ", "".xz = " << v.xz << ", "".yz = " << v.yz << ", "".i = " << v.i << "}";
    }
    inline std::ostream &operator<<(std::ostream &os, const Plane &v) {
        return os << "Plane{" << ".x = " << v.x << ", "".y = " << v.y << ", "".z = " << v.z << ", "".w = " << v.w << "}";
    }
    inline std::ostream &operator<<(std::ostream &os, const Bivector &v) {
        return os << "Bivector{" << ".wx = " << v.wx << ", "".wy = " << v.wy << ", "".wz = " << v.wz << ", "".xy = " << v.xy << ", "".xz = " << v.xz << ", "".yz = " << v.yz << "}";
    }
    inline std::ostream &operator<<(std::ostream &os, const ProjectivePoint &v) {
        return os << "ProjectivePoint{" << ".x = " << v.x << ", "".y = " << v.y << ", "".z = " << v.z << ", "".w = " << v.w << "}";
    }
    inline std::ostream &operator<<(std::ostream &os, const Quaternion &v) {
        return os << "Quaternion{" << ".s = " << v.s << ", "".xy = " << v.xy << ", "".xz = " << v.xz << ", "".yz = " << v.yz << "}";
    }
    inline std::ostream &operator<<(std::ostream &os, const ProjectiveTranslator &v) {
        return os << "ProjectiveTranslator{" << ".s = " << v.s << ", "".wx = " << v.wx << ", "".wy = " << v.wy << ", "".wz = " << v.wz << "}";
    }
    inline std::ostream &operator<<(std::ostream &os, const Translator &v) {
        return os << "Translator{" << ".wx = " << v.wx << ", "".wy = " << v.wy << ", "".wz = " << v.wz << "}";
    }
    inline std::ostream &operator<<(std::ostream &os, const Vector &v) {
        return os << "Vector{" << ".x = " << v.x << ", "".y = " << v.y << ", "".z = " << v.z << "}";
    }
    inline std::ostream &operator<<(std::ostream &os, const Point &v) {
        return os << "Point{" << ".x = " << v.x << ", "".y = " << v.y << ", "".z = " << v.z << "}";
    }
    inline std::ostream &operator<<(std::ostream &os, const PlaneIdeal &v) {
        return os << "PlaneIdeal{" << ".x = " << v.x << ", "".y = " << v.y << ", "".z = " << v.z << "}";
    }
    inline std::ostream &operator<<(std::ostream &os, const BivectorBulk &v) {
        return os << "BivectorBulk{" << ".xy = " << v.xy << ", "".xz = " << v.xz << ", "".yz = " << v.yz << "}";
    }
    inline std::ostream &operator<<(std::ostream &os, const BivectorWeight &v) {
        return os << "BivectorWeight{" << ".wx = " << v.wx << ", "".wy = " << v.wy << ", "".wz = " << v.wz << "}";
    }
    inline std::ostream &operator<<(std::ostream &os, const PseudoScalar &v) {
        return os << "PseudoScalar{" << ".i = " << v.i << "}";
    }
    inline std::ostream &operator<<(std::ostream &os, const PointCenter &v) {
        return os << "PointCenter{}";
    }
}

// opsDot.h

// generated by com.github.kright.pga3d.codegen.cpp.ops.DotOpGenerator

namespace pga3d {
    constexpr Multivector Multivector::dot(const Multivector& b) const noexcept { return {.s = (b.s * s + b.x * x + b.y * y + b.z * z - b.xy * xy - b.xyz * xyz - b.xz * xz - b.yz * yz), .w = (b.i * xyz + b.s * w + b.w * s + b.x * wx + b.y * wy + b.z * wz - b.wx * x - b.wxy * xy - b.wxz * xz - b.wy * y - b.wyz * yz - b.wz * z - b.xy * wxy - b.xyz * i - b.xz * wxz - b.yz * wyz), .x = (b.s * x + b.x * s + b.y * xy + b.z * xz - b.xy * y - b.xyz * yz - b.xz * z - b.yz * xyz), .y = (b.s * y + b.xy * x + b.xyz * xz + b.xz * xyz + b.y * s + b.z * yz - b.x * xy - b.yz * z), .z = (b.s * z + b.xz * x + b.yz * y + b.z * s - b.x * xz - b.xy * xyz - b.xyz * xy - b.y * yz), .wx = (b.s * wx + b.wx * s + b.wxy * y + b.wxz * z + b.y * wxy + b.z * wxz - b.i * yz - b.yz * i), .wy = (b.i * xz + b.s * wy + b.wy * s + b.wyz * z + b.xz * i + b.z * wyz - b.wxy * x - b.x * wxy), .wz = (b.s * wz + b.wz * s - b.i * xy - b.wxz * x - b.wyz * y - b.x * wxz - b.xy * i - b.y * wyz), .xy = (b.s * xy + b.xy * s + b.xyz * z + b.z * xyz), .xz = (b.s * xz + b.xz * s - b.xyz * y - b.y * xyz), .yz = (b.s * yz + b.x * xyz + b.xyz * x + b.yz * s), .wxy = (b.s * wxy + b.wxy * s + b.z * i - b.i * z), .wxz = (b.i * y + b.s * wxz + b.wxz * s - b.y * i), .wyz = (b.s * wyz + b.wyz * s + b.x * i - b.i * x), .xyz = (b.s * xyz + b.xyz * s), .i = (b.i * s + b.s * i)}; }

    constexpr Motor Motor::dot(const Motor& b) const noexcept { return {.s = (b.s * s - b.xy * xy - b.xz * xz - b.yz * yz), .wx = (b.s * wx + b.wx * s - b.i * yz - b.yz * i), .wy = (b.i * xz + b.s * wy + b.wy * s + b.xz * i), .wz = (b.s * wz + b.wz * s - b.i * xy - b.xy * i), .xy = (b.s * xy + b.xy * s), .xz = (b.s * xz + b.xz * s), .yz = (b.s * yz + b.yz * s), .i = (b.i * s + b.s * i)}; }
    constexpr Multivector Motor::dot(const Plane& b) const noexcept { return {.s = 0.0, .w = (b.w * s + b.x * wx + b.y * wy + b.z * wz), .x = (b.x * s + b.y * xy + b.z * xz), .y = (b.y * s + b.z * yz - b.x * xy), .z = (b.z * s - b.x * xz - b.y * yz), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = b.z * i, .wxz = -b.y * i, .wyz = b.x * i, .xyz = 0.0, .i = 0.0}; }
    constexpr Motor Motor::dot(const Bivector& b) const noexcept { return {.s = (-b.xy * xy - b.xz * xz - b.yz * yz), .wx = (b.wx * s - b.yz * i), .wy = (b.wy * s + b.xz * i), .wz = (b.wz * s - b.xy * i), .xy = b.xy * s, .xz = b.xz * s, .yz = b.yz * s, .i = 0.0}; }
    constexpr Multivector Motor::dot(const ProjectivePoint& b) const noexcept { return {.s = 0.0, .w = (b.x * yz + b.z * xy - b.w * i - b.y * xz), .x = -b.w * yz, .y = b.w * xz, .z = -b.w * xy, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = -b.z * s, .wxz = b.y * s, .wyz = -b.x * s, .xyz = b.w * s, .i = 0.0}; }
    constexpr Motor Motor::dot(const Quaternion& b) const noexcept { return {.s = (b.s * s - b.xy * xy - b.xz * xz - b.yz * yz), .wx = (b.s * wx - b.yz * i), .wy = (b.s * wy + b.xz * i), .wz = (b.s * wz - b.xy * i), .xy = (b.s * xy + b.xy * s), .xz = (b.s * xz + b.xz * s), .yz = (b.s * yz + b.yz * s), .i = b.s * i}; }
    constexpr Motor Motor::dot(const ProjectiveTranslator& b) const noexcept { return {.s = b.s * s, .wx = (b.s * wx + b.wx * s), .wy = (b.s * wy + b.wy * s), .wz = (b.s * wz + b.wz * s), .xy = b.s * xy, .xz = b.s * xz, .yz = b.s * yz, .i = b.s * i}; }
    constexpr Motor Motor::dot(const Translator& b) const noexcept { return {.s = s, .wx = (wx + b.wx * s), .wy = (wy + b.wy * s), .wz = (wz + b.wz * s), .xy = xy, .xz = xz, .yz = yz, .i = i}; }
    constexpr Multivector Motor::dot(const Vector& b) const noexcept { return {.s = 0.0, .w = (b.x * yz + b.z * xy - b.y * xz), .x = 0.0, .y = 0.0, .z = 0.0, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = -b.z * s, .wxz = b.y * s, .wyz = -b.x * s, .xyz = 0.0, .i = 0.0}; }
    constexpr Multivector Motor::dot(const Point& b) const noexcept { return {.s = 0.0, .w = (-i + b.x * yz + b.z * xy - b.y * xz), .x = -yz, .y = xz, .z = -xy, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = -b.z * s, .wxz = b.y * s, .wyz = -b.x * s, .xyz = s, .i = 0.0}; }
    constexpr Multivector Motor::dot(const PlaneIdeal& b) const noexcept { return {.s = 0.0, .w = (b.x * wx + b.y * wy + b.z * wz), .x = (b.x * s + b.y * xy + b.z * xz), .y = (b.y * s + b.z * yz - b.x * xy), .z = (b.z * s - b.x * xz - b.y * yz), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = b.z * i, .wxz = -b.y * i, .wyz = b.x * i, .xyz = 0.0, .i = 0.0}; }
    constexpr Motor Motor::dot(const BivectorBulk& b) const noexcept { return {.s = (-b.xy * xy - b.xz * xz - b.yz * yz), .wx = -b.yz * i, .wy = b.xz * i, .wz = -b.xy * i, .xy = b.xy * s, .xz = b.xz * s, .yz = b.yz * s, .i = 0.0}; }
    constexpr BivectorWeight Motor::dot(const BivectorWeight& b) const noexcept { return {.wx = b.wx * s, .wy = b.wy * s, .wz = b.wz * s}; }
    constexpr Motor Motor::dot(const PseudoScalar& b) const noexcept { return {.s = 0.0, .wx = -b.i * yz, .wy = b.i * xz, .wz = -b.i * xy, .xy = 0.0, .xz = 0.0, .yz = 0.0, .i = b.i * s}; }
    constexpr Multivector Motor::dot(const PointCenter& b) const noexcept { return {.s = 0.0, .w = -i, .x = -yz, .y = xz, .z = -xy, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = 0.0, .wxz = 0.0, .wyz = 0.0, .xyz = s, .i = 0.0}; }

    constexpr Multivector Plane::dot(const Motor& b) const noexcept { return {.s = 0.0, .w = (b.s * w - b.wx * x - b.wy * y - b.wz * z), .x = (b.s * x - b.xy * y - b.xz * z), .y = (b.s * y + b.xy * x - b.yz * z), .z = (b.s * z + b.xz * x + b.yz * y), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = -b.i * z, .wxz = b.i * y, .wyz = -b.i * x, .xyz = 0.0, .i = 0.0}; }
    constexpr double Plane::dot(const Plane& b) const noexcept { return (b.x * x + b.y * y + b.z * z); }
    constexpr Plane Plane::dot(const Bivector& b) const noexcept { return {.x = (-b.xy * y - b.xz * z), .y = (b.xy * x - b.yz * z), .z = (b.xz * x + b.yz * y), .w = (-b.wx * x - b.wy * y - b.wz * z)}; }
    constexpr Bivector Plane::dot(const ProjectivePoint& b) const noexcept { return {.wx = (b.y * z - b.z * y), .wy = (b.z * x - b.x * z), .wz = (b.x * y - b.y * x), .xy = b.w * z, .xz = -b.w * y, .yz = b.w * x}; }
    constexpr Plane Plane::dot(const Quaternion& b) const noexcept { return {.x = (b.s * x - b.xy * y - b.xz * z), .y = (b.s * y + b.xy * x - b.yz * z), .z = (b.s * z + b.xz * x + b.yz * y), .w = b.s * w}; }
    constexpr Plane Plane::dot(const ProjectiveTranslator& b) const noexcept { return {.x = b.s * x, .y = b.s * y, .z = b.s * z, .w = (b.s * w - b.wx * x - b.wy * y - b.wz * z)}; }
    constexpr Plane Plane::dot(const Translator& b) const noexcept { return {.x = x, .y = y, .z = z, .w = (w - b.wx * x - b.wy * y - b.wz * z)}; }
    constexpr BivectorWeight Plane::dot(const Vector& b) const noexcept { return {.wx = (b.y * z - b.z * y), .wy = (b.z * x - b.x * z), .wz = (b.x * y - b.y * x)}; }
    constexpr Bivector Plane::dot(const Point& b) const noexcept { return {.wx = (b.y * z - b.z * y), .wy = (b.z * x - b.x * z), .wz = (b.x * y - b.y * x), .xy = z, .xz = -y, .yz = x}; }
    constexpr double Plane::dot(const PlaneIdeal& b) const noexcept { return (b.x * x + b.y * y + b.z * z); }
    constexpr PlaneIdeal Plane::dot(const BivectorBulk& b) const noexcept { return {.x = (-b.xy * y - b.xz * z), .y = (b.xy * x - b.yz * z), .z = (b.xz * x + b.yz * y)}; }
    constexpr Plane Plane::dot(const BivectorWeight& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = (-b.wx * x - b.wy * y - b.wz * z)}; }
    constexpr Vector Plane::dot(const PseudoScalar& b) const noexcept { return {.x = b.i * x, .y = b.i * y, .z = b.i * z}; }
    constexpr BivectorBulk Plane::dot(const PointCenter& b) const noexcept { return {.xy = z, .xz = -y, .yz = x}; }

    constexpr Motor Bivector::dot(const Motor& b) const noexcept { return {.s = (-b.xy * xy - b.xz * xz - b.yz * yz), .wx = (b.s * wx - b.i * yz), .wy = (b.i * xz + b.s * wy), .wz = (b.s * wz - b.i * xy), .xy = b.s * xy, .xz = b.s * xz, .yz = b.s * yz, .i = 0.0}; }
    constexpr Plane Bivector::dot(const Plane& b) const noexcept { return {.x = (b.y * xy + b.z * xz), .y = (b.z * yz - b.x * xy), .z = (-b.x * xz - b.y * yz), .w = (b.x * wx + b.y * wy + b.z * wz)}; }
    constexpr double Bivector::dot(const Bivector& b) const noexcept { return (-b.xy * xy - b.xz * xz - b.yz * yz); }
    constexpr Plane Bivector::dot(const ProjectivePoint& b) const noexcept { return {.x = -b.w * yz, .y = b.w * xz, .z = -b.w * xy, .w = (b.x * yz + b.z * xy - b.y * xz)}; }
    constexpr Motor Bivector::dot(const Quaternion& b) const noexcept { return {.s = (-b.xy * xy - b.xz * xz - b.yz * yz), .wx = b.s * wx, .wy = b.s * wy, .wz = b.s * wz, .xy = b.s * xy, .xz = b.s * xz, .yz = b.s * yz, .i = 0.0}; }
    constexpr Bivector Bivector::dot(const ProjectiveTranslator& b) const noexcept { return {.wx = b.s * wx, .wy = b.s * wy, .wz = b.s * wz, .xy = b.s * xy, .xz = b.s * xz, .yz = b.s * yz}; }
    constexpr Bivector Bivector::dot(const Translator& b) const noexcept { return {.wx = wx, .wy = wy, .wz = wz, .xy = xy, .xz = xz, .yz = yz}; }
    constexpr Plane Bivector::dot(const Vector& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = (b.x * yz + b.z * xy - b.y * xz)}; }
    constexpr Plane Bivector::dot(const Point& b) const noexcept { return {.x = -yz, .y = xz, .z = -xy, .w = (b.x * yz + b.z * xy - b.y * xz)}; }
    constexpr Plane Bivector::dot(const PlaneIdeal& b) const noexcept { return {.x = (b.y * xy + b.z * xz), .y = (b.z * yz - b.x * xy), .z = (-b.x * xz - b.y * yz), .w = (b.x * wx + b.y * wy + b.z * wz)}; }
    constexpr double Bivector::dot(const BivectorBulk& b) const noexcept { return (-b.xy * xy - b.xz * xz - b.yz * yz); }
    constexpr BivectorWeight Bivector::dot(const PseudoScalar& b) const noexcept { return {.wx = -b.i * yz, .wy = b.i * xz, .wz = -b.i * xy}; }
    constexpr PlaneIdeal Bivector::dot(const PointCenter& b) const noexcept { return {.x = -yz, .y = xz, .z = -xy}; }

    constexpr Multivector ProjectivePoint::dot(const Motor& b) const noexcept { return {.s = 0.0, .w = (b.i * w + b.xy * z + b.yz * x - b.xz * y), .x = -b.yz * w, .y = b.xz * w, .z = -b.xy * w, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = -b.s * z, .wxz = b.s * y, .wyz = -b.s * x, .xyz = b.s * w, .i = 0.0}; }
    constexpr Bivector ProjectivePoint::dot(const Plane& b) const noexcept { return {.wx = (b.z * y - b.y * z), .wy = (b.x * z - b.z * x), .wz = (b.y * x - b.x * y), .xy = b.z * w, .xz = -b.y * w, .yz = b.x * w}; }
    constexpr Plane ProjectivePoint::dot(const Bivector& b) const noexcept { return {.x = -b.yz * w, .y = b.xz * w, .z = -b.xy * w, .w = (b.xy * z + b.yz * x - b.xz * y)}; }
    constexpr double ProjectivePoint::dot(const ProjectivePoint& b) const noexcept { return -b.w * w; }
    constexpr Multivector ProjectivePoint::dot(const Quaternion& b) const noexcept { return {.s = 0.0, .w = (b.xy * z + b.yz * x - b.xz * y), .x = -b.yz * w, .y = b.xz * w, .z = -b.xy * w, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = -b.s * z, .wxz = b.s * y, .wyz = -b.s * x, .xyz = b.s * w, .i = 0.0}; }
    constexpr ProjectivePoint ProjectivePoint::dot(const ProjectiveTranslator& b) const noexcept { return {.x = b.s * x, .y = b.s * y, .z = b.s * z, .w = b.s * w}; }
    constexpr ProjectivePoint ProjectivePoint::dot(const Translator& b) const noexcept { return {.x = x, .y = y, .z = z, .w = w}; }
    constexpr double ProjectivePoint::dot(const Point& b) const noexcept { return -w; }
    constexpr Bivector ProjectivePoint::dot(const PlaneIdeal& b) const noexcept { return {.wx = (b.z * y - b.y * z), .wy = (b.x * z - b.z * x), .wz = (b.y * x - b.x * y), .xy = b.z * w, .xz = -b.y * w, .yz = b.x * w}; }
    constexpr Plane ProjectivePoint::dot(const BivectorBulk& b) const noexcept { return {.x = -b.yz * w, .y = b.xz * w, .z = -b.xy * w, .w = (b.xy * z + b.yz * x - b.xz * y)}; }
    constexpr Plane ProjectivePoint::dot(const PseudoScalar& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = b.i * w}; }
    constexpr double ProjectivePoint::dot(const PointCenter& b) const noexcept { return -w; }

    constexpr Motor Quaternion::dot(const Motor& b) const noexcept { return {.s = (b.s * s - b.xy * xy - b.xz * xz - b.yz * yz), .wx = (b.wx * s - b.i * yz), .wy = (b.i * xz + b.wy * s), .wz = (b.wz * s - b.i * xy), .xy = (b.s * xy + b.xy * s), .xz = (b.s * xz + b.xz * s), .yz = (b.s * yz + b.yz * s), .i = b.i * s}; }
    constexpr Plane Quaternion::dot(const Plane& b) const noexcept { return {.x = (b.x * s + b.y * xy + b.z * xz), .y = (b.y * s + b.z * yz - b.x * xy), .z = (b.z * s - b.x * xz - b.y * yz), .w = b.w * s}; }
    constexpr Motor Quaternion::dot(const Bivector& b) const noexcept { return {.s = (-b.xy * xy - b.xz * xz - b.yz * yz), .wx = b.wx * s, .wy = b.wy * s, .wz = b.wz * s, .xy = b.xy * s, .xz = b.xz * s, .yz = b.yz * s, .i = 0.0}; }
    constexpr Multivector Quaternion::dot(const ProjectivePoint& b) const noexcept { return {.s = 0.0, .w = (b.x * yz + b.z * xy - b.y * xz), .x = -b.w * yz, .y = b.w * xz, .z = -b.w * xy, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = -b.z * s, .wxz = b.y * s, .wyz = -b.x * s, .xyz = b.w * s, .i = 0.0}; }
    constexpr Quaternion Quaternion::dot(const Quaternion& b) const noexcept { return {.s = (b.s * s - b.xy * xy - b.xz * xz - b.yz * yz), .xy = (b.s * xy + b.xy * s), .xz = (b.s * xz + b.xz * s), .yz = (b.s * yz + b.yz * s)}; }
    constexpr Motor Quaternion::dot(const ProjectiveTranslator& b) const noexcept { return {.s = b.s * s, .wx = b.wx * s, .wy = b.wy * s, .wz = b.wz * s, .xy = b.s * xy, .xz = b.s * xz, .yz = b.s * yz, .i = 0.0}; }
    constexpr Motor Quaternion::dot(const Translator& b) const noexcept { return {.s = s, .wx = b.wx * s, .wy = b.wy * s, .wz = b.wz * s, .xy = xy, .xz = xz, .yz = yz, .i = 0.0}; }
    constexpr Multivector Quaternion::dot(const Vector& b) const noexcept { return {.s = 0.0, .w = (b.x * yz + b.z * xy - b.y * xz), .x = 0.0, .y = 0.0, .z = 0.0, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = -b.z * s, .wxz = b.y * s, .wyz = -b.x * s, .xyz = 0.0, .i = 0.0}; }
    constexpr Multivector Quaternion::dot(const Point& b) const noexcept { return {.s = 0.0, .w = (b.x * yz + b.z * xy - b.y * xz), .x = -yz, .y = xz, .z = -xy, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = -b.z * s, .wxz = b.y * s, .wyz = -b.x * s, .xyz = s, .i = 0.0}; }
    constexpr PlaneIdeal Quaternion::dot(const PlaneIdeal& b) const noexcept { return {.x = (b.x * s + b.y * xy + b.z * xz), .y = (b.y * s + b.z * yz - b.x * xy), .z = (b.z * s - b.x * xz - b.y * yz)}; }
    constexpr Quaternion Quaternion::dot(const BivectorBulk& b) const noexcept { return {.s = (-b.xy * xy - b.xz * xz - b.yz * yz), .xy = b.xy * s, .xz = b.xz * s, .yz = b.yz * s}; }
    constexpr BivectorWeight Quaternion::dot(const BivectorWeight& b) const noexcept { return {.wx = b.wx * s, .wy = b.wy * s, .wz = b.wz * s}; }
    constexpr Motor Quaternion::dot(const PseudoScalar& b) const noexcept { return {.s = 0.0, .wx = -b.i * yz, .wy = b.i * xz, .wz = -b.i * xy, .xy = 0.0, .xz = 0.0, .yz = 0.0, .i = b.i * s}; }
    constexpr Multivector Quaternion::dot(const PointCenter& b) const noexcept { return {.s = 0.0, .w = 0.0, .x = -yz, .y = xz, .z = -xy, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = 0.0, .wxz = 0.0, .wyz = 0.0, .xyz = s, .i = 0.0}; }

    constexpr Motor ProjectiveTranslator::dot(const Motor& b) const noexcept { return {.s = b.s * s, .wx = (b.s * wx + b.wx * s), .wy = (b.s * wy + b.wy * s), .wz = (b.s * wz + b.wz * s), .xy = b.xy * s, .xz = b.xz * s, .yz = b.yz * s, .i = b.i * s}; }
    constexpr Plane ProjectiveTranslator::dot(const Plane& b) const noexcept { return {.x = b.x * s, .y = b.y * s, .z = b.z * s, .w = (b.w * s + b.x * wx + b.y * wy + b.z * wz)}; }
    constexpr Bivector ProjectiveTranslator::dot(const Bivector& b) const noexcept { return {.wx = b.wx * s, .wy = b.wy * s, .wz = b.wz * s, .xy = b.xy * s, .xz = b.xz * s, .yz = b.yz * s}; }
    constexpr ProjectivePoint ProjectiveTranslator::dot(const ProjectivePoint& b) const noexcept { return {.x = b.x * s, .y = b.y * s, .z = b.z * s, .w = b.w * s}; }
    constexpr Motor ProjectiveTranslator::dot(const Quaternion& b) const noexcept { return {.s = b.s * s, .wx = b.s * wx, .wy = b.s * wy, .wz = b.s * wz, .xy = b.xy * s, .xz = b.xz * s, .yz = b.yz * s, .i = 0.0}; }
    constexpr ProjectiveTranslator ProjectiveTranslator::dot(const ProjectiveTranslator& b) const noexcept { return {.s = b.s * s, .wx = (b.s * wx + b.wx * s), .wy = (b.s * wy + b.wy * s), .wz = (b.s * wz + b.wz * s)}; }
    constexpr ProjectiveTranslator ProjectiveTranslator::dot(const Translator& b) const noexcept { return {.s = s, .wx = (wx + b.wx * s), .wy = (wy + b.wy * s), .wz = (wz + b.wz * s)}; }
    constexpr Vector ProjectiveTranslator::dot(const Vector& b) const noexcept { return {.x = b.x * s, .y = b.y * s, .z = b.z * s}; }
    constexpr ProjectivePoint ProjectiveTranslator::dot(const Point& b) const noexcept { return {.x = b.x * s, .y = b.y * s, .z = b.z * s, .w = s}; }
    constexpr Plane ProjectiveTranslator::dot(const PlaneIdeal& b) const noexcept { return {.x = b.x * s, .y = b.y * s, .z = b.z * s, .w = (b.x * wx + b.y * wy + b.z * wz)}; }
    constexpr BivectorBulk ProjectiveTranslator::dot(const BivectorBulk& b) const noexcept { return {.xy = b.xy * s, .xz = b.xz * s, .yz = b.yz * s}; }
    constexpr BivectorWeight ProjectiveTranslator::dot(const BivectorWeight& b) const noexcept { return {.wx = b.wx * s, .wy = b.wy * s, .wz = b.wz * s}; }
    constexpr PseudoScalar ProjectiveTranslator::dot(const PseudoScalar& b) const noexcept { return {.i = b.i * s}; }
    constexpr ProjectivePoint ProjectiveTranslator::dot(const PointCenter& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = s}; }

    constexpr Motor Translator::dot(const Motor& b) const noexcept { return {.s = b.s, .wx = (b.wx + b.s * wx), .wy = (b.wy + b.s * wy), .wz = (b.wz + b.s * wz), .xy = b.xy, .xz = b.xz, .yz = b.yz, .i = b.i}; }
    constexpr Plane Translator::dot(const Plane& b) const noexcept { return {.x = b.x, .y = b.y, .z = b.z, .w = (b.w + b.x * wx + b.y * wy + b.z * wz)}; }
    constexpr Bivector Translator::dot(const Bivector& b) const noexcept { return {.wx = b.wx, .wy = b.wy, .wz = b.wz, .xy = b.xy, .xz = b.xz, .yz = b.yz}; }
    constexpr ProjectivePoint Translator::dot(const ProjectivePoint& b) const noexcept { return {.x = b.x, .y = b.y, .z = b.z, .w = b.w}; }
    constexpr Motor Translator::dot(const Quaternion& b) const noexcept { return {.s = b.s, .wx = b.s * wx, .wy = b.s * wy, .wz = b.s * wz, .xy = b.xy, .xz = b.xz, .yz = b.yz, .i = 0.0}; }
    constexpr ProjectiveTranslator Translator::dot(const ProjectiveTranslator& b) const noexcept { return {.s = b.s, .wx = (b.wx + b.s * wx), .wy = (b.wy + b.s * wy), .wz = (b.wz + b.s * wz)}; }
    constexpr Translator Translator::dot(const Translator& b) const noexcept { return {.wx = (b.wx + wx), .wy = (b.wy + wy), .wz = (b.wz + wz)}; }
    constexpr Vector Translator::dot(const Vector& b) const noexcept { return {.x = b.x, .y = b.y, .z = b.z}; }
    constexpr Point Translator::dot(const Point& b) const noexcept { return {.x = b.x, .y = b.y, .z = b.z}; }
    constexpr Plane Translator::dot(const PlaneIdeal& b) const noexcept { return {.x = b.x, .y = b.y, .z = b.z, .w = (b.x * wx + b.y * wy + b.z * wz)}; }
    constexpr BivectorBulk Translator::dot(const BivectorBulk& b) const noexcept { return {.xy = b.xy, .xz = b.xz, .yz = b.yz}; }
    constexpr BivectorWeight Translator::dot(const BivectorWeight& b) const noexcept { return {.wx = b.wx, .wy = b.wy, .wz = b.wz}; }
    constexpr PseudoScalar Translator::dot(const PseudoScalar& b) const noexcept { return {.i = b.i}; }
    constexpr PointCenter Translator::dot(const PointCenter& b) const noexcept { return {}; }

    constexpr Multivector Vector::dot(const Motor& b) const noexcept { return {.s = 0.0, .w = (b.xy * z + b.yz * x - b.xz * y), .x = 0.0, .y = 0.0, .z = 0.0, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = -b.s * z, .wxz = b.s * y, .wyz = -b.s * x, .xyz = 0.0, .i = 0.0}; }
    constexpr BivectorWeight Vector::dot(const Plane& b) const noexcept { return {.wx = (b.z * y - b.y * z), .wy = (b.x * z - b.z * x), .wz = (b.y * x - b.x * y)}; }
    constexpr Plane Vector::dot(const Bivector& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = (b.xy * z + b.yz * x - b.xz * y)}; }
    constexpr Multivector Vector::dot(const Quaternion& b) const noexcept { return {.s = 0.0, .w = (b.xy * z + b.yz * x - b.xz * y), .x = 0.0, .y = 0.0, .z = 0.0, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = -b.s * z, .wxz = b.s * y, .wyz = -b.s * x, .xyz = 0.0, .i = 0.0}; }
    constexpr Vector Vector::dot(const ProjectiveTranslator& b) const noexcept { return {.x = b.s * x, .y = b.s * y, .z = b.s * z}; }
    constexpr Vector Vector::dot(const Translator& b) const noexcept { return {.x = x, .y = y, .z = z}; }
    constexpr BivectorWeight Vector::dot(const PlaneIdeal& b) const noexcept { return {.wx = (b.z * y - b.y * z), .wy = (b.x * z - b.z * x), .wz = (b.y * x - b.x * y)}; }
    constexpr Plane Vector::dot(const BivectorBulk& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = (b.xy * z + b.yz * x - b.xz * y)}; }

    constexpr Multivector Point::dot(const Motor& b) const noexcept { return {.s = 0.0, .w = (b.i + b.xy * z + b.yz * x - b.xz * y), .x = -b.yz, .y = b.xz, .z = -b.xy, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = -b.s * z, .wxz = b.s * y, .wyz = -b.s * x, .xyz = b.s, .i = 0.0}; }
    constexpr Bivector Point::dot(const Plane& b) const noexcept { return {.wx = (b.z * y - b.y * z), .wy = (b.x * z - b.z * x), .wz = (b.y * x - b.x * y), .xy = b.z, .xz = -b.y, .yz = b.x}; }
    constexpr Plane Point::dot(const Bivector& b) const noexcept { return {.x = -b.yz, .y = b.xz, .z = -b.xy, .w = (b.xy * z + b.yz * x - b.xz * y)}; }
    constexpr double Point::dot(const ProjectivePoint& b) const noexcept { return -b.w; }
    constexpr Multivector Point::dot(const Quaternion& b) const noexcept { return {.s = 0.0, .w = (b.xy * z + b.yz * x - b.xz * y), .x = -b.yz, .y = b.xz, .z = -b.xy, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = -b.s * z, .wxz = b.s * y, .wyz = -b.s * x, .xyz = b.s, .i = 0.0}; }
    constexpr ProjectivePoint Point::dot(const ProjectiveTranslator& b) const noexcept { return {.x = b.s * x, .y = b.s * y, .z = b.s * z, .w = b.s}; }
    constexpr Point Point::dot(const Translator& b) const noexcept { return {.x = x, .y = y, .z = z}; }
    constexpr double Point::dot(const Point& b) const noexcept { return -1.0; }
    constexpr Bivector Point::dot(const PlaneIdeal& b) const noexcept { return {.wx = (b.z * y - b.y * z), .wy = (b.x * z - b.z * x), .wz = (b.y * x - b.x * y), .xy = b.z, .xz = -b.y, .yz = b.x}; }
    constexpr Plane Point::dot(const BivectorBulk& b) const noexcept { return {.x = -b.yz, .y = b.xz, .z = -b.xy, .w = (b.xy * z + b.yz * x - b.xz * y)}; }
    constexpr Plane Point::dot(const PseudoScalar& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = b.i}; }
    constexpr double Point::dot(const PointCenter& b) const noexcept { return -1.0; }

    constexpr Multivector PlaneIdeal::dot(const Motor& b) const noexcept { return {.s = 0.0, .w = (-b.wx * x - b.wy * y - b.wz * z), .x = (b.s * x - b.xy * y - b.xz * z), .y = (b.s * y + b.xy * x - b.yz * z), .z = (b.s * z + b.xz * x + b.yz * y), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = -b.i * z, .wxz = b.i * y, .wyz = -b.i * x, .xyz = 0.0, .i = 0.0}; }
    constexpr double PlaneIdeal::dot(const Plane& b) const noexcept { return (b.x * x + b.y * y + b.z * z); }
    constexpr Plane PlaneIdeal::dot(const Bivector& b) const noexcept { return {.x = (-b.xy * y - b.xz * z), .y = (b.xy * x - b.yz * z), .z = (b.xz * x + b.yz * y), .w = (-b.wx * x - b.wy * y - b.wz * z)}; }
    constexpr Bivector PlaneIdeal::dot(const ProjectivePoint& b) const noexcept { return {.wx = (b.y * z - b.z * y), .wy = (b.z * x - b.x * z), .wz = (b.x * y - b.y * x), .xy = b.w * z, .xz = -b.w * y, .yz = b.w * x}; }
    constexpr PlaneIdeal PlaneIdeal::dot(const Quaternion& b) const noexcept { return {.x = (b.s * x - b.xy * y - b.xz * z), .y = (b.s * y + b.xy * x - b.yz * z), .z = (b.s * z + b.xz * x + b.yz * y)}; }
    constexpr Plane PlaneIdeal::dot(const ProjectiveTranslator& b) const noexcept { return {.x = b.s * x, .y = b.s * y, .z = b.s * z, .w = (-b.wx * x - b.wy * y - b.wz * z)}; }
    constexpr Plane PlaneIdeal::dot(const Translator& b) const noexcept { return {.x = x, .y = y, .z = z, .w = (-b.wx * x - b.wy * y - b.wz * z)}; }
    constexpr BivectorWeight PlaneIdeal::dot(const Vector& b) const noexcept { return {.wx = (b.y * z - b.z * y), .wy = (b.z * x - b.x * z), .wz = (b.x * y - b.y * x)}; }
    constexpr Bivector PlaneIdeal::dot(const Point& b) const noexcept { return {.wx = (b.y * z - b.z * y), .wy = (b.z * x - b.x * z), .wz = (b.x * y - b.y * x), .xy = z, .xz = -y, .yz = x}; }
    constexpr double PlaneIdeal::dot(const PlaneIdeal& b) const noexcept { return (b.x * x + b.y * y + b.z * z); }
    constexpr PlaneIdeal PlaneIdeal::dot(const BivectorBulk& b) const noexcept { return {.x = (-b.xy * y - b.xz * z), .y = (b.xy * x - b.yz * z), .z = (b.xz * x + b.yz * y)}; }
    constexpr Plane PlaneIdeal::dot(const BivectorWeight& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = (-b.wx * x - b.wy * y - b.wz * z)}; }
    constexpr Vector PlaneIdeal::dot(const PseudoScalar& b) const noexcept { return {.x = b.i * x, .y = b.i * y, .z = b.i * z}; }
    constexpr BivectorBulk PlaneIdeal::dot(const PointCenter& b) const noexcept { return {.xy = z, .xz = -y, .yz = x}; }

    constexpr Motor BivectorBulk::dot(const Motor& b) const noexcept { return {.s = (-b.xy * xy - b.xz * xz - b.yz * yz), .wx = -b.i * yz, .wy = b.i * xz, .wz = -b.i * xy, .xy = b.s * xy, .xz = b.s * xz, .yz = b.s * yz, .i = 0.0}; }
    constexpr PlaneIdeal BivectorBulk::dot(const Plane& b) const noexcept { return {.x = (b.y * xy + b.z * xz), .y = (b.z * yz - b.x * xy), .z = (-b.x * xz - b.y * yz)}; }
    constexpr double BivectorBulk::dot(const Bivector& b) const noexcept { return (-b.xy * xy - b.xz * xz - b.yz * yz); }
    constexpr Plane BivectorBulk::dot(const ProjectivePoint& b) const noexcept { return {.x = -b.w * yz, .y = b.w * xz, .z = -b.w * xy, .w = (b.x * yz + b.z * xy - b.y * xz)}; }
    constexpr Quaternion BivectorBulk::dot(const Quaternion& b) const noexcept { return {.s = (-b.xy * xy - b.xz * xz - b.yz * yz), .xy = b.s * xy, .xz = b.s * xz, .yz = b.s * yz}; }
    constexpr BivectorBulk BivectorBulk::dot(const ProjectiveTranslator& b) const noexcept { return {.xy = b.s * xy, .xz = b.s * xz, .yz = b.s * yz}; }
    constexpr BivectorBulk BivectorBulk::dot(const Translator& b) const noexcept { return {.xy = xy, .xz = xz, .yz = yz}; }
    constexpr Plane BivectorBulk::dot(const Vector& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = (b.x * yz + b.z * xy - b.y * xz)}; }
    constexpr Plane BivectorBulk::dot(const Point& b) const noexcept { return {.x = -yz, .y = xz, .z = -xy, .w = (b.x * yz + b.z * xy - b.y * xz)}; }
    constexpr PlaneIdeal BivectorBulk::dot(const PlaneIdeal& b) const noexcept { return {.x = (b.y * xy + b.z * xz), .y = (b.z * yz - b.x * xy), .z = (-b.x * xz - b.y * yz)}; }
    constexpr double BivectorBulk::dot(const BivectorBulk& b) const noexcept { return (-b.xy * xy - b.xz * xz - b.yz * yz); }
    constexpr BivectorWeight BivectorBulk::dot(const PseudoScalar& b) const noexcept { return {.wx = -b.i * yz, .wy = b.i * xz, .wz = -b.i * xy}; }
    constexpr PlaneIdeal BivectorBulk::dot(const PointCenter& b) const noexcept { return {.x = -yz, .y = xz, .z = -xy}; }

    constexpr BivectorWeight BivectorWeight::dot(const Motor& b) const noexcept { return {.wx = b.s * wx, .wy = b.s * wy, .wz = b.s * wz}; }
    constexpr Plane BivectorWeight::dot(const Plane& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = (b.x * wx + b.y * wy + b.z * wz)}; }
    constexpr BivectorWeight BivectorWeight::dot(const Quaternion& b) const noexcept { return {.wx = b.s * wx, .wy = b.s * wy, .wz = b.s * wz}; }
    constexpr BivectorWeight BivectorWeight::dot(const ProjectiveTranslator& b) const noexcept { return {.wx = b.s * wx, .wy = b.s * wy, .wz = b.s * wz}; }
    constexpr BivectorWeight BivectorWeight::dot(const Translator& b) const noexcept { return {.wx = wx, .wy = wy, .wz = wz}; }
    constexpr Plane BivectorWeight::dot(const PlaneIdeal& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = (b.x * wx + b.y * wy + b.z * wz)}; }

    constexpr Motor PseudoScalar::dot(const Motor& b) const noexcept { return {.s = 0.0, .wx = -b.yz * i, .wy = b.xz * i, .wz = -b.xy * i, .xy = 0.0, .xz = 0.0, .yz = 0.0, .i = b.s * i}; }
    constexpr Vector PseudoScalar::dot(const Plane& b) const noexcept { return {.x = -b.x * i, .y = -b.y * i, .z = -b.z * i}; }
    constexpr BivectorWeight PseudoScalar::dot(const Bivector& b) const noexcept { return {.wx = -b.yz * i, .wy = b.xz * i, .wz = -b.xy * i}; }
    constexpr Plane PseudoScalar::dot(const ProjectivePoint& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = -b.w * i}; }
    constexpr Motor PseudoScalar::dot(const Quaternion& b) const noexcept { return {.s = 0.0, .wx = -b.yz * i, .wy = b.xz * i, .wz = -b.xy * i, .xy = 0.0, .xz = 0.0, .yz = 0.0, .i = b.s * i}; }
    constexpr PseudoScalar PseudoScalar::dot(const ProjectiveTranslator& b) const noexcept { return {.i = b.s * i}; }
    constexpr PseudoScalar PseudoScalar::dot(const Translator& b) const noexcept { return {.i = i}; }
    constexpr Plane PseudoScalar::dot(const Point& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = -i}; }
    constexpr Vector PseudoScalar::dot(const PlaneIdeal& b) const noexcept { return {.x = -b.x * i, .y = -b.y * i, .z = -b.z * i}; }
    constexpr BivectorWeight PseudoScalar::dot(const BivectorBulk& b) const noexcept { return {.wx = -b.yz * i, .wy = b.xz * i, .wz = -b.xy * i}; }
    constexpr Plane PseudoScalar::dot(const PointCenter& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = -i}; }

    constexpr Multivector PointCenter::dot(const Motor& b) const noexcept { return {.s = 0.0, .w = b.i, .x = -b.yz, .y = b.xz, .z = -b.xy, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = 0.0, .wxz = 0.0, .wyz = 0.0, .xyz = b.s, .i = 0.0}; }
    constexpr BivectorBulk PointCenter::dot(const Plane& b) const noexcept { return {.xy = b.z, .xz = -b.y, .yz = b.x}; }
    constexpr PlaneIdeal PointCenter::dot(const Bivector& b) const noexcept { return {.x = -b.yz, .y = b.xz, .z = -b.xy}; }
    constexpr double PointCenter::dot(const ProjectivePoint& b) const noexcept { return -b.w; }
    constexpr Multivector PointCenter::dot(const Quaternion& b) const noexcept { return {.s = 0.0, .w = 0.0, .x = -b.yz, .y = b.xz, .z = -b.xy, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = 0.0, .wxz = 0.0, .wyz = 0.0, .xyz = b.s, .i = 0.0}; }
    constexpr ProjectivePoint PointCenter::dot(const ProjectiveTranslator& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = b.s}; }
    constexpr PointCenter PointCenter::dot(const Translator& b) const noexcept { return {}; }
    constexpr double PointCenter::dot(const Point& b) const noexcept { return -1.0; }
    constexpr BivectorBulk PointCenter::dot(const PlaneIdeal& b) const noexcept { return {.xy = b.z, .xz = -b.y, .yz = b.x}; }
    constexpr PlaneIdeal PointCenter::dot(const BivectorBulk& b) const noexcept { return {.x = -b.yz, .y = b.xz, .z = -b.xy}; }
    constexpr Plane PointCenter::dot(const PseudoScalar& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = b.i}; }
    constexpr double PointCenter::dot(const PointCenter& b) const noexcept { return -1.0; }

}

// opsProject.h

// generated by com.github.kright.pga3d.codegen.cpp.ops.ProjectionOpsGenerator

namespace pga3d {
    [[nodiscard]] constexpr Bivector Bivector::projectOntoPlane(const Plane& plane) const noexcept { return -plane.dot(*this).geometric(plane).toBivectorUnsafe(); }
    [[nodiscard]] constexpr Bivector Bivector::projectOntoPlane(const PlaneIdeal& plane) const noexcept { return -plane.dot(*this).geometric(plane).toBivectorUnsafe(); }
    [[nodiscard]] constexpr ProjectivePoint ProjectivePoint::projectOntoPlane(const Plane& plane) const noexcept { return plane.dot(*this).geometric(plane).toProjectivePointUnsafe(); };
    [[nodiscard]] constexpr ProjectivePoint ProjectivePoint::projectOntoPlane(const PlaneIdeal& plane) const noexcept { return plane.dot(*this).geometric(plane).toProjectivePointUnsafe(); };
    [[nodiscard]] constexpr ProjectivePoint ProjectivePoint::projectOntoLine(const Bivector& line) const noexcept { return -line.dot(*this).geometric(line).toProjectivePointUnsafe(); };
    [[nodiscard]] constexpr ProjectivePoint Point::projectOntoPlane(const Plane& plane) const noexcept { return plane.dot(*this).geometric(plane).toProjectivePointUnsafe(); };
    [[nodiscard]] constexpr ProjectivePoint Point::projectOntoPlane(const PlaneIdeal& plane) const noexcept { return plane.dot(*this).geometric(plane).toProjectivePointUnsafe(); };
    [[nodiscard]] constexpr ProjectivePoint Point::projectOntoLine(const Bivector& line) const noexcept { return -line.dot(*this).geometric(line).toProjectivePointUnsafe(); };
    [[nodiscard]] constexpr ProjectivePoint PointCenter::projectOntoPlane(const Plane& plane) const noexcept { return plane.dot(*this).geometric(plane).toProjectivePointUnsafe(); };
    [[nodiscard]] constexpr ProjectivePoint PointCenter::projectOntoPlane(const PlaneIdeal& plane) const noexcept { return plane.dot(*this).geometric(plane).toProjectivePointUnsafe(); };
    [[nodiscard]] constexpr ProjectivePoint PointCenter::projectOntoLine(const Bivector& line) const noexcept { return -line.dot(*this).geometric(line).toProjectivePointUnsafe(); };
}

// opsAntiGeometric.h

// generated by com.github.kright.pga3d.codegen.cpp.ops.AntiGeometricOpGenerator

namespace pga3d {
    constexpr Multivector Multivector::antiGeometric(const Multivector& b) const noexcept { return {.s = (b.i * s + b.s * i + b.w * xyz + b.wx * yz + b.wxy * z + b.wyz * x + b.wz * xy + b.xy * wz + b.y * wxz + b.yz * wx - b.wxz * y - b.wy * xz - b.x * wyz - b.xyz * w - b.xz * wy - b.z * wxy), .w = (b.i * w + b.w * i + b.wxz * wy + b.wy * wxz - b.wx * wyz - b.wxy * wz - b.wyz * wx - b.wz * wxy), .x = (b.i * x + b.wxz * xy + b.wy * z + b.wyz * s + b.x * i + b.xy * wxz + b.y * wz + b.yz * w - b.s * wyz - b.w * yz - b.wx * xyz - b.wxy * xz - b.wz * y - b.xyz * wx - b.xz * wxy - b.z * wy), .y = (b.i * y + b.s * wxz + b.w * xz + b.wyz * xy + b.wz * x + b.xy * wyz + b.y * i + b.z * wx - b.wx * z - b.wxy * yz - b.wxz * s - b.wy * xyz - b.x * wz - b.xyz * wy - b.xz * w - b.yz * wxy), .z = (b.i * z + b.wx * y + b.wxy * s + b.wyz * xz + b.x * wy + b.xy * w + b.xz * wyz + b.z * i - b.s * wxy - b.w * xy - b.wxz * yz - b.wy * x - b.wz * xyz - b.xyz * wz - b.y * wx - b.yz * wxz), .wx = (b.i * wx + b.wx * i + b.wxz * wxy + b.wy * wz - b.w * wyz - b.wxy * wxz - b.wyz * w - b.wz * wy), .wy = (b.i * wy + b.w * wxz + b.wxz * w + b.wy * i + b.wyz * wxy + b.wz * wx - b.wx * wz - b.wxy * wyz), .wz = (b.i * wz + b.wx * wy + b.wyz * wxz + b.wz * i - b.w * wxy - b.wxy * w - b.wxz * wyz - b.wy * wx), .xy = (b.i * xy + b.w * z + b.wxz * x + b.wyz * y + b.x * wxz + b.xy * i + b.xyz * wxy + b.xz * wx + b.y * wyz + b.yz * wy - b.s * wz - b.wx * xz - b.wxy * xyz - b.wy * yz - b.wz * s - b.z * w), .xz = (b.i * xz + b.s * wy + b.wx * xy + b.wy * s + b.wyz * z + b.xyz * wxz + b.xz * i + b.y * w + b.yz * wz + b.z * wyz - b.w * y - b.wxy * x - b.wxz * xyz - b.wz * yz - b.x * wxy - b.xy * wx), .yz = (b.i * yz + b.w * x + b.wy * xy + b.wz * xz + b.xyz * wyz + b.yz * i - b.s * wx - b.wx * s - b.wxy * y - b.wxz * z - b.wyz * xyz - b.x * w - b.xy * wy - b.xz * wz - b.y * wxy - b.z * wxz), .wxy = (b.i * wxy + b.w * wz + b.wxy * i + b.wxz * wx + b.wyz * wy + b.wz * w - b.wx * wxz - b.wy * wyz), .wxz = (b.i * wxz + b.wx * wxy + b.wxz * i + b.wyz * wz - b.w * wy - b.wxy * wx - b.wy * w - b.wz * wyz), .wyz = (b.i * wyz + b.w * wx + b.wx * w + b.wy * wxy + b.wyz * i + b.wz * wxz - b.wxy * wy - b.wxz * wz), .xyz = (b.i * xyz + b.s * w + b.wx * x + b.wy * y + b.wz * z + b.x * wx + b.xy * wxy + b.xyz * i + b.xz * wxz + b.y * wy + b.yz * wyz + b.z * wz - b.w * s - b.wxy * xy - b.wxz * xz - b.wyz * yz), .i = (b.i * i + b.wxy * wxy + b.wxz * wxz + b.wyz * wyz - b.w * w - b.wx * wx - b.wy * wy - b.wz * wz)}; }

    constexpr Motor Motor::antiGeometric(const Motor& b) const noexcept { return {.s = (b.i * s + b.s * i + b.wx * yz + b.wz * xy + b.xy * wz + b.yz * wx - b.wy * xz - b.xz * wy), .wx = (b.i * wx + b.wx * i + b.wy * wz - b.wz * wy), .wy = (b.i * wy + b.wy * i + b.wz * wx - b.wx * wz), .wz = (b.i * wz + b.wx * wy + b.wz * i - b.wy * wx), .xy = (b.i * xy + b.xy * i + b.xz * wx + b.yz * wy - b.s * wz - b.wx * xz - b.wy * yz - b.wz * s), .xz = (b.i * xz + b.s * wy + b.wx * xy + b.wy * s + b.xz * i + b.yz * wz - b.wz * yz - b.xy * wx), .yz = (b.i * yz + b.wy * xy + b.wz * xz + b.yz * i - b.s * wx - b.wx * s - b.xy * wy - b.xz * wz), .i = (b.i * i - b.wx * wx - b.wy * wy - b.wz * wz)}; }
    constexpr Multivector Motor::antiGeometric(const Plane& b) const noexcept { return {.s = 0.0, .w = b.w * i, .x = (b.x * i + b.y * wz - b.w * yz - b.z * wy), .y = (b.w * xz + b.y * i + b.z * wx - b.x * wz), .z = (b.x * wy + b.z * i - b.w * xy - b.y * wx), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = b.w * wz, .wxz = -b.w * wy, .wyz = b.w * wx, .xyz = (b.x * wx + b.y * wy + b.z * wz - b.w * s), .i = 0.0}; }
    constexpr Motor Motor::antiGeometric(const Bivector& b) const noexcept { return {.s = (b.wx * yz + b.wz * xy + b.xy * wz + b.yz * wx - b.wy * xz - b.xz * wy), .wx = (b.wx * i + b.wy * wz - b.wz * wy), .wy = (b.wy * i + b.wz * wx - b.wx * wz), .wz = (b.wx * wy + b.wz * i - b.wy * wx), .xy = (b.xy * i + b.xz * wx + b.yz * wy - b.wx * xz - b.wy * yz - b.wz * s), .xz = (b.wx * xy + b.wy * s + b.xz * i + b.yz * wz - b.wz * yz - b.xy * wx), .yz = (b.wy * xy + b.wz * xz + b.yz * i - b.wx * s - b.xy * wy - b.xz * wz), .i = (-b.wx * wx - b.wy * wy - b.wz * wz)}; }
    constexpr Multivector Motor::antiGeometric(const ProjectivePoint& b) const noexcept { return {.s = 0.0, .w = (b.x * wx + b.y * wy + b.z * wz), .x = (b.y * xy + b.z * xz - b.w * wx - b.x * s), .y = (b.z * yz - b.w * wy - b.x * xy - b.y * s), .z = (-b.w * wz - b.x * xz - b.y * yz - b.z * s), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.y * wx - b.x * wy - b.z * i), .wxz = (b.y * i + b.z * wx - b.x * wz), .wyz = (b.z * wy - b.x * i - b.y * wz), .xyz = (b.w * i + b.x * yz + b.z * xy - b.y * xz), .i = 0.0}; }
    constexpr Quaternion Motor::antiGeometric(const Quaternion& b) const noexcept { return {.s = (b.s * i + b.xy * wz + b.yz * wx - b.xz * wy), .xy = (b.xy * i + b.xz * wx + b.yz * wy - b.s * wz), .xz = (b.s * wy + b.xz * i + b.yz * wz - b.xy * wx), .yz = (b.yz * i - b.s * wx - b.xy * wy - b.xz * wz)}; }
    constexpr Motor Motor::antiGeometric(const ProjectiveTranslator& b) const noexcept { return {.s = (b.s * i + b.wx * yz + b.wz * xy - b.wy * xz), .wx = (b.wx * i + b.wy * wz - b.wz * wy), .wy = (b.wy * i + b.wz * wx - b.wx * wz), .wz = (b.wx * wy + b.wz * i - b.wy * wx), .xy = (-b.s * wz - b.wx * xz - b.wy * yz - b.wz * s), .xz = (b.s * wy + b.wx * xy + b.wy * s - b.wz * yz), .yz = (b.wy * xy + b.wz * xz - b.s * wx - b.wx * s), .i = (-b.wx * wx - b.wy * wy - b.wz * wz)}; }
    constexpr Motor Motor::antiGeometric(const Translator& b) const noexcept { return {.s = (i + b.wx * yz + b.wz * xy - b.wy * xz), .wx = (b.wx * i + b.wy * wz - b.wz * wy), .wy = (b.wy * i + b.wz * wx - b.wx * wz), .wz = (b.wx * wy + b.wz * i - b.wy * wx), .xy = (-wz - b.wx * xz - b.wy * yz - b.wz * s), .xz = (wy + b.wx * xy + b.wy * s - b.wz * yz), .yz = (-wx + b.wy * xy + b.wz * xz - b.wx * s), .i = (-b.wx * wx - b.wy * wy - b.wz * wz)}; }
    constexpr Multivector Motor::antiGeometric(const Vector& b) const noexcept { return {.s = 0.0, .w = (b.x * wx + b.y * wy + b.z * wz), .x = (b.y * xy + b.z * xz - b.x * s), .y = (b.z * yz - b.x * xy - b.y * s), .z = (-b.x * xz - b.y * yz - b.z * s), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.y * wx - b.x * wy - b.z * i), .wxz = (b.y * i + b.z * wx - b.x * wz), .wyz = (b.z * wy - b.x * i - b.y * wz), .xyz = (b.x * yz + b.z * xy - b.y * xz), .i = 0.0}; }
    constexpr Multivector Motor::antiGeometric(const Point& b) const noexcept { return {.s = 0.0, .w = (b.x * wx + b.y * wy + b.z * wz), .x = (-wx + b.y * xy + b.z * xz - b.x * s), .y = (-wy + b.z * yz - b.x * xy - b.y * s), .z = (-wz - b.x * xz - b.y * yz - b.z * s), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.y * wx - b.x * wy - b.z * i), .wxz = (b.y * i + b.z * wx - b.x * wz), .wyz = (b.z * wy - b.x * i - b.y * wz), .xyz = (i + b.x * yz + b.z * xy - b.y * xz), .i = 0.0}; }
    constexpr Multivector Motor::antiGeometric(const PlaneIdeal& b) const noexcept { return {.s = 0.0, .w = 0.0, .x = (b.x * i + b.y * wz - b.z * wy), .y = (b.y * i + b.z * wx - b.x * wz), .z = (b.x * wy + b.z * i - b.y * wx), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = 0.0, .wxz = 0.0, .wyz = 0.0, .xyz = (b.x * wx + b.y * wy + b.z * wz), .i = 0.0}; }
    constexpr Quaternion Motor::antiGeometric(const BivectorBulk& b) const noexcept { return {.s = (b.xy * wz + b.yz * wx - b.xz * wy), .xy = (b.xy * i + b.xz * wx + b.yz * wy), .xz = (b.xz * i + b.yz * wz - b.xy * wx), .yz = (b.yz * i - b.xy * wy - b.xz * wz)}; }
    constexpr Motor Motor::antiGeometric(const BivectorWeight& b) const noexcept { return {.s = (b.wx * yz + b.wz * xy - b.wy * xz), .wx = (b.wx * i + b.wy * wz - b.wz * wy), .wy = (b.wy * i + b.wz * wx - b.wx * wz), .wz = (b.wx * wy + b.wz * i - b.wy * wx), .xy = (-b.wx * xz - b.wy * yz - b.wz * s), .xz = (b.wx * xy + b.wy * s - b.wz * yz), .yz = (b.wy * xy + b.wz * xz - b.wx * s), .i = (-b.wx * wx - b.wy * wy - b.wz * wz)}; }
    constexpr Motor Motor::antiGeometric(const PseudoScalar& b) const noexcept { return {.s = b.i * s, .wx = b.i * wx, .wy = b.i * wy, .wz = b.i * wz, .xy = b.i * xy, .xz = b.i * xz, .yz = b.i * yz, .i = b.i * i}; }
    constexpr Multivector Motor::antiGeometric(const PointCenter& b) const noexcept { return {.s = 0.0, .w = 0.0, .x = -wx, .y = -wy, .z = -wz, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = 0.0, .wxz = 0.0, .wyz = 0.0, .xyz = i, .i = 0.0}; }

    constexpr Multivector Plane::antiGeometric(const Motor& b) const noexcept { return {.s = 0.0, .w = b.i * w, .x = (b.i * x + b.wy * z + b.yz * w - b.wz * y), .y = (b.i * y + b.wz * x - b.wx * z - b.xz * w), .z = (b.i * z + b.wx * y + b.xy * w - b.wy * x), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = b.wz * w, .wxz = -b.wy * w, .wyz = b.wx * w, .xyz = (b.s * w + b.wx * x + b.wy * y + b.wz * z), .i = 0.0}; }
    constexpr Motor Plane::antiGeometric(const Plane& b) const noexcept { return {.s = 0.0, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = (b.w * z - b.z * w), .xz = (b.y * w - b.w * y), .yz = (b.w * x - b.x * w), .i = -b.w * w}; }
    constexpr Multivector Plane::antiGeometric(const Bivector& b) const noexcept { return {.s = 0.0, .w = 0.0, .x = (b.wy * z + b.yz * w - b.wz * y), .y = (b.wz * x - b.wx * z - b.xz * w), .z = (b.wx * y + b.xy * w - b.wy * x), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = b.wz * w, .wxz = -b.wy * w, .wyz = b.wx * w, .xyz = (b.wx * x + b.wy * y + b.wz * z), .i = 0.0}; }
    constexpr Motor Plane::antiGeometric(const ProjectivePoint& b) const noexcept { return {.s = (-b.w * w - b.x * x - b.y * y - b.z * z), .wx = b.x * w, .wy = b.y * w, .wz = b.z * w, .xy = (b.y * x - b.x * y), .xz = (b.z * x - b.x * z), .yz = (b.z * y - b.y * z), .i = 0.0}; }
    constexpr Multivector Plane::antiGeometric(const Quaternion& b) const noexcept { return {.s = 0.0, .w = 0.0, .x = b.yz * w, .y = -b.xz * w, .z = b.xy * w, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = 0.0, .wxz = 0.0, .wyz = 0.0, .xyz = b.s * w, .i = 0.0}; }
    constexpr Multivector Plane::antiGeometric(const ProjectiveTranslator& b) const noexcept { return {.s = 0.0, .w = 0.0, .x = (b.wy * z - b.wz * y), .y = (b.wz * x - b.wx * z), .z = (b.wx * y - b.wy * x), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = b.wz * w, .wxz = -b.wy * w, .wyz = b.wx * w, .xyz = (b.s * w + b.wx * x + b.wy * y + b.wz * z), .i = 0.0}; }
    constexpr Multivector Plane::antiGeometric(const Translator& b) const noexcept { return {.s = 0.0, .w = 0.0, .x = (b.wy * z - b.wz * y), .y = (b.wz * x - b.wx * z), .z = (b.wx * y - b.wy * x), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = b.wz * w, .wxz = -b.wy * w, .wyz = b.wx * w, .xyz = (w + b.wx * x + b.wy * y + b.wz * z), .i = 0.0}; }
    constexpr Motor Plane::antiGeometric(const Vector& b) const noexcept { return {.s = (-b.x * x - b.y * y - b.z * z), .wx = b.x * w, .wy = b.y * w, .wz = b.z * w, .xy = (b.y * x - b.x * y), .xz = (b.z * x - b.x * z), .yz = (b.z * y - b.y * z), .i = 0.0}; }
    constexpr Motor Plane::antiGeometric(const Point& b) const noexcept { return {.s = (-w - b.x * x - b.y * y - b.z * z), .wx = b.x * w, .wy = b.y * w, .wz = b.z * w, .xy = (b.y * x - b.x * y), .xz = (b.z * x - b.x * z), .yz = (b.z * y - b.y * z), .i = 0.0}; }
    constexpr BivectorBulk Plane::antiGeometric(const PlaneIdeal& b) const noexcept { return {.xy = -b.z * w, .xz = b.y * w, .yz = -b.x * w}; }
    constexpr PlaneIdeal Plane::antiGeometric(const BivectorBulk& b) const noexcept { return {.x = b.yz * w, .y = -b.xz * w, .z = b.xy * w}; }
    constexpr Multivector Plane::antiGeometric(const BivectorWeight& b) const noexcept { return {.s = 0.0, .w = 0.0, .x = (b.wy * z - b.wz * y), .y = (b.wz * x - b.wx * z), .z = (b.wx * y - b.wy * x), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = b.wz * w, .wxz = -b.wy * w, .wyz = b.wx * w, .xyz = (b.wx * x + b.wy * y + b.wz * z), .i = 0.0}; }
    constexpr Plane Plane::antiGeometric(const PseudoScalar& b) const noexcept { return {.x = b.i * x, .y = b.i * y, .z = b.i * z, .w = b.i * w}; }
    constexpr double Plane::antiGeometric(const PointCenter& b) const noexcept { return -w; }

    constexpr Motor Bivector::antiGeometric(const Motor& b) const noexcept { return {.s = (b.wx * yz + b.wz * xy + b.xy * wz + b.yz * wx - b.wy * xz - b.xz * wy), .wx = (b.i * wx + b.wy * wz - b.wz * wy), .wy = (b.i * wy + b.wz * wx - b.wx * wz), .wz = (b.i * wz + b.wx * wy - b.wy * wx), .xy = (b.i * xy + b.xz * wx + b.yz * wy - b.s * wz - b.wx * xz - b.wy * yz), .xz = (b.i * xz + b.s * wy + b.wx * xy + b.yz * wz - b.wz * yz - b.xy * wx), .yz = (b.i * yz + b.wy * xy + b.wz * xz - b.s * wx - b.xy * wy - b.xz * wz), .i = (-b.wx * wx - b.wy * wy - b.wz * wz)}; }
    constexpr Multivector Bivector::antiGeometric(const Plane& b) const noexcept { return {.s = 0.0, .w = 0.0, .x = (b.y * wz - b.w * yz - b.z * wy), .y = (b.w * xz + b.z * wx - b.x * wz), .z = (b.x * wy - b.w * xy - b.y * wx), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = b.w * wz, .wxz = -b.w * wy, .wyz = b.w * wx, .xyz = (b.x * wx + b.y * wy + b.z * wz), .i = 0.0}; }
    constexpr Motor Bivector::antiGeometric(const Bivector& b) const noexcept { return {.s = (b.wx * yz + b.wz * xy + b.xy * wz + b.yz * wx - b.wy * xz - b.xz * wy), .wx = (b.wy * wz - b.wz * wy), .wy = (b.wz * wx - b.wx * wz), .wz = (b.wx * wy - b.wy * wx), .xy = (b.xz * wx + b.yz * wy - b.wx * xz - b.wy * yz), .xz = (b.wx * xy + b.yz * wz - b.wz * yz - b.xy * wx), .yz = (b.wy * xy + b.wz * xz - b.xy * wy - b.xz * wz), .i = (-b.wx * wx - b.wy * wy - b.wz * wz)}; }
    constexpr Multivector Bivector::antiGeometric(const ProjectivePoint& b) const noexcept { return {.s = 0.0, .w = (b.x * wx + b.y * wy + b.z * wz), .x = (b.y * xy + b.z * xz - b.w * wx), .y = (b.z * yz - b.w * wy - b.x * xy), .z = (-b.w * wz - b.x * xz - b.y * yz), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.y * wx - b.x * wy), .wxz = (b.z * wx - b.x * wz), .wyz = (b.z * wy - b.y * wz), .xyz = (b.x * yz + b.z * xy - b.y * xz), .i = 0.0}; }
    constexpr Quaternion Bivector::antiGeometric(const Quaternion& b) const noexcept { return {.s = (b.xy * wz + b.yz * wx - b.xz * wy), .xy = (b.xz * wx + b.yz * wy - b.s * wz), .xz = (b.s * wy + b.yz * wz - b.xy * wx), .yz = (-b.s * wx - b.xy * wy - b.xz * wz)}; }
    constexpr Motor Bivector::antiGeometric(const ProjectiveTranslator& b) const noexcept { return {.s = (b.wx * yz + b.wz * xy - b.wy * xz), .wx = (b.wy * wz - b.wz * wy), .wy = (b.wz * wx - b.wx * wz), .wz = (b.wx * wy - b.wy * wx), .xy = (-b.s * wz - b.wx * xz - b.wy * yz), .xz = (b.s * wy + b.wx * xy - b.wz * yz), .yz = (b.wy * xy + b.wz * xz - b.s * wx), .i = (-b.wx * wx - b.wy * wy - b.wz * wz)}; }
    constexpr Motor Bivector::antiGeometric(const Translator& b) const noexcept { return {.s = (b.wx * yz + b.wz * xy - b.wy * xz), .wx = (b.wy * wz - b.wz * wy), .wy = (b.wz * wx - b.wx * wz), .wz = (b.wx * wy - b.wy * wx), .xy = (-wz - b.wx * xz - b.wy * yz), .xz = (wy + b.wx * xy - b.wz * yz), .yz = (-wx + b.wy * xy + b.wz * xz), .i = (-b.wx * wx - b.wy * wy - b.wz * wz)}; }
    constexpr Multivector Bivector::antiGeometric(const Vector& b) const noexcept { return {.s = 0.0, .w = (b.x * wx + b.y * wy + b.z * wz), .x = (b.y * xy + b.z * xz), .y = (b.z * yz - b.x * xy), .z = (-b.x * xz - b.y * yz), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.y * wx - b.x * wy), .wxz = (b.z * wx - b.x * wz), .wyz = (b.z * wy - b.y * wz), .xyz = (b.x * yz + b.z * xy - b.y * xz), .i = 0.0}; }
    constexpr Multivector Bivector::antiGeometric(const Point& b) const noexcept { return {.s = 0.0, .w = (b.x * wx + b.y * wy + b.z * wz), .x = (-wx + b.y * xy + b.z * xz), .y = (-wy + b.z * yz - b.x * xy), .z = (-wz - b.x * xz - b.y * yz), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.y * wx - b.x * wy), .wxz = (b.z * wx - b.x * wz), .wyz = (b.z * wy - b.y * wz), .xyz = (b.x * yz + b.z * xy - b.y * xz), .i = 0.0}; }
    constexpr Multivector Bivector::antiGeometric(const PlaneIdeal& b) const noexcept { return {.s = 0.0, .w = 0.0, .x = (b.y * wz - b.z * wy), .y = (b.z * wx - b.x * wz), .z = (b.x * wy - b.y * wx), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = 0.0, .wxz = 0.0, .wyz = 0.0, .xyz = (b.x * wx + b.y * wy + b.z * wz), .i = 0.0}; }
    constexpr Quaternion Bivector::antiGeometric(const BivectorBulk& b) const noexcept { return {.s = (b.xy * wz + b.yz * wx - b.xz * wy), .xy = (b.xz * wx + b.yz * wy), .xz = (b.yz * wz - b.xy * wx), .yz = (-b.xy * wy - b.xz * wz)}; }
    constexpr Motor Bivector::antiGeometric(const BivectorWeight& b) const noexcept { return {.s = (b.wx * yz + b.wz * xy - b.wy * xz), .wx = (b.wy * wz - b.wz * wy), .wy = (b.wz * wx - b.wx * wz), .wz = (b.wx * wy - b.wy * wx), .xy = (-b.wx * xz - b.wy * yz), .xz = (b.wx * xy - b.wz * yz), .yz = (b.wy * xy + b.wz * xz), .i = (-b.wx * wx - b.wy * wy - b.wz * wz)}; }
    constexpr Bivector Bivector::antiGeometric(const PseudoScalar& b) const noexcept { return {.wx = b.i * wx, .wy = b.i * wy, .wz = b.i * wz, .xy = b.i * xy, .xz = b.i * xz, .yz = b.i * yz}; }
    constexpr PlaneIdeal Bivector::antiGeometric(const PointCenter& b) const noexcept { return {.x = -wx, .y = -wy, .z = -wz}; }

    constexpr Multivector ProjectivePoint::antiGeometric(const Motor& b) const noexcept { return {.s = 0.0, .w = (b.wx * x + b.wy * y + b.wz * z), .x = (b.s * x + b.xy * y + b.xz * z - b.wx * w), .y = (b.s * y + b.yz * z - b.wy * w - b.xy * x), .z = (b.s * z - b.wz * w - b.xz * x - b.yz * y), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.wy * x - b.i * z - b.wx * y), .wxz = (b.i * y + b.wz * x - b.wx * z), .wyz = (b.wz * y - b.i * x - b.wy * z), .xyz = (b.i * w + b.xz * y - b.xy * z - b.yz * x), .i = 0.0}; }
    constexpr Motor ProjectivePoint::antiGeometric(const Plane& b) const noexcept { return {.s = (b.w * w + b.x * x + b.y * y + b.z * z), .wx = b.w * x, .wy = b.w * y, .wz = b.w * z, .xy = (b.x * y - b.y * x), .xz = (b.x * z - b.z * x), .yz = (b.y * z - b.z * y), .i = 0.0}; }
    constexpr Multivector ProjectivePoint::antiGeometric(const Bivector& b) const noexcept { return {.s = 0.0, .w = (b.wx * x + b.wy * y + b.wz * z), .x = (b.xy * y + b.xz * z - b.wx * w), .y = (b.yz * z - b.wy * w - b.xy * x), .z = (-b.wz * w - b.xz * x - b.yz * y), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.wy * x - b.wx * y), .wxz = (b.wz * x - b.wx * z), .wyz = (b.wz * y - b.wy * z), .xyz = (b.xz * y - b.xy * z - b.yz * x), .i = 0.0}; }
    constexpr Motor ProjectivePoint::antiGeometric(const ProjectivePoint& b) const noexcept { return {.s = 0.0, .wx = (b.z * y - b.y * z), .wy = (b.x * z - b.z * x), .wz = (b.y * x - b.x * y), .xy = (b.z * w - b.w * z), .xz = (b.w * y - b.y * w), .yz = (b.x * w - b.w * x), .i = (b.x * x + b.y * y + b.z * z)}; }
    constexpr Multivector ProjectivePoint::antiGeometric(const Quaternion& b) const noexcept { return {.s = 0.0, .w = 0.0, .x = (b.s * x + b.xy * y + b.xz * z), .y = (b.s * y + b.yz * z - b.xy * x), .z = (b.s * z - b.xz * x - b.yz * y), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = 0.0, .wxz = 0.0, .wyz = 0.0, .xyz = (b.xz * y - b.xy * z - b.yz * x), .i = 0.0}; }
    constexpr Multivector ProjectivePoint::antiGeometric(const ProjectiveTranslator& b) const noexcept { return {.s = 0.0, .w = (b.wx * x + b.wy * y + b.wz * z), .x = (b.s * x - b.wx * w), .y = (b.s * y - b.wy * w), .z = (b.s * z - b.wz * w), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.wy * x - b.wx * y), .wxz = (b.wz * x - b.wx * z), .wyz = (b.wz * y - b.wy * z), .xyz = 0.0, .i = 0.0}; }
    constexpr Multivector ProjectivePoint::antiGeometric(const Translator& b) const noexcept { return {.s = 0.0, .w = (b.wx * x + b.wy * y + b.wz * z), .x = (x - b.wx * w), .y = (y - b.wy * w), .z = (z - b.wz * w), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.wy * x - b.wx * y), .wxz = (b.wz * x - b.wx * z), .wyz = (b.wz * y - b.wy * z), .xyz = 0.0, .i = 0.0}; }
    constexpr Motor ProjectivePoint::antiGeometric(const Vector& b) const noexcept { return {.s = 0.0, .wx = (b.z * y - b.y * z), .wy = (b.x * z - b.z * x), .wz = (b.y * x - b.x * y), .xy = b.z * w, .xz = -b.y * w, .yz = b.x * w, .i = (b.x * x + b.y * y + b.z * z)}; }
    constexpr Motor ProjectivePoint::antiGeometric(const Point& b) const noexcept { return {.s = 0.0, .wx = (b.z * y - b.y * z), .wy = (b.x * z - b.z * x), .wz = (b.y * x - b.x * y), .xy = (-z + b.z * w), .xz = (y - b.y * w), .yz = (-x + b.x * w), .i = (b.x * x + b.y * y + b.z * z)}; }
    constexpr Quaternion ProjectivePoint::antiGeometric(const PlaneIdeal& b) const noexcept { return {.s = (b.x * x + b.y * y + b.z * z), .xy = (b.x * y - b.y * x), .xz = (b.x * z - b.z * x), .yz = (b.y * z - b.z * y)}; }
    constexpr Multivector ProjectivePoint::antiGeometric(const BivectorBulk& b) const noexcept { return {.s = 0.0, .w = 0.0, .x = (b.xy * y + b.xz * z), .y = (b.yz * z - b.xy * x), .z = (-b.xz * x - b.yz * y), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = 0.0, .wxz = 0.0, .wyz = 0.0, .xyz = (b.xz * y - b.xy * z - b.yz * x), .i = 0.0}; }
    constexpr Multivector ProjectivePoint::antiGeometric(const BivectorWeight& b) const noexcept { return {.s = 0.0, .w = (b.wx * x + b.wy * y + b.wz * z), .x = -b.wx * w, .y = -b.wy * w, .z = -b.wz * w, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.wy * x - b.wx * y), .wxz = (b.wz * x - b.wx * z), .wyz = (b.wz * y - b.wy * z), .xyz = 0.0, .i = 0.0}; }
    constexpr ProjectivePoint ProjectivePoint::antiGeometric(const PseudoScalar& b) const noexcept { return {.x = b.i * x, .y = b.i * y, .z = b.i * z, .w = b.i * w}; }
    constexpr BivectorBulk ProjectivePoint::antiGeometric(const PointCenter& b) const noexcept { return {.xy = -z, .xz = y, .yz = -x}; }

    constexpr Quaternion Quaternion::antiGeometric(const Motor& b) const noexcept { return {.s = (b.i * s + b.wx * yz + b.wz * xy - b.wy * xz), .xy = (b.i * xy - b.wx * xz - b.wy * yz - b.wz * s), .xz = (b.i * xz + b.wx * xy + b.wy * s - b.wz * yz), .yz = (b.i * yz + b.wy * xy + b.wz * xz - b.wx * s)}; }
    constexpr Multivector Quaternion::antiGeometric(const Plane& b) const noexcept { return {.s = 0.0, .w = 0.0, .x = -b.w * yz, .y = b.w * xz, .z = -b.w * xy, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = 0.0, .wxz = 0.0, .wyz = 0.0, .xyz = -b.w * s, .i = 0.0}; }
    constexpr Quaternion Quaternion::antiGeometric(const Bivector& b) const noexcept { return {.s = (b.wx * yz + b.wz * xy - b.wy * xz), .xy = (-b.wx * xz - b.wy * yz - b.wz * s), .xz = (b.wx * xy + b.wy * s - b.wz * yz), .yz = (b.wy * xy + b.wz * xz - b.wx * s)}; }
    constexpr Multivector Quaternion::antiGeometric(const ProjectivePoint& b) const noexcept { return {.s = 0.0, .w = 0.0, .x = (b.y * xy + b.z * xz - b.x * s), .y = (b.z * yz - b.x * xy - b.y * s), .z = (-b.x * xz - b.y * yz - b.z * s), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = 0.0, .wxz = 0.0, .wyz = 0.0, .xyz = (b.x * yz + b.z * xy - b.y * xz), .i = 0.0}; }
    constexpr Quaternion Quaternion::antiGeometric(const ProjectiveTranslator& b) const noexcept { return {.s = (b.wx * yz + b.wz * xy - b.wy * xz), .xy = (-b.wx * xz - b.wy * yz - b.wz * s), .xz = (b.wx * xy + b.wy * s - b.wz * yz), .yz = (b.wy * xy + b.wz * xz - b.wx * s)}; }
    constexpr Quaternion Quaternion::antiGeometric(const Translator& b) const noexcept { return {.s = (b.wx * yz + b.wz * xy - b.wy * xz), .xy = (-b.wx * xz - b.wy * yz - b.wz * s), .xz = (b.wx * xy + b.wy * s - b.wz * yz), .yz = (b.wy * xy + b.wz * xz - b.wx * s)}; }
    constexpr Multivector Quaternion::antiGeometric(const Vector& b) const noexcept { return {.s = 0.0, .w = 0.0, .x = (b.y * xy + b.z * xz - b.x * s), .y = (b.z * yz - b.x * xy - b.y * s), .z = (-b.x * xz - b.y * yz - b.z * s), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = 0.0, .wxz = 0.0, .wyz = 0.0, .xyz = (b.x * yz + b.z * xy - b.y * xz), .i = 0.0}; }
    constexpr Multivector Quaternion::antiGeometric(const Point& b) const noexcept { return {.s = 0.0, .w = 0.0, .x = (b.y * xy + b.z * xz - b.x * s), .y = (b.z * yz - b.x * xy - b.y * s), .z = (-b.x * xz - b.y * yz - b.z * s), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = 0.0, .wxz = 0.0, .wyz = 0.0, .xyz = (b.x * yz + b.z * xy - b.y * xz), .i = 0.0}; }
    constexpr Quaternion Quaternion::antiGeometric(const BivectorWeight& b) const noexcept { return {.s = (b.wx * yz + b.wz * xy - b.wy * xz), .xy = (-b.wx * xz - b.wy * yz - b.wz * s), .xz = (b.wx * xy + b.wy * s - b.wz * yz), .yz = (b.wy * xy + b.wz * xz - b.wx * s)}; }
    constexpr Quaternion Quaternion::antiGeometric(const PseudoScalar& b) const noexcept { return {.s = b.i * s, .xy = b.i * xy, .xz = b.i * xz, .yz = b.i * yz}; }

    constexpr Motor ProjectiveTranslator::antiGeometric(const Motor& b) const noexcept { return {.s = (b.i * s + b.xy * wz + b.yz * wx - b.xz * wy), .wx = (b.i * wx + b.wy * wz - b.wz * wy), .wy = (b.i * wy + b.wz * wx - b.wx * wz), .wz = (b.i * wz + b.wx * wy - b.wy * wx), .xy = (b.xz * wx + b.yz * wy - b.s * wz - b.wz * s), .xz = (b.s * wy + b.wy * s + b.yz * wz - b.xy * wx), .yz = (-b.s * wx - b.wx * s - b.xy * wy - b.xz * wz), .i = (-b.wx * wx - b.wy * wy - b.wz * wz)}; }
    constexpr Multivector ProjectiveTranslator::antiGeometric(const Plane& b) const noexcept { return {.s = 0.0, .w = 0.0, .x = (b.y * wz - b.z * wy), .y = (b.z * wx - b.x * wz), .z = (b.x * wy - b.y * wx), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = b.w * wz, .wxz = -b.w * wy, .wyz = b.w * wx, .xyz = (b.x * wx + b.y * wy + b.z * wz - b.w * s), .i = 0.0}; }
    constexpr Motor ProjectiveTranslator::antiGeometric(const Bivector& b) const noexcept { return {.s = (b.xy * wz + b.yz * wx - b.xz * wy), .wx = (b.wy * wz - b.wz * wy), .wy = (b.wz * wx - b.wx * wz), .wz = (b.wx * wy - b.wy * wx), .xy = (b.xz * wx + b.yz * wy - b.wz * s), .xz = (b.wy * s + b.yz * wz - b.xy * wx), .yz = (-b.wx * s - b.xy * wy - b.xz * wz), .i = (-b.wx * wx - b.wy * wy - b.wz * wz)}; }
    constexpr Multivector ProjectiveTranslator::antiGeometric(const ProjectivePoint& b) const noexcept { return {.s = 0.0, .w = (b.x * wx + b.y * wy + b.z * wz), .x = (-b.w * wx - b.x * s), .y = (-b.w * wy - b.y * s), .z = (-b.w * wz - b.z * s), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.y * wx - b.x * wy), .wxz = (b.z * wx - b.x * wz), .wyz = (b.z * wy - b.y * wz), .xyz = 0.0, .i = 0.0}; }
    constexpr Quaternion ProjectiveTranslator::antiGeometric(const Quaternion& b) const noexcept { return {.s = (b.xy * wz + b.yz * wx - b.xz * wy), .xy = (b.xz * wx + b.yz * wy - b.s * wz), .xz = (b.s * wy + b.yz * wz - b.xy * wx), .yz = (-b.s * wx - b.xy * wy - b.xz * wz)}; }
    constexpr Motor ProjectiveTranslator::antiGeometric(const ProjectiveTranslator& b) const noexcept { return {.s = 0.0, .wx = (b.wy * wz - b.wz * wy), .wy = (b.wz * wx - b.wx * wz), .wz = (b.wx * wy - b.wy * wx), .xy = (-b.s * wz - b.wz * s), .xz = (b.s * wy + b.wy * s), .yz = (-b.s * wx - b.wx * s), .i = (-b.wx * wx - b.wy * wy - b.wz * wz)}; }
    constexpr Motor ProjectiveTranslator::antiGeometric(const Translator& b) const noexcept { return {.s = 0.0, .wx = (b.wy * wz - b.wz * wy), .wy = (b.wz * wx - b.wx * wz), .wz = (b.wx * wy - b.wy * wx), .xy = (-wz - b.wz * s), .xz = (wy + b.wy * s), .yz = (-wx - b.wx * s), .i = (-b.wx * wx - b.wy * wy - b.wz * wz)}; }
    constexpr Multivector ProjectiveTranslator::antiGeometric(const Vector& b) const noexcept { return {.s = 0.0, .w = (b.x * wx + b.y * wy + b.z * wz), .x = -b.x * s, .y = -b.y * s, .z = -b.z * s, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.y * wx - b.x * wy), .wxz = (b.z * wx - b.x * wz), .wyz = (b.z * wy - b.y * wz), .xyz = 0.0, .i = 0.0}; }
    constexpr Multivector ProjectiveTranslator::antiGeometric(const Point& b) const noexcept { return {.s = 0.0, .w = (b.x * wx + b.y * wy + b.z * wz), .x = (-wx - b.x * s), .y = (-wy - b.y * s), .z = (-wz - b.z * s), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.y * wx - b.x * wy), .wxz = (b.z * wx - b.x * wz), .wyz = (b.z * wy - b.y * wz), .xyz = 0.0, .i = 0.0}; }
    constexpr Multivector ProjectiveTranslator::antiGeometric(const PlaneIdeal& b) const noexcept { return {.s = 0.0, .w = 0.0, .x = (b.y * wz - b.z * wy), .y = (b.z * wx - b.x * wz), .z = (b.x * wy - b.y * wx), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = 0.0, .wxz = 0.0, .wyz = 0.0, .xyz = (b.x * wx + b.y * wy + b.z * wz), .i = 0.0}; }
    constexpr Quaternion ProjectiveTranslator::antiGeometric(const BivectorBulk& b) const noexcept { return {.s = (b.xy * wz + b.yz * wx - b.xz * wy), .xy = (b.xz * wx + b.yz * wy), .xz = (b.yz * wz - b.xy * wx), .yz = (-b.xy * wy - b.xz * wz)}; }
    constexpr Motor ProjectiveTranslator::antiGeometric(const BivectorWeight& b) const noexcept { return {.s = 0.0, .wx = (b.wy * wz - b.wz * wy), .wy = (b.wz * wx - b.wx * wz), .wz = (b.wx * wy - b.wy * wx), .xy = -b.wz * s, .xz = b.wy * s, .yz = -b.wx * s, .i = (-b.wx * wx - b.wy * wy - b.wz * wz)}; }
    constexpr ProjectiveTranslator ProjectiveTranslator::antiGeometric(const PseudoScalar& b) const noexcept { return {.s = b.i * s, .wx = b.i * wx, .wy = b.i * wy, .wz = b.i * wz}; }
    constexpr PlaneIdeal ProjectiveTranslator::antiGeometric(const PointCenter& b) const noexcept { return {.x = -wx, .y = -wy, .z = -wz}; }

    constexpr Motor Translator::antiGeometric(const Motor& b) const noexcept { return {.s = (b.i + b.xy * wz + b.yz * wx - b.xz * wy), .wx = (b.i * wx + b.wy * wz - b.wz * wy), .wy = (b.i * wy + b.wz * wx - b.wx * wz), .wz = (b.i * wz + b.wx * wy - b.wy * wx), .xy = (-b.wz + b.xz * wx + b.yz * wy - b.s * wz), .xz = (b.wy + b.s * wy + b.yz * wz - b.xy * wx), .yz = (-b.wx - b.s * wx - b.xy * wy - b.xz * wz), .i = (-b.wx * wx - b.wy * wy - b.wz * wz)}; }
    constexpr Multivector Translator::antiGeometric(const Plane& b) const noexcept { return {.s = 0.0, .w = 0.0, .x = (b.y * wz - b.z * wy), .y = (b.z * wx - b.x * wz), .z = (b.x * wy - b.y * wx), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = b.w * wz, .wxz = -b.w * wy, .wyz = b.w * wx, .xyz = (-b.w + b.x * wx + b.y * wy + b.z * wz), .i = 0.0}; }
    constexpr Motor Translator::antiGeometric(const Bivector& b) const noexcept { return {.s = (b.xy * wz + b.yz * wx - b.xz * wy), .wx = (b.wy * wz - b.wz * wy), .wy = (b.wz * wx - b.wx * wz), .wz = (b.wx * wy - b.wy * wx), .xy = (-b.wz + b.xz * wx + b.yz * wy), .xz = (b.wy + b.yz * wz - b.xy * wx), .yz = (-b.wx - b.xy * wy - b.xz * wz), .i = (-b.wx * wx - b.wy * wy - b.wz * wz)}; }
    constexpr Multivector Translator::antiGeometric(const ProjectivePoint& b) const noexcept { return {.s = 0.0, .w = (b.x * wx + b.y * wy + b.z * wz), .x = (-b.x - b.w * wx), .y = (-b.y - b.w * wy), .z = (-b.z - b.w * wz), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.y * wx - b.x * wy), .wxz = (b.z * wx - b.x * wz), .wyz = (b.z * wy - b.y * wz), .xyz = 0.0, .i = 0.0}; }
    constexpr Quaternion Translator::antiGeometric(const Quaternion& b) const noexcept { return {.s = (b.xy * wz + b.yz * wx - b.xz * wy), .xy = (b.xz * wx + b.yz * wy - b.s * wz), .xz = (b.s * wy + b.yz * wz - b.xy * wx), .yz = (-b.s * wx - b.xy * wy - b.xz * wz)}; }
    constexpr Motor Translator::antiGeometric(const ProjectiveTranslator& b) const noexcept { return {.s = 0.0, .wx = (b.wy * wz - b.wz * wy), .wy = (b.wz * wx - b.wx * wz), .wz = (b.wx * wy - b.wy * wx), .xy = (-b.wz - b.s * wz), .xz = (b.wy + b.s * wy), .yz = (-b.wx - b.s * wx), .i = (-b.wx * wx - b.wy * wy - b.wz * wz)}; }
    constexpr Motor Translator::antiGeometric(const Translator& b) const noexcept { return {.s = 0.0, .wx = (b.wy * wz - b.wz * wy), .wy = (b.wz * wx - b.wx * wz), .wz = (b.wx * wy - b.wy * wx), .xy = (-b.wz - wz), .xz = (b.wy + wy), .yz = (-b.wx - wx), .i = (-b.wx * wx - b.wy * wy - b.wz * wz)}; }
    constexpr Multivector Translator::antiGeometric(const Vector& b) const noexcept { return {.s = 0.0, .w = (b.x * wx + b.y * wy + b.z * wz), .x = -b.x, .y = -b.y, .z = -b.z, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.y * wx - b.x * wy), .wxz = (b.z * wx - b.x * wz), .wyz = (b.z * wy - b.y * wz), .xyz = 0.0, .i = 0.0}; }
    constexpr Multivector Translator::antiGeometric(const Point& b) const noexcept { return {.s = 0.0, .w = (b.x * wx + b.y * wy + b.z * wz), .x = (-b.x - wx), .y = (-b.y - wy), .z = (-b.z - wz), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.y * wx - b.x * wy), .wxz = (b.z * wx - b.x * wz), .wyz = (b.z * wy - b.y * wz), .xyz = 0.0, .i = 0.0}; }
    constexpr Multivector Translator::antiGeometric(const PlaneIdeal& b) const noexcept { return {.s = 0.0, .w = 0.0, .x = (b.y * wz - b.z * wy), .y = (b.z * wx - b.x * wz), .z = (b.x * wy - b.y * wx), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = 0.0, .wxz = 0.0, .wyz = 0.0, .xyz = (b.x * wx + b.y * wy + b.z * wz), .i = 0.0}; }
    constexpr Quaternion Translator::antiGeometric(const BivectorBulk& b) const noexcept { return {.s = (b.xy * wz + b.yz * wx - b.xz * wy), .xy = (b.xz * wx + b.yz * wy), .xz = (b.yz * wz - b.xy * wx), .yz = (-b.xy * wy - b.xz * wz)}; }
    constexpr Motor Translator::antiGeometric(const BivectorWeight& b) const noexcept { return {.s = 0.0, .wx = (b.wy * wz - b.wz * wy), .wy = (b.wz * wx - b.wx * wz), .wz = (b.wx * wy - b.wy * wx), .xy = -b.wz, .xz = b.wy, .yz = -b.wx, .i = (-b.wx * wx - b.wy * wy - b.wz * wz)}; }
    constexpr ProjectiveTranslator Translator::antiGeometric(const PseudoScalar& b) const noexcept { return {.s = b.i, .wx = b.i * wx, .wy = b.i * wy, .wz = b.i * wz}; }
    constexpr PlaneIdeal Translator::antiGeometric(const PointCenter& b) const noexcept { return {.x = -wx, .y = -wy, .z = -wz}; }

    constexpr Multivector Vector::antiGeometric(const Motor& b) const noexcept { return {.s = 0.0, .w = (b.wx * x + b.wy * y + b.wz * z), .x = (b.s * x + b.xy * y + b.xz * z), .y = (b.s * y + b.yz * z - b.xy * x), .z = (b.s * z - b.xz * x - b.yz * y), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.wy * x - b.i * z - b.wx * y), .wxz = (b.i * y + b.wz * x - b.wx * z), .wyz = (b.wz * y - b.i * x - b.wy * z), .xyz = (b.xz * y - b.xy * z - b.yz * x), .i = 0.0}; }
    constexpr Motor Vector::antiGeometric(const Plane& b) const noexcept { return {.s = (b.x * x + b.y * y + b.z * z), .wx = b.w * x, .wy = b.w * y, .wz = b.w * z, .xy = (b.x * y - b.y * x), .xz = (b.x * z - b.z * x), .yz = (b.y * z - b.z * y), .i = 0.0}; }
    constexpr Multivector Vector::antiGeometric(const Bivector& b) const noexcept { return {.s = 0.0, .w = (b.wx * x + b.wy * y + b.wz * z), .x = (b.xy * y + b.xz * z), .y = (b.yz * z - b.xy * x), .z = (-b.xz * x - b.yz * y), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.wy * x - b.wx * y), .wxz = (b.wz * x - b.wx * z), .wyz = (b.wz * y - b.wy * z), .xyz = (b.xz * y - b.xy * z - b.yz * x), .i = 0.0}; }
    constexpr Motor Vector::antiGeometric(const ProjectivePoint& b) const noexcept { return {.s = 0.0, .wx = (b.z * y - b.y * z), .wy = (b.x * z - b.z * x), .wz = (b.y * x - b.x * y), .xy = -b.w * z, .xz = b.w * y, .yz = -b.w * x, .i = (b.x * x + b.y * y + b.z * z)}; }
    constexpr Multivector Vector::antiGeometric(const Quaternion& b) const noexcept { return {.s = 0.0, .w = 0.0, .x = (b.s * x + b.xy * y + b.xz * z), .y = (b.s * y + b.yz * z - b.xy * x), .z = (b.s * z - b.xz * x - b.yz * y), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = 0.0, .wxz = 0.0, .wyz = 0.0, .xyz = (b.xz * y - b.xy * z - b.yz * x), .i = 0.0}; }
    constexpr Multivector Vector::antiGeometric(const ProjectiveTranslator& b) const noexcept { return {.s = 0.0, .w = (b.wx * x + b.wy * y + b.wz * z), .x = b.s * x, .y = b.s * y, .z = b.s * z, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.wy * x - b.wx * y), .wxz = (b.wz * x - b.wx * z), .wyz = (b.wz * y - b.wy * z), .xyz = 0.0, .i = 0.0}; }
    constexpr Multivector Vector::antiGeometric(const Translator& b) const noexcept { return {.s = 0.0, .w = (b.wx * x + b.wy * y + b.wz * z), .x = x, .y = y, .z = z, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.wy * x - b.wx * y), .wxz = (b.wz * x - b.wx * z), .wyz = (b.wz * y - b.wy * z), .xyz = 0.0, .i = 0.0}; }
    constexpr Motor Vector::antiGeometric(const Vector& b) const noexcept { return {.s = 0.0, .wx = (b.z * y - b.y * z), .wy = (b.x * z - b.z * x), .wz = (b.y * x - b.x * y), .xy = 0.0, .xz = 0.0, .yz = 0.0, .i = (b.x * x + b.y * y + b.z * z)}; }
    constexpr Motor Vector::antiGeometric(const Point& b) const noexcept { return {.s = 0.0, .wx = (b.z * y - b.y * z), .wy = (b.x * z - b.z * x), .wz = (b.y * x - b.x * y), .xy = -z, .xz = y, .yz = -x, .i = (b.x * x + b.y * y + b.z * z)}; }
    constexpr Quaternion Vector::antiGeometric(const PlaneIdeal& b) const noexcept { return {.s = (b.x * x + b.y * y + b.z * z), .xy = (b.x * y - b.y * x), .xz = (b.x * z - b.z * x), .yz = (b.y * z - b.z * y)}; }
    constexpr Multivector Vector::antiGeometric(const BivectorBulk& b) const noexcept { return {.s = 0.0, .w = 0.0, .x = (b.xy * y + b.xz * z), .y = (b.yz * z - b.xy * x), .z = (-b.xz * x - b.yz * y), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = 0.0, .wxz = 0.0, .wyz = 0.0, .xyz = (b.xz * y - b.xy * z - b.yz * x), .i = 0.0}; }
    constexpr Multivector Vector::antiGeometric(const BivectorWeight& b) const noexcept { return {.s = 0.0, .w = (b.wx * x + b.wy * y + b.wz * z), .x = 0.0, .y = 0.0, .z = 0.0, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.wy * x - b.wx * y), .wxz = (b.wz * x - b.wx * z), .wyz = (b.wz * y - b.wy * z), .xyz = 0.0, .i = 0.0}; }
    constexpr Vector Vector::antiGeometric(const PseudoScalar& b) const noexcept { return {.x = b.i * x, .y = b.i * y, .z = b.i * z}; }
    constexpr BivectorBulk Vector::antiGeometric(const PointCenter& b) const noexcept { return {.xy = -z, .xz = y, .yz = -x}; }

    constexpr Multivector Point::antiGeometric(const Motor& b) const noexcept { return {.s = 0.0, .w = (b.wx * x + b.wy * y + b.wz * z), .x = (-b.wx + b.s * x + b.xy * y + b.xz * z), .y = (-b.wy + b.s * y + b.yz * z - b.xy * x), .z = (-b.wz + b.s * z - b.xz * x - b.yz * y), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.wy * x - b.i * z - b.wx * y), .wxz = (b.i * y + b.wz * x - b.wx * z), .wyz = (b.wz * y - b.i * x - b.wy * z), .xyz = (b.i + b.xz * y - b.xy * z - b.yz * x), .i = 0.0}; }
    constexpr Motor Point::antiGeometric(const Plane& b) const noexcept { return {.s = (b.w + b.x * x + b.y * y + b.z * z), .wx = b.w * x, .wy = b.w * y, .wz = b.w * z, .xy = (b.x * y - b.y * x), .xz = (b.x * z - b.z * x), .yz = (b.y * z - b.z * y), .i = 0.0}; }
    constexpr Multivector Point::antiGeometric(const Bivector& b) const noexcept { return {.s = 0.0, .w = (b.wx * x + b.wy * y + b.wz * z), .x = (-b.wx + b.xy * y + b.xz * z), .y = (-b.wy + b.yz * z - b.xy * x), .z = (-b.wz - b.xz * x - b.yz * y), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.wy * x - b.wx * y), .wxz = (b.wz * x - b.wx * z), .wyz = (b.wz * y - b.wy * z), .xyz = (b.xz * y - b.xy * z - b.yz * x), .i = 0.0}; }
    constexpr Motor Point::antiGeometric(const ProjectivePoint& b) const noexcept { return {.s = 0.0, .wx = (b.z * y - b.y * z), .wy = (b.x * z - b.z * x), .wz = (b.y * x - b.x * y), .xy = (b.z - b.w * z), .xz = (-b.y + b.w * y), .yz = (b.x - b.w * x), .i = (b.x * x + b.y * y + b.z * z)}; }
    constexpr Multivector Point::antiGeometric(const Quaternion& b) const noexcept { return {.s = 0.0, .w = 0.0, .x = (b.s * x + b.xy * y + b.xz * z), .y = (b.s * y + b.yz * z - b.xy * x), .z = (b.s * z - b.xz * x - b.yz * y), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = 0.0, .wxz = 0.0, .wyz = 0.0, .xyz = (b.xz * y - b.xy * z - b.yz * x), .i = 0.0}; }
    constexpr Multivector Point::antiGeometric(const ProjectiveTranslator& b) const noexcept { return {.s = 0.0, .w = (b.wx * x + b.wy * y + b.wz * z), .x = (-b.wx + b.s * x), .y = (-b.wy + b.s * y), .z = (-b.wz + b.s * z), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.wy * x - b.wx * y), .wxz = (b.wz * x - b.wx * z), .wyz = (b.wz * y - b.wy * z), .xyz = 0.0, .i = 0.0}; }
    constexpr Multivector Point::antiGeometric(const Translator& b) const noexcept { return {.s = 0.0, .w = (b.wx * x + b.wy * y + b.wz * z), .x = (x - b.wx), .y = (y - b.wy), .z = (z - b.wz), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.wy * x - b.wx * y), .wxz = (b.wz * x - b.wx * z), .wyz = (b.wz * y - b.wy * z), .xyz = 0.0, .i = 0.0}; }
    constexpr Motor Point::antiGeometric(const Vector& b) const noexcept { return {.s = 0.0, .wx = (b.z * y - b.y * z), .wy = (b.x * z - b.z * x), .wz = (b.y * x - b.x * y), .xy = b.z, .xz = -b.y, .yz = b.x, .i = (b.x * x + b.y * y + b.z * z)}; }
    constexpr Motor Point::antiGeometric(const Point& b) const noexcept { return {.s = 0.0, .wx = (b.z * y - b.y * z), .wy = (b.x * z - b.z * x), .wz = (b.y * x - b.x * y), .xy = (b.z - z), .xz = (y - b.y), .yz = (b.x - x), .i = (b.x * x + b.y * y + b.z * z)}; }
    constexpr Quaternion Point::antiGeometric(const PlaneIdeal& b) const noexcept { return {.s = (b.x * x + b.y * y + b.z * z), .xy = (b.x * y - b.y * x), .xz = (b.x * z - b.z * x), .yz = (b.y * z - b.z * y)}; }
    constexpr Multivector Point::antiGeometric(const BivectorBulk& b) const noexcept { return {.s = 0.0, .w = 0.0, .x = (b.xy * y + b.xz * z), .y = (b.yz * z - b.xy * x), .z = (-b.xz * x - b.yz * y), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = 0.0, .wxz = 0.0, .wyz = 0.0, .xyz = (b.xz * y - b.xy * z - b.yz * x), .i = 0.0}; }
    constexpr Multivector Point::antiGeometric(const BivectorWeight& b) const noexcept { return {.s = 0.0, .w = (b.wx * x + b.wy * y + b.wz * z), .x = -b.wx, .y = -b.wy, .z = -b.wz, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.wy * x - b.wx * y), .wxz = (b.wz * x - b.wx * z), .wyz = (b.wz * y - b.wy * z), .xyz = 0.0, .i = 0.0}; }
    constexpr ProjectivePoint Point::antiGeometric(const PseudoScalar& b) const noexcept { return {.x = b.i * x, .y = b.i * y, .z = b.i * z, .w = b.i}; }
    constexpr BivectorBulk Point::antiGeometric(const PointCenter& b) const noexcept { return {.xy = -z, .xz = y, .yz = -x}; }

    constexpr Multivector PlaneIdeal::antiGeometric(const Motor& b) const noexcept { return {.s = 0.0, .w = 0.0, .x = (b.i * x + b.wy * z - b.wz * y), .y = (b.i * y + b.wz * x - b.wx * z), .z = (b.i * z + b.wx * y - b.wy * x), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = 0.0, .wxz = 0.0, .wyz = 0.0, .xyz = (b.wx * x + b.wy * y + b.wz * z), .i = 0.0}; }
    constexpr BivectorBulk PlaneIdeal::antiGeometric(const Plane& b) const noexcept { return {.xy = b.w * z, .xz = -b.w * y, .yz = b.w * x}; }
    constexpr Multivector PlaneIdeal::antiGeometric(const Bivector& b) const noexcept { return {.s = 0.0, .w = 0.0, .x = (b.wy * z - b.wz * y), .y = (b.wz * x - b.wx * z), .z = (b.wx * y - b.wy * x), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = 0.0, .wxz = 0.0, .wyz = 0.0, .xyz = (b.wx * x + b.wy * y + b.wz * z), .i = 0.0}; }
    constexpr Quaternion PlaneIdeal::antiGeometric(const ProjectivePoint& b) const noexcept { return {.s = (-b.x * x - b.y * y - b.z * z), .xy = (b.y * x - b.x * y), .xz = (b.z * x - b.x * z), .yz = (b.z * y - b.y * z)}; }
    constexpr Multivector PlaneIdeal::antiGeometric(const ProjectiveTranslator& b) const noexcept { return {.s = 0.0, .w = 0.0, .x = (b.wy * z - b.wz * y), .y = (b.wz * x - b.wx * z), .z = (b.wx * y - b.wy * x), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = 0.0, .wxz = 0.0, .wyz = 0.0, .xyz = (b.wx * x + b.wy * y + b.wz * z), .i = 0.0}; }
    constexpr Multivector PlaneIdeal::antiGeometric(const Translator& b) const noexcept { return {.s = 0.0, .w = 0.0, .x = (b.wy * z - b.wz * y), .y = (b.wz * x - b.wx * z), .z = (b.wx * y - b.wy * x), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = 0.0, .wxz = 0.0, .wyz = 0.0, .xyz = (b.wx * x + b.wy * y + b.wz * z), .i = 0.0}; }
    constexpr Quaternion PlaneIdeal::antiGeometric(const Vector& b) const noexcept { return {.s = (-b.x * x - b.y * y - b.z * z), .xy = (b.y * x - b.x * y), .xz = (b.z * x - b.x * z), .yz = (b.z * y - b.y * z)}; }
    constexpr Quaternion PlaneIdeal::antiGeometric(const Point& b) const noexcept { return {.s = (-b.x * x - b.y * y - b.z * z), .xy = (b.y * x - b.x * y), .xz = (b.z * x - b.x * z), .yz = (b.z * y - b.y * z)}; }
    constexpr Multivector PlaneIdeal::antiGeometric(const BivectorWeight& b) const noexcept { return {.s = 0.0, .w = 0.0, .x = (b.wy * z - b.wz * y), .y = (b.wz * x - b.wx * z), .z = (b.wx * y - b.wy * x), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = 0.0, .wxz = 0.0, .wyz = 0.0, .xyz = (b.wx * x + b.wy * y + b.wz * z), .i = 0.0}; }
    constexpr PlaneIdeal PlaneIdeal::antiGeometric(const PseudoScalar& b) const noexcept { return {.x = b.i * x, .y = b.i * y, .z = b.i * z}; }

    constexpr Quaternion BivectorBulk::antiGeometric(const Motor& b) const noexcept { return {.s = (b.wx * yz + b.wz * xy - b.wy * xz), .xy = (b.i * xy - b.wx * xz - b.wy * yz), .xz = (b.i * xz + b.wx * xy - b.wz * yz), .yz = (b.i * yz + b.wy * xy + b.wz * xz)}; }
    constexpr PlaneIdeal BivectorBulk::antiGeometric(const Plane& b) const noexcept { return {.x = -b.w * yz, .y = b.w * xz, .z = -b.w * xy}; }
    constexpr Quaternion BivectorBulk::antiGeometric(const Bivector& b) const noexcept { return {.s = (b.wx * yz + b.wz * xy - b.wy * xz), .xy = (-b.wx * xz - b.wy * yz), .xz = (b.wx * xy - b.wz * yz), .yz = (b.wy * xy + b.wz * xz)}; }
    constexpr Multivector BivectorBulk::antiGeometric(const ProjectivePoint& b) const noexcept { return {.s = 0.0, .w = 0.0, .x = (b.y * xy + b.z * xz), .y = (b.z * yz - b.x * xy), .z = (-b.x * xz - b.y * yz), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = 0.0, .wxz = 0.0, .wyz = 0.0, .xyz = (b.x * yz + b.z * xy - b.y * xz), .i = 0.0}; }
    constexpr Quaternion BivectorBulk::antiGeometric(const ProjectiveTranslator& b) const noexcept { return {.s = (b.wx * yz + b.wz * xy - b.wy * xz), .xy = (-b.wx * xz - b.wy * yz), .xz = (b.wx * xy - b.wz * yz), .yz = (b.wy * xy + b.wz * xz)}; }
    constexpr Quaternion BivectorBulk::antiGeometric(const Translator& b) const noexcept { return {.s = (b.wx * yz + b.wz * xy - b.wy * xz), .xy = (-b.wx * xz - b.wy * yz), .xz = (b.wx * xy - b.wz * yz), .yz = (b.wy * xy + b.wz * xz)}; }
    constexpr Multivector BivectorBulk::antiGeometric(const Vector& b) const noexcept { return {.s = 0.0, .w = 0.0, .x = (b.y * xy + b.z * xz), .y = (b.z * yz - b.x * xy), .z = (-b.x * xz - b.y * yz), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = 0.0, .wxz = 0.0, .wyz = 0.0, .xyz = (b.x * yz + b.z * xy - b.y * xz), .i = 0.0}; }
    constexpr Multivector BivectorBulk::antiGeometric(const Point& b) const noexcept { return {.s = 0.0, .w = 0.0, .x = (b.y * xy + b.z * xz), .y = (b.z * yz - b.x * xy), .z = (-b.x * xz - b.y * yz), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = 0.0, .wxz = 0.0, .wyz = 0.0, .xyz = (b.x * yz + b.z * xy - b.y * xz), .i = 0.0}; }
    constexpr Quaternion BivectorBulk::antiGeometric(const BivectorWeight& b) const noexcept { return {.s = (b.wx * yz + b.wz * xy - b.wy * xz), .xy = (-b.wx * xz - b.wy * yz), .xz = (b.wx * xy - b.wz * yz), .yz = (b.wy * xy + b.wz * xz)}; }
    constexpr BivectorBulk BivectorBulk::antiGeometric(const PseudoScalar& b) const noexcept { return {.xy = b.i * xy, .xz = b.i * xz, .yz = b.i * yz}; }

    constexpr Motor BivectorWeight::antiGeometric(const Motor& b) const noexcept { return {.s = (b.xy * wz + b.yz * wx - b.xz * wy), .wx = (b.i * wx + b.wy * wz - b.wz * wy), .wy = (b.i * wy + b.wz * wx - b.wx * wz), .wz = (b.i * wz + b.wx * wy - b.wy * wx), .xy = (b.xz * wx + b.yz * wy - b.s * wz), .xz = (b.s * wy + b.yz * wz - b.xy * wx), .yz = (-b.s * wx - b.xy * wy - b.xz * wz), .i = (-b.wx * wx - b.wy * wy - b.wz * wz)}; }
    constexpr Multivector BivectorWeight::antiGeometric(const Plane& b) const noexcept { return {.s = 0.0, .w = 0.0, .x = (b.y * wz - b.z * wy), .y = (b.z * wx - b.x * wz), .z = (b.x * wy - b.y * wx), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = b.w * wz, .wxz = -b.w * wy, .wyz = b.w * wx, .xyz = (b.x * wx + b.y * wy + b.z * wz), .i = 0.0}; }
    constexpr Motor BivectorWeight::antiGeometric(const Bivector& b) const noexcept { return {.s = (b.xy * wz + b.yz * wx - b.xz * wy), .wx = (b.wy * wz - b.wz * wy), .wy = (b.wz * wx - b.wx * wz), .wz = (b.wx * wy - b.wy * wx), .xy = (b.xz * wx + b.yz * wy), .xz = (b.yz * wz - b.xy * wx), .yz = (-b.xy * wy - b.xz * wz), .i = (-b.wx * wx - b.wy * wy - b.wz * wz)}; }
    constexpr Multivector BivectorWeight::antiGeometric(const ProjectivePoint& b) const noexcept { return {.s = 0.0, .w = (b.x * wx + b.y * wy + b.z * wz), .x = -b.w * wx, .y = -b.w * wy, .z = -b.w * wz, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.y * wx - b.x * wy), .wxz = (b.z * wx - b.x * wz), .wyz = (b.z * wy - b.y * wz), .xyz = 0.0, .i = 0.0}; }
    constexpr Quaternion BivectorWeight::antiGeometric(const Quaternion& b) const noexcept { return {.s = (b.xy * wz + b.yz * wx - b.xz * wy), .xy = (b.xz * wx + b.yz * wy - b.s * wz), .xz = (b.s * wy + b.yz * wz - b.xy * wx), .yz = (-b.s * wx - b.xy * wy - b.xz * wz)}; }
    constexpr Motor BivectorWeight::antiGeometric(const ProjectiveTranslator& b) const noexcept { return {.s = 0.0, .wx = (b.wy * wz - b.wz * wy), .wy = (b.wz * wx - b.wx * wz), .wz = (b.wx * wy - b.wy * wx), .xy = -b.s * wz, .xz = b.s * wy, .yz = -b.s * wx, .i = (-b.wx * wx - b.wy * wy - b.wz * wz)}; }
    constexpr Motor BivectorWeight::antiGeometric(const Translator& b) const noexcept { return {.s = 0.0, .wx = (b.wy * wz - b.wz * wy), .wy = (b.wz * wx - b.wx * wz), .wz = (b.wx * wy - b.wy * wx), .xy = -wz, .xz = wy, .yz = -wx, .i = (-b.wx * wx - b.wy * wy - b.wz * wz)}; }
    constexpr Multivector BivectorWeight::antiGeometric(const Vector& b) const noexcept { return {.s = 0.0, .w = (b.x * wx + b.y * wy + b.z * wz), .x = 0.0, .y = 0.0, .z = 0.0, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.y * wx - b.x * wy), .wxz = (b.z * wx - b.x * wz), .wyz = (b.z * wy - b.y * wz), .xyz = 0.0, .i = 0.0}; }
    constexpr Multivector BivectorWeight::antiGeometric(const Point& b) const noexcept { return {.s = 0.0, .w = (b.x * wx + b.y * wy + b.z * wz), .x = -wx, .y = -wy, .z = -wz, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.y * wx - b.x * wy), .wxz = (b.z * wx - b.x * wz), .wyz = (b.z * wy - b.y * wz), .xyz = 0.0, .i = 0.0}; }
    constexpr Multivector BivectorWeight::antiGeometric(const PlaneIdeal& b) const noexcept { return {.s = 0.0, .w = 0.0, .x = (b.y * wz - b.z * wy), .y = (b.z * wx - b.x * wz), .z = (b.x * wy - b.y * wx), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = 0.0, .wxz = 0.0, .wyz = 0.0, .xyz = (b.x * wx + b.y * wy + b.z * wz), .i = 0.0}; }
    constexpr Quaternion BivectorWeight::antiGeometric(const BivectorBulk& b) const noexcept { return {.s = (b.xy * wz + b.yz * wx - b.xz * wy), .xy = (b.xz * wx + b.yz * wy), .xz = (b.yz * wz - b.xy * wx), .yz = (-b.xy * wy - b.xz * wz)}; }
    constexpr Motor BivectorWeight::antiGeometric(const BivectorWeight& b) const noexcept { return {.s = 0.0, .wx = (b.wy * wz - b.wz * wy), .wy = (b.wz * wx - b.wx * wz), .wz = (b.wx * wy - b.wy * wx), .xy = 0.0, .xz = 0.0, .yz = 0.0, .i = (-b.wx * wx - b.wy * wy - b.wz * wz)}; }
    constexpr BivectorWeight BivectorWeight::antiGeometric(const PseudoScalar& b) const noexcept { return {.wx = b.i * wx, .wy = b.i * wy, .wz = b.i * wz}; }
    constexpr PlaneIdeal BivectorWeight::antiGeometric(const PointCenter& b) const noexcept { return {.x = -wx, .y = -wy, .z = -wz}; }

    constexpr Motor PseudoScalar::antiGeometric(const Motor& b) const noexcept { return {.s = b.s * i, .wx = b.wx * i, .wy = b.wy * i, .wz = b.wz * i, .xy = b.xy * i, .xz = b.xz * i, .yz = b.yz * i, .i = b.i * i}; }
    constexpr Plane PseudoScalar::antiGeometric(const Plane& b) const noexcept { return {.x = b.x * i, .y = b.y * i, .z = b.z * i, .w = b.w * i}; }
    constexpr Bivector PseudoScalar::antiGeometric(const Bivector& b) const noexcept { return {.wx = b.wx * i, .wy = b.wy * i, .wz = b.wz * i, .xy = b.xy * i, .xz = b.xz * i, .yz = b.yz * i}; }
    constexpr ProjectivePoint PseudoScalar::antiGeometric(const ProjectivePoint& b) const noexcept { return {.x = b.x * i, .y = b.y * i, .z = b.z * i, .w = b.w * i}; }
    constexpr Quaternion PseudoScalar::antiGeometric(const Quaternion& b) const noexcept { return {.s = b.s * i, .xy = b.xy * i, .xz = b.xz * i, .yz = b.yz * i}; }
    constexpr ProjectiveTranslator PseudoScalar::antiGeometric(const ProjectiveTranslator& b) const noexcept { return {.s = b.s * i, .wx = b.wx * i, .wy = b.wy * i, .wz = b.wz * i}; }
    constexpr ProjectiveTranslator PseudoScalar::antiGeometric(const Translator& b) const noexcept { return {.s = i, .wx = b.wx * i, .wy = b.wy * i, .wz = b.wz * i}; }
    constexpr Vector PseudoScalar::antiGeometric(const Vector& b) const noexcept { return {.x = b.x * i, .y = b.y * i, .z = b.z * i}; }
    constexpr ProjectivePoint PseudoScalar::antiGeometric(const Point& b) const noexcept { return {.x = b.x * i, .y = b.y * i, .z = b.z * i, .w = i}; }
    constexpr PlaneIdeal PseudoScalar::antiGeometric(const PlaneIdeal& b) const noexcept { return {.x = b.x * i, .y = b.y * i, .z = b.z * i}; }
    constexpr BivectorBulk PseudoScalar::antiGeometric(const BivectorBulk& b) const noexcept { return {.xy = b.xy * i, .xz = b.xz * i, .yz = b.yz * i}; }
    constexpr BivectorWeight PseudoScalar::antiGeometric(const BivectorWeight& b) const noexcept { return {.wx = b.wx * i, .wy = b.wy * i, .wz = b.wz * i}; }
    constexpr PseudoScalar PseudoScalar::antiGeometric(const PseudoScalar& b) const noexcept { return {.i = b.i * i}; }
    constexpr ProjectivePoint PseudoScalar::antiGeometric(const PointCenter& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = i}; }

    constexpr Multivector PointCenter::antiGeometric(const Motor& b) const noexcept { return {.s = 0.0, .w = 0.0, .x = -b.wx, .y = -b.wy, .z = -b.wz, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = 0.0, .wxz = 0.0, .wyz = 0.0, .xyz = b.i, .i = 0.0}; }
    constexpr double PointCenter::antiGeometric(const Plane& b) const noexcept { return b.w; }
    constexpr PlaneIdeal PointCenter::antiGeometric(const Bivector& b) const noexcept { return {.x = -b.wx, .y = -b.wy, .z = -b.wz}; }
    constexpr BivectorBulk PointCenter::antiGeometric(const ProjectivePoint& b) const noexcept { return {.xy = b.z, .xz = -b.y, .yz = b.x}; }
    constexpr PlaneIdeal PointCenter::antiGeometric(const ProjectiveTranslator& b) const noexcept { return {.x = -b.wx, .y = -b.wy, .z = -b.wz}; }
    constexpr PlaneIdeal PointCenter::antiGeometric(const Translator& b) const noexcept { return {.x = -b.wx, .y = -b.wy, .z = -b.wz}; }
    constexpr BivectorBulk PointCenter::antiGeometric(const Vector& b) const noexcept { return {.xy = b.z, .xz = -b.y, .yz = b.x}; }
    constexpr BivectorBulk PointCenter::antiGeometric(const Point& b) const noexcept { return {.xy = b.z, .xz = -b.y, .yz = b.x}; }
    constexpr PlaneIdeal PointCenter::antiGeometric(const BivectorWeight& b) const noexcept { return {.x = -b.wx, .y = -b.wy, .z = -b.wz}; }
    constexpr ProjectivePoint PointCenter::antiGeometric(const PseudoScalar& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = b.i}; }

}

// opsAntiDot.h

// generated by com.github.kright.pga3d.codegen.cpp.ops.AntiDotOpGenerator

namespace pga3d {
    constexpr Multivector Multivector::antiDot(const Multivector& b) const noexcept { return {.s = (b.i * s + b.s * i), .w = (b.i * w + b.w * i), .x = (b.i * x + b.wyz * s + b.x * i - b.s * wyz), .y = (b.i * y + b.s * wxz + b.y * i - b.wxz * s), .z = (b.i * z + b.wxy * s + b.z * i - b.s * wxy), .wx = (b.i * wx + b.wx * i - b.w * wyz - b.wyz * w), .wy = (b.i * wy + b.w * wxz + b.wxz * w + b.wy * i), .wz = (b.i * wz + b.wz * i - b.w * wxy - b.wxy * w), .xy = (b.i * xy + b.wxz * x + b.wyz * y + b.x * wxz + b.xy * i + b.y * wyz - b.s * wz - b.wz * s), .xz = (b.i * xz + b.s * wy + b.wy * s + b.wyz * z + b.xz * i + b.z * wyz - b.wxy * x - b.x * wxy), .yz = (b.i * yz + b.yz * i - b.s * wx - b.wx * s - b.wxy * y - b.wxz * z - b.y * wxy - b.z * wxz), .wxy = (b.i * wxy + b.w * wz + b.wxy * i + b.wxz * wx + b.wyz * wy + b.wz * w - b.wx * wxz - b.wy * wyz), .wxz = (b.i * wxz + b.wx * wxy + b.wxz * i + b.wyz * wz - b.w * wy - b.wxy * wx - b.wy * w - b.wz * wyz), .wyz = (b.i * wyz + b.w * wx + b.wx * w + b.wy * wxy + b.wyz * i + b.wz * wxz - b.wxy * wy - b.wxz * wz), .xyz = (b.i * xyz + b.s * w + b.wx * x + b.wy * y + b.wz * z + b.x * wx + b.xy * wxy + b.xyz * i + b.xz * wxz + b.y * wy + b.yz * wyz + b.z * wz - b.w * s - b.wxy * xy - b.wxz * xz - b.wyz * yz), .i = (b.i * i + b.wxy * wxy + b.wxz * wxz + b.wyz * wyz - b.w * w - b.wx * wx - b.wy * wy - b.wz * wz)}; }

    constexpr Motor Motor::antiDot(const Motor& b) const noexcept { return {.s = (b.i * s + b.s * i), .wx = (b.i * wx + b.wx * i), .wy = (b.i * wy + b.wy * i), .wz = (b.i * wz + b.wz * i), .xy = (b.i * xy + b.xy * i - b.s * wz - b.wz * s), .xz = (b.i * xz + b.s * wy + b.wy * s + b.xz * i), .yz = (b.i * yz + b.yz * i - b.s * wx - b.wx * s), .i = (b.i * i - b.wx * wx - b.wy * wy - b.wz * wz)}; }
    constexpr Multivector Motor::antiDot(const Plane& b) const noexcept { return {.s = 0.0, .w = b.w * i, .x = b.x * i, .y = b.y * i, .z = b.z * i, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = b.w * wz, .wxz = -b.w * wy, .wyz = b.w * wx, .xyz = (b.x * wx + b.y * wy + b.z * wz - b.w * s), .i = 0.0}; }
    constexpr Motor Motor::antiDot(const Bivector& b) const noexcept { return {.s = 0.0, .wx = b.wx * i, .wy = b.wy * i, .wz = b.wz * i, .xy = (b.xy * i - b.wz * s), .xz = (b.wy * s + b.xz * i), .yz = (b.yz * i - b.wx * s), .i = (-b.wx * wx - b.wy * wy - b.wz * wz)}; }
    constexpr Multivector Motor::antiDot(const ProjectivePoint& b) const noexcept { return {.s = 0.0, .w = 0.0, .x = -b.x * s, .y = -b.y * s, .z = -b.z * s, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.y * wx - b.x * wy - b.z * i), .wxz = (b.y * i + b.z * wx - b.x * wz), .wyz = (b.z * wy - b.x * i - b.y * wz), .xyz = (b.w * i + b.x * yz + b.z * xy - b.y * xz), .i = 0.0}; }
    constexpr Quaternion Motor::antiDot(const Quaternion& b) const noexcept { return {.s = b.s * i, .xy = (b.xy * i - b.s * wz), .xz = (b.s * wy + b.xz * i), .yz = (b.yz * i - b.s * wx)}; }
    constexpr Motor Motor::antiDot(const ProjectiveTranslator& b) const noexcept { return {.s = b.s * i, .wx = b.wx * i, .wy = b.wy * i, .wz = b.wz * i, .xy = (-b.s * wz - b.wz * s), .xz = (b.s * wy + b.wy * s), .yz = (-b.s * wx - b.wx * s), .i = (-b.wx * wx - b.wy * wy - b.wz * wz)}; }
    constexpr Motor Motor::antiDot(const Translator& b) const noexcept { return {.s = i, .wx = b.wx * i, .wy = b.wy * i, .wz = b.wz * i, .xy = (-wz - b.wz * s), .xz = (wy + b.wy * s), .yz = (-wx - b.wx * s), .i = (-b.wx * wx - b.wy * wy - b.wz * wz)}; }
    constexpr Multivector Motor::antiDot(const Vector& b) const noexcept { return {.s = 0.0, .w = 0.0, .x = -b.x * s, .y = -b.y * s, .z = -b.z * s, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.y * wx - b.x * wy - b.z * i), .wxz = (b.y * i + b.z * wx - b.x * wz), .wyz = (b.z * wy - b.x * i - b.y * wz), .xyz = (b.x * yz + b.z * xy - b.y * xz), .i = 0.0}; }
    constexpr Multivector Motor::antiDot(const Point& b) const noexcept { return {.s = 0.0, .w = 0.0, .x = -b.x * s, .y = -b.y * s, .z = -b.z * s, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.y * wx - b.x * wy - b.z * i), .wxz = (b.y * i + b.z * wx - b.x * wz), .wyz = (b.z * wy - b.x * i - b.y * wz), .xyz = (i + b.x * yz + b.z * xy - b.y * xz), .i = 0.0}; }
    constexpr Multivector Motor::antiDot(const PlaneIdeal& b) const noexcept { return {.s = 0.0, .w = 0.0, .x = b.x * i, .y = b.y * i, .z = b.z * i, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = 0.0, .wxz = 0.0, .wyz = 0.0, .xyz = (b.x * wx + b.y * wy + b.z * wz), .i = 0.0}; }
    constexpr BivectorBulk Motor::antiDot(const BivectorBulk& b) const noexcept { return {.xy = b.xy * i, .xz = b.xz * i, .yz = b.yz * i}; }
    constexpr Motor Motor::antiDot(const BivectorWeight& b) const noexcept { return {.s = 0.0, .wx = b.wx * i, .wy = b.wy * i, .wz = b.wz * i, .xy = -b.wz * s, .xz = b.wy * s, .yz = -b.wx * s, .i = (-b.wx * wx - b.wy * wy - b.wz * wz)}; }
    constexpr Motor Motor::antiDot(const PseudoScalar& b) const noexcept { return {.s = b.i * s, .wx = b.i * wx, .wy = b.i * wy, .wz = b.i * wz, .xy = b.i * xy, .xz = b.i * xz, .yz = b.i * yz, .i = b.i * i}; }
    constexpr ProjectivePoint Motor::antiDot(const PointCenter& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = i}; }

    constexpr Multivector Plane::antiDot(const Motor& b) const noexcept { return {.s = 0.0, .w = b.i * w, .x = b.i * x, .y = b.i * y, .z = b.i * z, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = b.wz * w, .wxz = -b.wy * w, .wyz = b.wx * w, .xyz = (b.s * w + b.wx * x + b.wy * y + b.wz * z), .i = 0.0}; }
    constexpr PseudoScalar Plane::antiDot(const Plane& b) const noexcept { return {.i = -b.w * w}; }
    constexpr ProjectivePoint Plane::antiDot(const Bivector& b) const noexcept { return {.x = -b.wx * w, .y = -b.wy * w, .z = -b.wz * w, .w = (b.wx * x + b.wy * y + b.wz * z)}; }
    constexpr Bivector Plane::antiDot(const ProjectivePoint& b) const noexcept { return {.wx = b.x * w, .wy = b.y * w, .wz = b.z * w, .xy = (b.y * x - b.x * y), .xz = (b.z * x - b.x * z), .yz = (b.z * y - b.y * z)}; }
    constexpr ProjectivePoint Plane::antiDot(const Quaternion& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = b.s * w}; }
    constexpr ProjectivePoint Plane::antiDot(const ProjectiveTranslator& b) const noexcept { return {.x = -b.wx * w, .y = -b.wy * w, .z = -b.wz * w, .w = (b.s * w + b.wx * x + b.wy * y + b.wz * z)}; }
    constexpr ProjectivePoint Plane::antiDot(const Translator& b) const noexcept { return {.x = -b.wx * w, .y = -b.wy * w, .z = -b.wz * w, .w = (w + b.wx * x + b.wy * y + b.wz * z)}; }
    constexpr Bivector Plane::antiDot(const Vector& b) const noexcept { return {.wx = b.x * w, .wy = b.y * w, .wz = b.z * w, .xy = (b.y * x - b.x * y), .xz = (b.z * x - b.x * z), .yz = (b.z * y - b.y * z)}; }
    constexpr Bivector Plane::antiDot(const Point& b) const noexcept { return {.wx = b.x * w, .wy = b.y * w, .wz = b.z * w, .xy = (b.y * x - b.x * y), .xz = (b.z * x - b.x * z), .yz = (b.z * y - b.y * z)}; }
    constexpr ProjectivePoint Plane::antiDot(const BivectorWeight& b) const noexcept { return {.x = -b.wx * w, .y = -b.wy * w, .z = -b.wz * w, .w = (b.wx * x + b.wy * y + b.wz * z)}; }
    constexpr Plane Plane::antiDot(const PseudoScalar& b) const noexcept { return {.x = b.i * x, .y = b.i * y, .z = b.i * z, .w = b.i * w}; }

    constexpr Motor Bivector::antiDot(const Motor& b) const noexcept { return {.s = 0.0, .wx = b.i * wx, .wy = b.i * wy, .wz = b.i * wz, .xy = (b.i * xy - b.s * wz), .xz = (b.i * xz + b.s * wy), .yz = (b.i * yz - b.s * wx), .i = (-b.wx * wx - b.wy * wy - b.wz * wz)}; }
    constexpr ProjectivePoint Bivector::antiDot(const Plane& b) const noexcept { return {.x = -b.w * wx, .y = -b.w * wy, .z = -b.w * wz, .w = (b.x * wx + b.y * wy + b.z * wz)}; }
    constexpr PseudoScalar Bivector::antiDot(const Bivector& b) const noexcept { return {.i = (-b.wx * wx - b.wy * wy - b.wz * wz)}; }
    constexpr ProjectivePoint Bivector::antiDot(const ProjectivePoint& b) const noexcept { return {.x = (b.y * wz - b.z * wy), .y = (b.z * wx - b.x * wz), .z = (b.x * wy - b.y * wx), .w = (b.x * yz + b.z * xy - b.y * xz)}; }
    constexpr BivectorBulk Bivector::antiDot(const Quaternion& b) const noexcept { return {.xy = -b.s * wz, .xz = b.s * wy, .yz = -b.s * wx}; }
    constexpr Motor Bivector::antiDot(const ProjectiveTranslator& b) const noexcept { return {.s = 0.0, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = -b.s * wz, .xz = b.s * wy, .yz = -b.s * wx, .i = (-b.wx * wx - b.wy * wy - b.wz * wz)}; }
    constexpr Motor Bivector::antiDot(const Translator& b) const noexcept { return {.s = 0.0, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = -wz, .xz = wy, .yz = -wx, .i = (-b.wx * wx - b.wy * wy - b.wz * wz)}; }
    constexpr ProjectivePoint Bivector::antiDot(const Vector& b) const noexcept { return {.x = (b.y * wz - b.z * wy), .y = (b.z * wx - b.x * wz), .z = (b.x * wy - b.y * wx), .w = (b.x * yz + b.z * xy - b.y * xz)}; }
    constexpr ProjectivePoint Bivector::antiDot(const Point& b) const noexcept { return {.x = (b.y * wz - b.z * wy), .y = (b.z * wx - b.x * wz), .z = (b.x * wy - b.y * wx), .w = (b.x * yz + b.z * xy - b.y * xz)}; }
    constexpr ProjectivePoint Bivector::antiDot(const PlaneIdeal& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = (b.x * wx + b.y * wy + b.z * wz)}; }
    constexpr PseudoScalar Bivector::antiDot(const BivectorWeight& b) const noexcept { return {.i = (-b.wx * wx - b.wy * wy - b.wz * wz)}; }
    constexpr Bivector Bivector::antiDot(const PseudoScalar& b) const noexcept { return {.wx = b.i * wx, .wy = b.i * wy, .wz = b.i * wz, .xy = b.i * xy, .xz = b.i * xz, .yz = b.i * yz}; }

    constexpr Multivector ProjectivePoint::antiDot(const Motor& b) const noexcept { return {.s = 0.0, .w = 0.0, .x = b.s * x, .y = b.s * y, .z = b.s * z, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.wy * x - b.i * z - b.wx * y), .wxz = (b.i * y + b.wz * x - b.wx * z), .wyz = (b.wz * y - b.i * x - b.wy * z), .xyz = (b.i * w + b.xz * y - b.xy * z - b.yz * x), .i = 0.0}; }
    constexpr Bivector ProjectivePoint::antiDot(const Plane& b) const noexcept { return {.wx = b.w * x, .wy = b.w * y, .wz = b.w * z, .xy = (b.x * y - b.y * x), .xz = (b.x * z - b.z * x), .yz = (b.y * z - b.z * y)}; }
    constexpr ProjectivePoint ProjectivePoint::antiDot(const Bivector& b) const noexcept { return {.x = (b.wy * z - b.wz * y), .y = (b.wz * x - b.wx * z), .z = (b.wx * y - b.wy * x), .w = (b.xz * y - b.xy * z - b.yz * x)}; }
    constexpr PseudoScalar ProjectivePoint::antiDot(const ProjectivePoint& b) const noexcept { return {.i = (b.x * x + b.y * y + b.z * z)}; }
    constexpr Multivector ProjectivePoint::antiDot(const Quaternion& b) const noexcept { return {.s = 0.0, .w = 0.0, .x = b.s * x, .y = b.s * y, .z = b.s * z, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = 0.0, .wxz = 0.0, .wyz = 0.0, .xyz = (b.xz * y - b.xy * z - b.yz * x), .i = 0.0}; }
    constexpr Multivector ProjectivePoint::antiDot(const ProjectiveTranslator& b) const noexcept { return {.s = 0.0, .w = 0.0, .x = b.s * x, .y = b.s * y, .z = b.s * z, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.wy * x - b.wx * y), .wxz = (b.wz * x - b.wx * z), .wyz = (b.wz * y - b.wy * z), .xyz = 0.0, .i = 0.0}; }
    constexpr Multivector ProjectivePoint::antiDot(const Translator& b) const noexcept { return {.s = 0.0, .w = 0.0, .x = x, .y = y, .z = z, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.wy * x - b.wx * y), .wxz = (b.wz * x - b.wx * z), .wyz = (b.wz * y - b.wy * z), .xyz = 0.0, .i = 0.0}; }
    constexpr PseudoScalar ProjectivePoint::antiDot(const Vector& b) const noexcept { return {.i = (b.x * x + b.y * y + b.z * z)}; }
    constexpr PseudoScalar ProjectivePoint::antiDot(const Point& b) const noexcept { return {.i = (b.x * x + b.y * y + b.z * z)}; }
    constexpr BivectorBulk ProjectivePoint::antiDot(const PlaneIdeal& b) const noexcept { return {.xy = (b.x * y - b.y * x), .xz = (b.x * z - b.z * x), .yz = (b.y * z - b.z * y)}; }
    constexpr ProjectivePoint ProjectivePoint::antiDot(const BivectorBulk& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = (b.xz * y - b.xy * z - b.yz * x)}; }
    constexpr Vector ProjectivePoint::antiDot(const BivectorWeight& b) const noexcept { return {.x = (b.wy * z - b.wz * y), .y = (b.wz * x - b.wx * z), .z = (b.wx * y - b.wy * x)}; }
    constexpr ProjectivePoint ProjectivePoint::antiDot(const PseudoScalar& b) const noexcept { return {.x = b.i * x, .y = b.i * y, .z = b.i * z, .w = b.i * w}; }

    constexpr Quaternion Quaternion::antiDot(const Motor& b) const noexcept { return {.s = b.i * s, .xy = (b.i * xy - b.wz * s), .xz = (b.i * xz + b.wy * s), .yz = (b.i * yz - b.wx * s)}; }
    constexpr ProjectivePoint Quaternion::antiDot(const Plane& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = -b.w * s}; }
    constexpr BivectorBulk Quaternion::antiDot(const Bivector& b) const noexcept { return {.xy = -b.wz * s, .xz = b.wy * s, .yz = -b.wx * s}; }
    constexpr Multivector Quaternion::antiDot(const ProjectivePoint& b) const noexcept { return {.s = 0.0, .w = 0.0, .x = -b.x * s, .y = -b.y * s, .z = -b.z * s, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = 0.0, .wxz = 0.0, .wyz = 0.0, .xyz = (b.x * yz + b.z * xy - b.y * xz), .i = 0.0}; }
    constexpr BivectorBulk Quaternion::antiDot(const ProjectiveTranslator& b) const noexcept { return {.xy = -b.wz * s, .xz = b.wy * s, .yz = -b.wx * s}; }
    constexpr BivectorBulk Quaternion::antiDot(const Translator& b) const noexcept { return {.xy = -b.wz * s, .xz = b.wy * s, .yz = -b.wx * s}; }
    constexpr Multivector Quaternion::antiDot(const Vector& b) const noexcept { return {.s = 0.0, .w = 0.0, .x = -b.x * s, .y = -b.y * s, .z = -b.z * s, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = 0.0, .wxz = 0.0, .wyz = 0.0, .xyz = (b.x * yz + b.z * xy - b.y * xz), .i = 0.0}; }
    constexpr Multivector Quaternion::antiDot(const Point& b) const noexcept { return {.s = 0.0, .w = 0.0, .x = -b.x * s, .y = -b.y * s, .z = -b.z * s, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = 0.0, .wxz = 0.0, .wyz = 0.0, .xyz = (b.x * yz + b.z * xy - b.y * xz), .i = 0.0}; }
    constexpr BivectorBulk Quaternion::antiDot(const BivectorWeight& b) const noexcept { return {.xy = -b.wz * s, .xz = b.wy * s, .yz = -b.wx * s}; }
    constexpr Quaternion Quaternion::antiDot(const PseudoScalar& b) const noexcept { return {.s = b.i * s, .xy = b.i * xy, .xz = b.i * xz, .yz = b.i * yz}; }

    constexpr Motor ProjectiveTranslator::antiDot(const Motor& b) const noexcept { return {.s = b.i * s, .wx = b.i * wx, .wy = b.i * wy, .wz = b.i * wz, .xy = (-b.s * wz - b.wz * s), .xz = (b.s * wy + b.wy * s), .yz = (-b.s * wx - b.wx * s), .i = (-b.wx * wx - b.wy * wy - b.wz * wz)}; }
    constexpr ProjectivePoint ProjectiveTranslator::antiDot(const Plane& b) const noexcept { return {.x = -b.w * wx, .y = -b.w * wy, .z = -b.w * wz, .w = (b.x * wx + b.y * wy + b.z * wz - b.w * s)}; }
    constexpr Motor ProjectiveTranslator::antiDot(const Bivector& b) const noexcept { return {.s = 0.0, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = -b.wz * s, .xz = b.wy * s, .yz = -b.wx * s, .i = (-b.wx * wx - b.wy * wy - b.wz * wz)}; }
    constexpr Multivector ProjectiveTranslator::antiDot(const ProjectivePoint& b) const noexcept { return {.s = 0.0, .w = 0.0, .x = -b.x * s, .y = -b.y * s, .z = -b.z * s, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.y * wx - b.x * wy), .wxz = (b.z * wx - b.x * wz), .wyz = (b.z * wy - b.y * wz), .xyz = 0.0, .i = 0.0}; }
    constexpr BivectorBulk ProjectiveTranslator::antiDot(const Quaternion& b) const noexcept { return {.xy = -b.s * wz, .xz = b.s * wy, .yz = -b.s * wx}; }
    constexpr Motor ProjectiveTranslator::antiDot(const ProjectiveTranslator& b) const noexcept { return {.s = 0.0, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = (-b.s * wz - b.wz * s), .xz = (b.s * wy + b.wy * s), .yz = (-b.s * wx - b.wx * s), .i = (-b.wx * wx - b.wy * wy - b.wz * wz)}; }
    constexpr Motor ProjectiveTranslator::antiDot(const Translator& b) const noexcept { return {.s = 0.0, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = (-wz - b.wz * s), .xz = (wy + b.wy * s), .yz = (-wx - b.wx * s), .i = (-b.wx * wx - b.wy * wy - b.wz * wz)}; }
    constexpr Multivector ProjectiveTranslator::antiDot(const Vector& b) const noexcept { return {.s = 0.0, .w = 0.0, .x = -b.x * s, .y = -b.y * s, .z = -b.z * s, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.y * wx - b.x * wy), .wxz = (b.z * wx - b.x * wz), .wyz = (b.z * wy - b.y * wz), .xyz = 0.0, .i = 0.0}; }
    constexpr Multivector ProjectiveTranslator::antiDot(const Point& b) const noexcept { return {.s = 0.0, .w = 0.0, .x = -b.x * s, .y = -b.y * s, .z = -b.z * s, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.y * wx - b.x * wy), .wxz = (b.z * wx - b.x * wz), .wyz = (b.z * wy - b.y * wz), .xyz = 0.0, .i = 0.0}; }
    constexpr ProjectivePoint ProjectiveTranslator::antiDot(const PlaneIdeal& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = (b.x * wx + b.y * wy + b.z * wz)}; }
    constexpr Motor ProjectiveTranslator::antiDot(const BivectorWeight& b) const noexcept { return {.s = 0.0, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = -b.wz * s, .xz = b.wy * s, .yz = -b.wx * s, .i = (-b.wx * wx - b.wy * wy - b.wz * wz)}; }
    constexpr ProjectiveTranslator ProjectiveTranslator::antiDot(const PseudoScalar& b) const noexcept { return {.s = b.i * s, .wx = b.i * wx, .wy = b.i * wy, .wz = b.i * wz}; }

    constexpr Motor Translator::antiDot(const Motor& b) const noexcept { return {.s = b.i, .wx = b.i * wx, .wy = b.i * wy, .wz = b.i * wz, .xy = (-b.wz - b.s * wz), .xz = (b.wy + b.s * wy), .yz = (-b.wx - b.s * wx), .i = (-b.wx * wx - b.wy * wy - b.wz * wz)}; }
    constexpr ProjectivePoint Translator::antiDot(const Plane& b) const noexcept { return {.x = -b.w * wx, .y = -b.w * wy, .z = -b.w * wz, .w = (-b.w + b.x * wx + b.y * wy + b.z * wz)}; }
    constexpr Motor Translator::antiDot(const Bivector& b) const noexcept { return {.s = 0.0, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = -b.wz, .xz = b.wy, .yz = -b.wx, .i = (-b.wx * wx - b.wy * wy - b.wz * wz)}; }
    constexpr Multivector Translator::antiDot(const ProjectivePoint& b) const noexcept { return {.s = 0.0, .w = 0.0, .x = -b.x, .y = -b.y, .z = -b.z, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.y * wx - b.x * wy), .wxz = (b.z * wx - b.x * wz), .wyz = (b.z * wy - b.y * wz), .xyz = 0.0, .i = 0.0}; }
    constexpr BivectorBulk Translator::antiDot(const Quaternion& b) const noexcept { return {.xy = -b.s * wz, .xz = b.s * wy, .yz = -b.s * wx}; }
    constexpr Motor Translator::antiDot(const ProjectiveTranslator& b) const noexcept { return {.s = 0.0, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = (-b.wz - b.s * wz), .xz = (b.wy + b.s * wy), .yz = (-b.wx - b.s * wx), .i = (-b.wx * wx - b.wy * wy - b.wz * wz)}; }
    constexpr Motor Translator::antiDot(const Translator& b) const noexcept { return {.s = 0.0, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = (-b.wz - wz), .xz = (b.wy + wy), .yz = (-b.wx - wx), .i = (-b.wx * wx - b.wy * wy - b.wz * wz)}; }
    constexpr Multivector Translator::antiDot(const Vector& b) const noexcept { return {.s = 0.0, .w = 0.0, .x = -b.x, .y = -b.y, .z = -b.z, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.y * wx - b.x * wy), .wxz = (b.z * wx - b.x * wz), .wyz = (b.z * wy - b.y * wz), .xyz = 0.0, .i = 0.0}; }
    constexpr Multivector Translator::antiDot(const Point& b) const noexcept { return {.s = 0.0, .w = 0.0, .x = -b.x, .y = -b.y, .z = -b.z, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.y * wx - b.x * wy), .wxz = (b.z * wx - b.x * wz), .wyz = (b.z * wy - b.y * wz), .xyz = 0.0, .i = 0.0}; }
    constexpr ProjectivePoint Translator::antiDot(const PlaneIdeal& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = (b.x * wx + b.y * wy + b.z * wz)}; }
    constexpr Motor Translator::antiDot(const BivectorWeight& b) const noexcept { return {.s = 0.0, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = -b.wz, .xz = b.wy, .yz = -b.wx, .i = (-b.wx * wx - b.wy * wy - b.wz * wz)}; }
    constexpr ProjectiveTranslator Translator::antiDot(const PseudoScalar& b) const noexcept { return {.s = b.i, .wx = b.i * wx, .wy = b.i * wy, .wz = b.i * wz}; }

    constexpr Multivector Vector::antiDot(const Motor& b) const noexcept { return {.s = 0.0, .w = 0.0, .x = b.s * x, .y = b.s * y, .z = b.s * z, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.wy * x - b.i * z - b.wx * y), .wxz = (b.i * y + b.wz * x - b.wx * z), .wyz = (b.wz * y - b.i * x - b.wy * z), .xyz = (b.xz * y - b.xy * z - b.yz * x), .i = 0.0}; }
    constexpr Bivector Vector::antiDot(const Plane& b) const noexcept { return {.wx = b.w * x, .wy = b.w * y, .wz = b.w * z, .xy = (b.x * y - b.y * x), .xz = (b.x * z - b.z * x), .yz = (b.y * z - b.z * y)}; }
    constexpr ProjectivePoint Vector::antiDot(const Bivector& b) const noexcept { return {.x = (b.wy * z - b.wz * y), .y = (b.wz * x - b.wx * z), .z = (b.wx * y - b.wy * x), .w = (b.xz * y - b.xy * z - b.yz * x)}; }
    constexpr PseudoScalar Vector::antiDot(const ProjectivePoint& b) const noexcept { return {.i = (b.x * x + b.y * y + b.z * z)}; }
    constexpr Multivector Vector::antiDot(const Quaternion& b) const noexcept { return {.s = 0.0, .w = 0.0, .x = b.s * x, .y = b.s * y, .z = b.s * z, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = 0.0, .wxz = 0.0, .wyz = 0.0, .xyz = (b.xz * y - b.xy * z - b.yz * x), .i = 0.0}; }
    constexpr Multivector Vector::antiDot(const ProjectiveTranslator& b) const noexcept { return {.s = 0.0, .w = 0.0, .x = b.s * x, .y = b.s * y, .z = b.s * z, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.wy * x - b.wx * y), .wxz = (b.wz * x - b.wx * z), .wyz = (b.wz * y - b.wy * z), .xyz = 0.0, .i = 0.0}; }
    constexpr Multivector Vector::antiDot(const Translator& b) const noexcept { return {.s = 0.0, .w = 0.0, .x = x, .y = y, .z = z, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.wy * x - b.wx * y), .wxz = (b.wz * x - b.wx * z), .wyz = (b.wz * y - b.wy * z), .xyz = 0.0, .i = 0.0}; }
    constexpr PseudoScalar Vector::antiDot(const Vector& b) const noexcept { return {.i = (b.x * x + b.y * y + b.z * z)}; }
    constexpr PseudoScalar Vector::antiDot(const Point& b) const noexcept { return {.i = (b.x * x + b.y * y + b.z * z)}; }
    constexpr BivectorBulk Vector::antiDot(const PlaneIdeal& b) const noexcept { return {.xy = (b.x * y - b.y * x), .xz = (b.x * z - b.z * x), .yz = (b.y * z - b.z * y)}; }
    constexpr ProjectivePoint Vector::antiDot(const BivectorBulk& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = (b.xz * y - b.xy * z - b.yz * x)}; }
    constexpr Vector Vector::antiDot(const BivectorWeight& b) const noexcept { return {.x = (b.wy * z - b.wz * y), .y = (b.wz * x - b.wx * z), .z = (b.wx * y - b.wy * x)}; }
    constexpr Vector Vector::antiDot(const PseudoScalar& b) const noexcept { return {.x = b.i * x, .y = b.i * y, .z = b.i * z}; }

    constexpr Multivector Point::antiDot(const Motor& b) const noexcept { return {.s = 0.0, .w = 0.0, .x = b.s * x, .y = b.s * y, .z = b.s * z, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.wy * x - b.i * z - b.wx * y), .wxz = (b.i * y + b.wz * x - b.wx * z), .wyz = (b.wz * y - b.i * x - b.wy * z), .xyz = (b.i + b.xz * y - b.xy * z - b.yz * x), .i = 0.0}; }
    constexpr Bivector Point::antiDot(const Plane& b) const noexcept { return {.wx = b.w * x, .wy = b.w * y, .wz = b.w * z, .xy = (b.x * y - b.y * x), .xz = (b.x * z - b.z * x), .yz = (b.y * z - b.z * y)}; }
    constexpr ProjectivePoint Point::antiDot(const Bivector& b) const noexcept { return {.x = (b.wy * z - b.wz * y), .y = (b.wz * x - b.wx * z), .z = (b.wx * y - b.wy * x), .w = (b.xz * y - b.xy * z - b.yz * x)}; }
    constexpr PseudoScalar Point::antiDot(const ProjectivePoint& b) const noexcept { return {.i = (b.x * x + b.y * y + b.z * z)}; }
    constexpr Multivector Point::antiDot(const Quaternion& b) const noexcept { return {.s = 0.0, .w = 0.0, .x = b.s * x, .y = b.s * y, .z = b.s * z, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = 0.0, .wxz = 0.0, .wyz = 0.0, .xyz = (b.xz * y - b.xy * z - b.yz * x), .i = 0.0}; }
    constexpr Multivector Point::antiDot(const ProjectiveTranslator& b) const noexcept { return {.s = 0.0, .w = 0.0, .x = b.s * x, .y = b.s * y, .z = b.s * z, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.wy * x - b.wx * y), .wxz = (b.wz * x - b.wx * z), .wyz = (b.wz * y - b.wy * z), .xyz = 0.0, .i = 0.0}; }
    constexpr Multivector Point::antiDot(const Translator& b) const noexcept { return {.s = 0.0, .w = 0.0, .x = x, .y = y, .z = z, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.wy * x - b.wx * y), .wxz = (b.wz * x - b.wx * z), .wyz = (b.wz * y - b.wy * z), .xyz = 0.0, .i = 0.0}; }
    constexpr PseudoScalar Point::antiDot(const Vector& b) const noexcept { return {.i = (b.x * x + b.y * y + b.z * z)}; }
    constexpr PseudoScalar Point::antiDot(const Point& b) const noexcept { return {.i = (b.x * x + b.y * y + b.z * z)}; }
    constexpr BivectorBulk Point::antiDot(const PlaneIdeal& b) const noexcept { return {.xy = (b.x * y - b.y * x), .xz = (b.x * z - b.z * x), .yz = (b.y * z - b.z * y)}; }
    constexpr ProjectivePoint Point::antiDot(const BivectorBulk& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = (b.xz * y - b.xy * z - b.yz * x)}; }
    constexpr Vector Point::antiDot(const BivectorWeight& b) const noexcept { return {.x = (b.wy * z - b.wz * y), .y = (b.wz * x - b.wx * z), .z = (b.wx * y - b.wy * x)}; }
    constexpr ProjectivePoint Point::antiDot(const PseudoScalar& b) const noexcept { return {.x = b.i * x, .y = b.i * y, .z = b.i * z, .w = b.i}; }

    constexpr Multivector PlaneIdeal::antiDot(const Motor& b) const noexcept { return {.s = 0.0, .w = 0.0, .x = b.i * x, .y = b.i * y, .z = b.i * z, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = 0.0, .wxz = 0.0, .wyz = 0.0, .xyz = (b.wx * x + b.wy * y + b.wz * z), .i = 0.0}; }
    constexpr ProjectivePoint PlaneIdeal::antiDot(const Bivector& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = (b.wx * x + b.wy * y + b.wz * z)}; }
    constexpr BivectorBulk PlaneIdeal::antiDot(const ProjectivePoint& b) const noexcept { return {.xy = (b.y * x - b.x * y), .xz = (b.z * x - b.x * z), .yz = (b.z * y - b.y * z)}; }
    constexpr ProjectivePoint PlaneIdeal::antiDot(const ProjectiveTranslator& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = (b.wx * x + b.wy * y + b.wz * z)}; }
    constexpr ProjectivePoint PlaneIdeal::antiDot(const Translator& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = (b.wx * x + b.wy * y + b.wz * z)}; }
    constexpr BivectorBulk PlaneIdeal::antiDot(const Vector& b) const noexcept { return {.xy = (b.y * x - b.x * y), .xz = (b.z * x - b.x * z), .yz = (b.z * y - b.y * z)}; }
    constexpr BivectorBulk PlaneIdeal::antiDot(const Point& b) const noexcept { return {.xy = (b.y * x - b.x * y), .xz = (b.z * x - b.x * z), .yz = (b.z * y - b.y * z)}; }
    constexpr ProjectivePoint PlaneIdeal::antiDot(const BivectorWeight& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = (b.wx * x + b.wy * y + b.wz * z)}; }
    constexpr PlaneIdeal PlaneIdeal::antiDot(const PseudoScalar& b) const noexcept { return {.x = b.i * x, .y = b.i * y, .z = b.i * z}; }

    constexpr BivectorBulk BivectorBulk::antiDot(const Motor& b) const noexcept { return {.xy = b.i * xy, .xz = b.i * xz, .yz = b.i * yz}; }
    constexpr ProjectivePoint BivectorBulk::antiDot(const ProjectivePoint& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = (b.x * yz + b.z * xy - b.y * xz)}; }
    constexpr ProjectivePoint BivectorBulk::antiDot(const Vector& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = (b.x * yz + b.z * xy - b.y * xz)}; }
    constexpr ProjectivePoint BivectorBulk::antiDot(const Point& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = (b.x * yz + b.z * xy - b.y * xz)}; }
    constexpr BivectorBulk BivectorBulk::antiDot(const PseudoScalar& b) const noexcept { return {.xy = b.i * xy, .xz = b.i * xz, .yz = b.i * yz}; }

    constexpr Motor BivectorWeight::antiDot(const Motor& b) const noexcept { return {.s = 0.0, .wx = b.i * wx, .wy = b.i * wy, .wz = b.i * wz, .xy = -b.s * wz, .xz = b.s * wy, .yz = -b.s * wx, .i = (-b.wx * wx - b.wy * wy - b.wz * wz)}; }
    constexpr ProjectivePoint BivectorWeight::antiDot(const Plane& b) const noexcept { return {.x = -b.w * wx, .y = -b.w * wy, .z = -b.w * wz, .w = (b.x * wx + b.y * wy + b.z * wz)}; }
    constexpr PseudoScalar BivectorWeight::antiDot(const Bivector& b) const noexcept { return {.i = (-b.wx * wx - b.wy * wy - b.wz * wz)}; }
    constexpr Vector BivectorWeight::antiDot(const ProjectivePoint& b) const noexcept { return {.x = (b.y * wz - b.z * wy), .y = (b.z * wx - b.x * wz), .z = (b.x * wy - b.y * wx)}; }
    constexpr BivectorBulk BivectorWeight::antiDot(const Quaternion& b) const noexcept { return {.xy = -b.s * wz, .xz = b.s * wy, .yz = -b.s * wx}; }
    constexpr Motor BivectorWeight::antiDot(const ProjectiveTranslator& b) const noexcept { return {.s = 0.0, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = -b.s * wz, .xz = b.s * wy, .yz = -b.s * wx, .i = (-b.wx * wx - b.wy * wy - b.wz * wz)}; }
    constexpr Motor BivectorWeight::antiDot(const Translator& b) const noexcept { return {.s = 0.0, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = -wz, .xz = wy, .yz = -wx, .i = (-b.wx * wx - b.wy * wy - b.wz * wz)}; }
    constexpr Vector BivectorWeight::antiDot(const Vector& b) const noexcept { return {.x = (b.y * wz - b.z * wy), .y = (b.z * wx - b.x * wz), .z = (b.x * wy - b.y * wx)}; }
    constexpr Vector BivectorWeight::antiDot(const Point& b) const noexcept { return {.x = (b.y * wz - b.z * wy), .y = (b.z * wx - b.x * wz), .z = (b.x * wy - b.y * wx)}; }
    constexpr ProjectivePoint BivectorWeight::antiDot(const PlaneIdeal& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = (b.x * wx + b.y * wy + b.z * wz)}; }
    constexpr PseudoScalar BivectorWeight::antiDot(const BivectorWeight& b) const noexcept { return {.i = (-b.wx * wx - b.wy * wy - b.wz * wz)}; }
    constexpr BivectorWeight BivectorWeight::antiDot(const PseudoScalar& b) const noexcept { return {.wx = b.i * wx, .wy = b.i * wy, .wz = b.i * wz}; }

    constexpr Motor PseudoScalar::antiDot(const Motor& b) const noexcept { return {.s = b.s * i, .wx = b.wx * i, .wy = b.wy * i, .wz = b.wz * i, .xy = b.xy * i, .xz = b.xz * i, .yz = b.yz * i, .i = b.i * i}; }
    constexpr Plane PseudoScalar::antiDot(const Plane& b) const noexcept { return {.x = b.x * i, .y = b.y * i, .z = b.z * i, .w = b.w * i}; }
    constexpr Bivector PseudoScalar::antiDot(const Bivector& b) const noexcept { return {.wx = b.wx * i, .wy = b.wy * i, .wz = b.wz * i, .xy = b.xy * i, .xz = b.xz * i, .yz = b.yz * i}; }
    constexpr ProjectivePoint PseudoScalar::antiDot(const ProjectivePoint& b) const noexcept { return {.x = b.x * i, .y = b.y * i, .z = b.z * i, .w = b.w * i}; }
    constexpr Quaternion PseudoScalar::antiDot(const Quaternion& b) const noexcept { return {.s = b.s * i, .xy = b.xy * i, .xz = b.xz * i, .yz = b.yz * i}; }
    constexpr ProjectiveTranslator PseudoScalar::antiDot(const ProjectiveTranslator& b) const noexcept { return {.s = b.s * i, .wx = b.wx * i, .wy = b.wy * i, .wz = b.wz * i}; }
    constexpr ProjectiveTranslator PseudoScalar::antiDot(const Translator& b) const noexcept { return {.s = i, .wx = b.wx * i, .wy = b.wy * i, .wz = b.wz * i}; }
    constexpr Vector PseudoScalar::antiDot(const Vector& b) const noexcept { return {.x = b.x * i, .y = b.y * i, .z = b.z * i}; }
    constexpr ProjectivePoint PseudoScalar::antiDot(const Point& b) const noexcept { return {.x = b.x * i, .y = b.y * i, .z = b.z * i, .w = i}; }
    constexpr PlaneIdeal PseudoScalar::antiDot(const PlaneIdeal& b) const noexcept { return {.x = b.x * i, .y = b.y * i, .z = b.z * i}; }
    constexpr BivectorBulk PseudoScalar::antiDot(const BivectorBulk& b) const noexcept { return {.xy = b.xy * i, .xz = b.xz * i, .yz = b.yz * i}; }
    constexpr BivectorWeight PseudoScalar::antiDot(const BivectorWeight& b) const noexcept { return {.wx = b.wx * i, .wy = b.wy * i, .wz = b.wz * i}; }
    constexpr PseudoScalar PseudoScalar::antiDot(const PseudoScalar& b) const noexcept { return {.i = b.i * i}; }
    constexpr ProjectivePoint PseudoScalar::antiDot(const PointCenter& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = i}; }

    constexpr ProjectivePoint PointCenter::antiDot(const Motor& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = b.i}; }
    constexpr ProjectivePoint PointCenter::antiDot(const PseudoScalar& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = b.i}; }

}

// opsWedge.h

// generated by com.github.kright.pga3d.codegen.cpp.ops.WedgeOpGenerator

namespace pga3d {
    constexpr Multivector Multivector::wedge(const Multivector& b) const noexcept { return {.s = b.s * s, .w = (b.s * w + b.w * s), .x = (b.s * x + b.x * s), .y = (b.s * y + b.y * s), .z = (b.s * z + b.z * s), .wx = (b.s * wx + b.wx * s + b.x * w - b.w * x), .wy = (b.s * wy + b.wy * s + b.y * w - b.w * y), .wz = (b.s * wz + b.wz * s + b.z * w - b.w * z), .xy = (b.s * xy + b.xy * s + b.y * x - b.x * y), .xz = (b.s * xz + b.xz * s + b.z * x - b.x * z), .yz = (b.s * yz + b.yz * s + b.z * y - b.y * z), .wxy = (b.s * wxy + b.w * xy + b.wx * y + b.wxy * s + b.xy * w + b.y * wx - b.wy * x - b.x * wy), .wxz = (b.s * wxz + b.w * xz + b.wx * z + b.wxz * s + b.xz * w + b.z * wx - b.wz * x - b.x * wz), .wyz = (b.s * wyz + b.w * yz + b.wy * z + b.wyz * s + b.yz * w + b.z * wy - b.wz * y - b.y * wz), .xyz = (b.s * xyz + b.x * yz + b.xy * z + b.xyz * s + b.yz * x + b.z * xy - b.xz * y - b.y * xz), .i = (b.i * s + b.s * i + b.wx * yz + b.wxz * y + b.wz * xy + b.x * wyz + b.xy * wz + b.xyz * w + b.yz * wx + b.z * wxy - b.w * xyz - b.wxy * z - b.wy * xz - b.wyz * x - b.xz * wy - b.y * wxz)}; }

    constexpr Motor Motor::wedge(const Motor& b) const noexcept { return {.s = b.s * s, .wx = (b.s * wx + b.wx * s), .wy = (b.s * wy + b.wy * s), .wz = (b.s * wz + b.wz * s), .xy = (b.s * xy + b.xy * s), .xz = (b.s * xz + b.xz * s), .yz = (b.s * yz + b.yz * s), .i = (b.i * s + b.s * i + b.wx * yz + b.wz * xy + b.xy * wz + b.yz * wx - b.wy * xz - b.xz * wy)}; }
    constexpr Multivector Motor::wedge(const Plane& b) const noexcept { return {.s = 0.0, .w = b.w * s, .x = b.x * s, .y = b.y * s, .z = b.z * s, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.w * xy + b.y * wx - b.x * wy), .wxz = (b.w * xz + b.z * wx - b.x * wz), .wyz = (b.w * yz + b.z * wy - b.y * wz), .xyz = (b.x * yz + b.z * xy - b.y * xz), .i = 0.0}; }
    constexpr Motor Motor::wedge(const Bivector& b) const noexcept { return {.s = 0.0, .wx = b.wx * s, .wy = b.wy * s, .wz = b.wz * s, .xy = b.xy * s, .xz = b.xz * s, .yz = b.yz * s, .i = (b.wx * yz + b.wz * xy + b.xy * wz + b.yz * wx - b.wy * xz - b.xz * wy)}; }
    constexpr ProjectivePoint Motor::wedge(const ProjectivePoint& b) const noexcept { return {.x = b.x * s, .y = b.y * s, .z = b.z * s, .w = b.w * s}; }
    constexpr Motor Motor::wedge(const Quaternion& b) const noexcept { return {.s = b.s * s, .wx = b.s * wx, .wy = b.s * wy, .wz = b.s * wz, .xy = (b.s * xy + b.xy * s), .xz = (b.s * xz + b.xz * s), .yz = (b.s * yz + b.yz * s), .i = (b.s * i + b.xy * wz + b.yz * wx - b.xz * wy)}; }
    constexpr Motor Motor::wedge(const ProjectiveTranslator& b) const noexcept { return {.s = b.s * s, .wx = (b.s * wx + b.wx * s), .wy = (b.s * wy + b.wy * s), .wz = (b.s * wz + b.wz * s), .xy = b.s * xy, .xz = b.s * xz, .yz = b.s * yz, .i = (b.s * i + b.wx * yz + b.wz * xy - b.wy * xz)}; }
    constexpr Motor Motor::wedge(const Translator& b) const noexcept { return {.s = s, .wx = (wx + b.wx * s), .wy = (wy + b.wy * s), .wz = (wz + b.wz * s), .xy = xy, .xz = xz, .yz = yz, .i = (i + b.wx * yz + b.wz * xy - b.wy * xz)}; }
    constexpr Vector Motor::wedge(const Vector& b) const noexcept { return {.x = b.x * s, .y = b.y * s, .z = b.z * s}; }
    constexpr ProjectivePoint Motor::wedge(const Point& b) const noexcept { return {.x = b.x * s, .y = b.y * s, .z = b.z * s, .w = s}; }
    constexpr Multivector Motor::wedge(const PlaneIdeal& b) const noexcept { return {.s = 0.0, .w = 0.0, .x = b.x * s, .y = b.y * s, .z = b.z * s, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.y * wx - b.x * wy), .wxz = (b.z * wx - b.x * wz), .wyz = (b.z * wy - b.y * wz), .xyz = (b.x * yz + b.z * xy - b.y * xz), .i = 0.0}; }
    constexpr Motor Motor::wedge(const BivectorBulk& b) const noexcept { return {.s = 0.0, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = b.xy * s, .xz = b.xz * s, .yz = b.yz * s, .i = (b.xy * wz + b.yz * wx - b.xz * wy)}; }
    constexpr Motor Motor::wedge(const BivectorWeight& b) const noexcept { return {.s = 0.0, .wx = b.wx * s, .wy = b.wy * s, .wz = b.wz * s, .xy = 0.0, .xz = 0.0, .yz = 0.0, .i = (b.wx * yz + b.wz * xy - b.wy * xz)}; }
    constexpr PseudoScalar Motor::wedge(const PseudoScalar& b) const noexcept { return {.i = b.i * s}; }
    constexpr ProjectivePoint Motor::wedge(const PointCenter& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = s}; }

    constexpr Multivector Plane::wedge(const Motor& b) const noexcept { return {.s = 0.0, .w = b.s * w, .x = b.s * x, .y = b.s * y, .z = b.s * z, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.wx * y + b.xy * w - b.wy * x), .wxz = (b.wx * z + b.xz * w - b.wz * x), .wyz = (b.wy * z + b.yz * w - b.wz * y), .xyz = (b.xy * z + b.yz * x - b.xz * y), .i = 0.0}; }
    constexpr Bivector Plane::wedge(const Plane& b) const noexcept { return {.wx = (b.x * w - b.w * x), .wy = (b.y * w - b.w * y), .wz = (b.z * w - b.w * z), .xy = (b.y * x - b.x * y), .xz = (b.z * x - b.x * z), .yz = (b.z * y - b.y * z)}; }
    constexpr ProjectivePoint Plane::wedge(const Bivector& b) const noexcept { return {.x = (b.wz * y - b.wy * z - b.yz * w), .y = (b.wx * z + b.xz * w - b.wz * x), .z = (b.wy * x - b.wx * y - b.xy * w), .w = (b.xy * z + b.yz * x - b.xz * y)}; }
    constexpr PseudoScalar Plane::wedge(const ProjectivePoint& b) const noexcept { return {.i = (b.w * w + b.x * x + b.y * y + b.z * z)}; }
    constexpr Multivector Plane::wedge(const Quaternion& b) const noexcept { return {.s = 0.0, .w = b.s * w, .x = b.s * x, .y = b.s * y, .z = b.s * z, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = b.xy * w, .wxz = b.xz * w, .wyz = b.yz * w, .xyz = (b.xy * z + b.yz * x - b.xz * y), .i = 0.0}; }
    constexpr Multivector Plane::wedge(const ProjectiveTranslator& b) const noexcept { return {.s = 0.0, .w = b.s * w, .x = b.s * x, .y = b.s * y, .z = b.s * z, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.wx * y - b.wy * x), .wxz = (b.wx * z - b.wz * x), .wyz = (b.wy * z - b.wz * y), .xyz = 0.0, .i = 0.0}; }
    constexpr Multivector Plane::wedge(const Translator& b) const noexcept { return {.s = 0.0, .w = w, .x = x, .y = y, .z = z, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.wx * y - b.wy * x), .wxz = (b.wx * z - b.wz * x), .wyz = (b.wy * z - b.wz * y), .xyz = 0.0, .i = 0.0}; }
    constexpr PseudoScalar Plane::wedge(const Vector& b) const noexcept { return {.i = (b.x * x + b.y * y + b.z * z)}; }
    constexpr PseudoScalar Plane::wedge(const Point& b) const noexcept { return {.i = (w + b.x * x + b.y * y + b.z * z)}; }
    constexpr Bivector Plane::wedge(const PlaneIdeal& b) const noexcept { return {.wx = b.x * w, .wy = b.y * w, .wz = b.z * w, .xy = (b.y * x - b.x * y), .xz = (b.z * x - b.x * z), .yz = (b.z * y - b.y * z)}; }
    constexpr ProjectivePoint Plane::wedge(const BivectorBulk& b) const noexcept { return {.x = -b.yz * w, .y = b.xz * w, .z = -b.xy * w, .w = (b.xy * z + b.yz * x - b.xz * y)}; }
    constexpr Vector Plane::wedge(const BivectorWeight& b) const noexcept { return {.x = (b.wz * y - b.wy * z), .y = (b.wx * z - b.wz * x), .z = (b.wy * x - b.wx * y)}; }
    constexpr PseudoScalar Plane::wedge(const PointCenter& b) const noexcept { return {.i = w}; }

    constexpr Motor Bivector::wedge(const Motor& b) const noexcept { return {.s = 0.0, .wx = b.s * wx, .wy = b.s * wy, .wz = b.s * wz, .xy = b.s * xy, .xz = b.s * xz, .yz = b.s * yz, .i = (b.wx * yz + b.wz * xy + b.xy * wz + b.yz * wx - b.wy * xz - b.xz * wy)}; }
    constexpr ProjectivePoint Bivector::wedge(const Plane& b) const noexcept { return {.x = (b.y * wz - b.w * yz - b.z * wy), .y = (b.w * xz + b.z * wx - b.x * wz), .z = (b.x * wy - b.w * xy - b.y * wx), .w = (b.x * yz + b.z * xy - b.y * xz)}; }
    constexpr PseudoScalar Bivector::wedge(const Bivector& b) const noexcept { return {.i = (b.wx * yz + b.wz * xy + b.xy * wz + b.yz * wx - b.wy * xz - b.xz * wy)}; }
    constexpr Motor Bivector::wedge(const Quaternion& b) const noexcept { return {.s = 0.0, .wx = b.s * wx, .wy = b.s * wy, .wz = b.s * wz, .xy = b.s * xy, .xz = b.s * xz, .yz = b.s * yz, .i = (b.xy * wz + b.yz * wx - b.xz * wy)}; }
    constexpr Motor Bivector::wedge(const ProjectiveTranslator& b) const noexcept { return {.s = 0.0, .wx = b.s * wx, .wy = b.s * wy, .wz = b.s * wz, .xy = b.s * xy, .xz = b.s * xz, .yz = b.s * yz, .i = (b.wx * yz + b.wz * xy - b.wy * xz)}; }
    constexpr Motor Bivector::wedge(const Translator& b) const noexcept { return {.s = 0.0, .wx = wx, .wy = wy, .wz = wz, .xy = xy, .xz = xz, .yz = yz, .i = (b.wx * yz + b.wz * xy - b.wy * xz)}; }
    constexpr ProjectivePoint Bivector::wedge(const PlaneIdeal& b) const noexcept { return {.x = (b.y * wz - b.z * wy), .y = (b.z * wx - b.x * wz), .z = (b.x * wy - b.y * wx), .w = (b.x * yz + b.z * xy - b.y * xz)}; }
    constexpr PseudoScalar Bivector::wedge(const BivectorBulk& b) const noexcept { return {.i = (b.xy * wz + b.yz * wx - b.xz * wy)}; }
    constexpr PseudoScalar Bivector::wedge(const BivectorWeight& b) const noexcept { return {.i = (b.wx * yz + b.wz * xy - b.wy * xz)}; }

    constexpr ProjectivePoint ProjectivePoint::wedge(const Motor& b) const noexcept { return {.x = b.s * x, .y = b.s * y, .z = b.s * z, .w = b.s * w}; }
    constexpr PseudoScalar ProjectivePoint::wedge(const Plane& b) const noexcept { return {.i = (-b.w * w - b.x * x - b.y * y - b.z * z)}; }
    constexpr ProjectivePoint ProjectivePoint::wedge(const Quaternion& b) const noexcept { return {.x = b.s * x, .y = b.s * y, .z = b.s * z, .w = b.s * w}; }
    constexpr ProjectivePoint ProjectivePoint::wedge(const ProjectiveTranslator& b) const noexcept { return {.x = b.s * x, .y = b.s * y, .z = b.s * z, .w = b.s * w}; }
    constexpr ProjectivePoint ProjectivePoint::wedge(const Translator& b) const noexcept { return {.x = x, .y = y, .z = z, .w = w}; }
    constexpr PseudoScalar ProjectivePoint::wedge(const PlaneIdeal& b) const noexcept { return {.i = (-b.x * x - b.y * y - b.z * z)}; }

    constexpr Motor Quaternion::wedge(const Motor& b) const noexcept { return {.s = b.s * s, .wx = b.wx * s, .wy = b.wy * s, .wz = b.wz * s, .xy = (b.s * xy + b.xy * s), .xz = (b.s * xz + b.xz * s), .yz = (b.s * yz + b.yz * s), .i = (b.i * s + b.wx * yz + b.wz * xy - b.wy * xz)}; }
    constexpr Multivector Quaternion::wedge(const Plane& b) const noexcept { return {.s = 0.0, .w = b.w * s, .x = b.x * s, .y = b.y * s, .z = b.z * s, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = b.w * xy, .wxz = b.w * xz, .wyz = b.w * yz, .xyz = (b.x * yz + b.z * xy - b.y * xz), .i = 0.0}; }
    constexpr Motor Quaternion::wedge(const Bivector& b) const noexcept { return {.s = 0.0, .wx = b.wx * s, .wy = b.wy * s, .wz = b.wz * s, .xy = b.xy * s, .xz = b.xz * s, .yz = b.yz * s, .i = (b.wx * yz + b.wz * xy - b.wy * xz)}; }
    constexpr ProjectivePoint Quaternion::wedge(const ProjectivePoint& b) const noexcept { return {.x = b.x * s, .y = b.y * s, .z = b.z * s, .w = b.w * s}; }
    constexpr Quaternion Quaternion::wedge(const Quaternion& b) const noexcept { return {.s = b.s * s, .xy = (b.s * xy + b.xy * s), .xz = (b.s * xz + b.xz * s), .yz = (b.s * yz + b.yz * s)}; }
    constexpr Motor Quaternion::wedge(const ProjectiveTranslator& b) const noexcept { return {.s = b.s * s, .wx = b.wx * s, .wy = b.wy * s, .wz = b.wz * s, .xy = b.s * xy, .xz = b.s * xz, .yz = b.s * yz, .i = (b.wx * yz + b.wz * xy - b.wy * xz)}; }
    constexpr Motor Quaternion::wedge(const Translator& b) const noexcept { return {.s = s, .wx = b.wx * s, .wy = b.wy * s, .wz = b.wz * s, .xy = xy, .xz = xz, .yz = yz, .i = (b.wx * yz + b.wz * xy - b.wy * xz)}; }
    constexpr Vector Quaternion::wedge(const Vector& b) const noexcept { return {.x = b.x * s, .y = b.y * s, .z = b.z * s}; }
    constexpr ProjectivePoint Quaternion::wedge(const Point& b) const noexcept { return {.x = b.x * s, .y = b.y * s, .z = b.z * s, .w = s}; }
    constexpr Multivector Quaternion::wedge(const PlaneIdeal& b) const noexcept { return {.s = 0.0, .w = 0.0, .x = b.x * s, .y = b.y * s, .z = b.z * s, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = 0.0, .wxz = 0.0, .wyz = 0.0, .xyz = (b.x * yz + b.z * xy - b.y * xz), .i = 0.0}; }
    constexpr BivectorBulk Quaternion::wedge(const BivectorBulk& b) const noexcept { return {.xy = b.xy * s, .xz = b.xz * s, .yz = b.yz * s}; }
    constexpr Motor Quaternion::wedge(const BivectorWeight& b) const noexcept { return {.s = 0.0, .wx = b.wx * s, .wy = b.wy * s, .wz = b.wz * s, .xy = 0.0, .xz = 0.0, .yz = 0.0, .i = (b.wx * yz + b.wz * xy - b.wy * xz)}; }
    constexpr PseudoScalar Quaternion::wedge(const PseudoScalar& b) const noexcept { return {.i = b.i * s}; }
    constexpr ProjectivePoint Quaternion::wedge(const PointCenter& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = s}; }

    constexpr Motor ProjectiveTranslator::wedge(const Motor& b) const noexcept { return {.s = b.s * s, .wx = (b.s * wx + b.wx * s), .wy = (b.s * wy + b.wy * s), .wz = (b.s * wz + b.wz * s), .xy = b.xy * s, .xz = b.xz * s, .yz = b.yz * s, .i = (b.i * s + b.xy * wz + b.yz * wx - b.xz * wy)}; }
    constexpr Multivector ProjectiveTranslator::wedge(const Plane& b) const noexcept { return {.s = 0.0, .w = b.w * s, .x = b.x * s, .y = b.y * s, .z = b.z * s, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.y * wx - b.x * wy), .wxz = (b.z * wx - b.x * wz), .wyz = (b.z * wy - b.y * wz), .xyz = 0.0, .i = 0.0}; }
    constexpr Motor ProjectiveTranslator::wedge(const Bivector& b) const noexcept { return {.s = 0.0, .wx = b.wx * s, .wy = b.wy * s, .wz = b.wz * s, .xy = b.xy * s, .xz = b.xz * s, .yz = b.yz * s, .i = (b.xy * wz + b.yz * wx - b.xz * wy)}; }
    constexpr ProjectivePoint ProjectiveTranslator::wedge(const ProjectivePoint& b) const noexcept { return {.x = b.x * s, .y = b.y * s, .z = b.z * s, .w = b.w * s}; }
    constexpr Motor ProjectiveTranslator::wedge(const Quaternion& b) const noexcept { return {.s = b.s * s, .wx = b.s * wx, .wy = b.s * wy, .wz = b.s * wz, .xy = b.xy * s, .xz = b.xz * s, .yz = b.yz * s, .i = (b.xy * wz + b.yz * wx - b.xz * wy)}; }
    constexpr ProjectiveTranslator ProjectiveTranslator::wedge(const ProjectiveTranslator& b) const noexcept { return {.s = b.s * s, .wx = (b.s * wx + b.wx * s), .wy = (b.s * wy + b.wy * s), .wz = (b.s * wz + b.wz * s)}; }
    constexpr ProjectiveTranslator ProjectiveTranslator::wedge(const Translator& b) const noexcept { return {.s = s, .wx = (wx + b.wx * s), .wy = (wy + b.wy * s), .wz = (wz + b.wz * s)}; }
    constexpr Vector ProjectiveTranslator::wedge(const Vector& b) const noexcept { return {.x = b.x * s, .y = b.y * s, .z = b.z * s}; }
    constexpr ProjectivePoint ProjectiveTranslator::wedge(const Point& b) const noexcept { return {.x = b.x * s, .y = b.y * s, .z = b.z * s, .w = s}; }
    constexpr Multivector ProjectiveTranslator::wedge(const PlaneIdeal& b) const noexcept { return {.s = 0.0, .w = 0.0, .x = b.x * s, .y = b.y * s, .z = b.z * s, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.y * wx - b.x * wy), .wxz = (b.z * wx - b.x * wz), .wyz = (b.z * wy - b.y * wz), .xyz = 0.0, .i = 0.0}; }
    constexpr Motor ProjectiveTranslator::wedge(const BivectorBulk& b) const noexcept { return {.s = 0.0, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = b.xy * s, .xz = b.xz * s, .yz = b.yz * s, .i = (b.xy * wz + b.yz * wx - b.xz * wy)}; }
    constexpr BivectorWeight ProjectiveTranslator::wedge(const BivectorWeight& b) const noexcept { return {.wx = b.wx * s, .wy = b.wy * s, .wz = b.wz * s}; }
    constexpr PseudoScalar ProjectiveTranslator::wedge(const PseudoScalar& b) const noexcept { return {.i = b.i * s}; }
    constexpr ProjectivePoint ProjectiveTranslator::wedge(const PointCenter& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = s}; }

    constexpr Motor Translator::wedge(const Motor& b) const noexcept { return {.s = b.s, .wx = (b.wx + b.s * wx), .wy = (b.wy + b.s * wy), .wz = (b.wz + b.s * wz), .xy = b.xy, .xz = b.xz, .yz = b.yz, .i = (b.i + b.xy * wz + b.yz * wx - b.xz * wy)}; }
    constexpr Multivector Translator::wedge(const Plane& b) const noexcept { return {.s = 0.0, .w = b.w, .x = b.x, .y = b.y, .z = b.z, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.y * wx - b.x * wy), .wxz = (b.z * wx - b.x * wz), .wyz = (b.z * wy - b.y * wz), .xyz = 0.0, .i = 0.0}; }
    constexpr Motor Translator::wedge(const Bivector& b) const noexcept { return {.s = 0.0, .wx = b.wx, .wy = b.wy, .wz = b.wz, .xy = b.xy, .xz = b.xz, .yz = b.yz, .i = (b.xy * wz + b.yz * wx - b.xz * wy)}; }
    constexpr ProjectivePoint Translator::wedge(const ProjectivePoint& b) const noexcept { return {.x = b.x, .y = b.y, .z = b.z, .w = b.w}; }
    constexpr Motor Translator::wedge(const Quaternion& b) const noexcept { return {.s = b.s, .wx = b.s * wx, .wy = b.s * wy, .wz = b.s * wz, .xy = b.xy, .xz = b.xz, .yz = b.yz, .i = (b.xy * wz + b.yz * wx - b.xz * wy)}; }
    constexpr ProjectiveTranslator Translator::wedge(const ProjectiveTranslator& b) const noexcept { return {.s = b.s, .wx = (b.wx + b.s * wx), .wy = (b.wy + b.s * wy), .wz = (b.wz + b.s * wz)}; }
    constexpr Translator Translator::wedge(const Translator& b) const noexcept { return {.wx = (b.wx + wx), .wy = (b.wy + wy), .wz = (b.wz + wz)}; }
    constexpr Vector Translator::wedge(const Vector& b) const noexcept { return {.x = b.x, .y = b.y, .z = b.z}; }
    constexpr Point Translator::wedge(const Point& b) const noexcept { return {.x = b.x, .y = b.y, .z = b.z}; }
    constexpr Multivector Translator::wedge(const PlaneIdeal& b) const noexcept { return {.s = 0.0, .w = 0.0, .x = b.x, .y = b.y, .z = b.z, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.y * wx - b.x * wy), .wxz = (b.z * wx - b.x * wz), .wyz = (b.z * wy - b.y * wz), .xyz = 0.0, .i = 0.0}; }
    constexpr Motor Translator::wedge(const BivectorBulk& b) const noexcept { return {.s = 0.0, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = b.xy, .xz = b.xz, .yz = b.yz, .i = (b.xy * wz + b.yz * wx - b.xz * wy)}; }
    constexpr BivectorWeight Translator::wedge(const BivectorWeight& b) const noexcept { return {.wx = b.wx, .wy = b.wy, .wz = b.wz}; }
    constexpr PseudoScalar Translator::wedge(const PseudoScalar& b) const noexcept { return {.i = b.i}; }
    constexpr PointCenter Translator::wedge(const PointCenter& b) const noexcept { return {}; }

    constexpr Vector Vector::wedge(const Motor& b) const noexcept { return {.x = b.s * x, .y = b.s * y, .z = b.s * z}; }
    constexpr PseudoScalar Vector::wedge(const Plane& b) const noexcept { return {.i = (-b.x * x - b.y * y - b.z * z)}; }
    constexpr Vector Vector::wedge(const Quaternion& b) const noexcept { return {.x = b.s * x, .y = b.s * y, .z = b.s * z}; }
    constexpr Vector Vector::wedge(const ProjectiveTranslator& b) const noexcept { return {.x = b.s * x, .y = b.s * y, .z = b.s * z}; }
    constexpr Vector Vector::wedge(const Translator& b) const noexcept { return {.x = x, .y = y, .z = z}; }
    constexpr PseudoScalar Vector::wedge(const PlaneIdeal& b) const noexcept { return {.i = (-b.x * x - b.y * y - b.z * z)}; }

    constexpr ProjectivePoint Point::wedge(const Motor& b) const noexcept { return {.x = b.s * x, .y = b.s * y, .z = b.s * z, .w = b.s}; }
    constexpr PseudoScalar Point::wedge(const Plane& b) const noexcept { return {.i = (-b.w - b.x * x - b.y * y - b.z * z)}; }
    constexpr ProjectivePoint Point::wedge(const Quaternion& b) const noexcept { return {.x = b.s * x, .y = b.s * y, .z = b.s * z, .w = b.s}; }
    constexpr ProjectivePoint Point::wedge(const ProjectiveTranslator& b) const noexcept { return {.x = b.s * x, .y = b.s * y, .z = b.s * z, .w = b.s}; }
    constexpr Point Point::wedge(const Translator& b) const noexcept { return {.x = x, .y = y, .z = z}; }
    constexpr PseudoScalar Point::wedge(const PlaneIdeal& b) const noexcept { return {.i = (-b.x * x - b.y * y - b.z * z)}; }

    constexpr Multivector PlaneIdeal::wedge(const Motor& b) const noexcept { return {.s = 0.0, .w = 0.0, .x = b.s * x, .y = b.s * y, .z = b.s * z, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.wx * y - b.wy * x), .wxz = (b.wx * z - b.wz * x), .wyz = (b.wy * z - b.wz * y), .xyz = (b.xy * z + b.yz * x - b.xz * y), .i = 0.0}; }
    constexpr Bivector PlaneIdeal::wedge(const Plane& b) const noexcept { return {.wx = -b.w * x, .wy = -b.w * y, .wz = -b.w * z, .xy = (b.y * x - b.x * y), .xz = (b.z * x - b.x * z), .yz = (b.z * y - b.y * z)}; }
    constexpr ProjectivePoint PlaneIdeal::wedge(const Bivector& b) const noexcept { return {.x = (b.wz * y - b.wy * z), .y = (b.wx * z - b.wz * x), .z = (b.wy * x - b.wx * y), .w = (b.xy * z + b.yz * x - b.xz * y)}; }
    constexpr PseudoScalar PlaneIdeal::wedge(const ProjectivePoint& b) const noexcept { return {.i = (b.x * x + b.y * y + b.z * z)}; }
    constexpr Multivector PlaneIdeal::wedge(const Quaternion& b) const noexcept { return {.s = 0.0, .w = 0.0, .x = b.s * x, .y = b.s * y, .z = b.s * z, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = 0.0, .wxz = 0.0, .wyz = 0.0, .xyz = (b.xy * z + b.yz * x - b.xz * y), .i = 0.0}; }
    constexpr Multivector PlaneIdeal::wedge(const ProjectiveTranslator& b) const noexcept { return {.s = 0.0, .w = 0.0, .x = b.s * x, .y = b.s * y, .z = b.s * z, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.wx * y - b.wy * x), .wxz = (b.wx * z - b.wz * x), .wyz = (b.wy * z - b.wz * y), .xyz = 0.0, .i = 0.0}; }
    constexpr Multivector PlaneIdeal::wedge(const Translator& b) const noexcept { return {.s = 0.0, .w = 0.0, .x = x, .y = y, .z = z, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.wx * y - b.wy * x), .wxz = (b.wx * z - b.wz * x), .wyz = (b.wy * z - b.wz * y), .xyz = 0.0, .i = 0.0}; }
    constexpr PseudoScalar PlaneIdeal::wedge(const Vector& b) const noexcept { return {.i = (b.x * x + b.y * y + b.z * z)}; }
    constexpr PseudoScalar PlaneIdeal::wedge(const Point& b) const noexcept { return {.i = (b.x * x + b.y * y + b.z * z)}; }
    constexpr BivectorBulk PlaneIdeal::wedge(const PlaneIdeal& b) const noexcept { return {.xy = (b.y * x - b.x * y), .xz = (b.z * x - b.x * z), .yz = (b.z * y - b.y * z)}; }
    constexpr ProjectivePoint PlaneIdeal::wedge(const BivectorBulk& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = (b.xy * z + b.yz * x - b.xz * y)}; }
    constexpr Vector PlaneIdeal::wedge(const BivectorWeight& b) const noexcept { return {.x = (b.wz * y - b.wy * z), .y = (b.wx * z - b.wz * x), .z = (b.wy * x - b.wx * y)}; }

    constexpr Motor BivectorBulk::wedge(const Motor& b) const noexcept { return {.s = 0.0, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = b.s * xy, .xz = b.s * xz, .yz = b.s * yz, .i = (b.wx * yz + b.wz * xy - b.wy * xz)}; }
    constexpr ProjectivePoint BivectorBulk::wedge(const Plane& b) const noexcept { return {.x = -b.w * yz, .y = b.w * xz, .z = -b.w * xy, .w = (b.x * yz + b.z * xy - b.y * xz)}; }
    constexpr PseudoScalar BivectorBulk::wedge(const Bivector& b) const noexcept { return {.i = (b.wx * yz + b.wz * xy - b.wy * xz)}; }
    constexpr BivectorBulk BivectorBulk::wedge(const Quaternion& b) const noexcept { return {.xy = b.s * xy, .xz = b.s * xz, .yz = b.s * yz}; }
    constexpr Motor BivectorBulk::wedge(const ProjectiveTranslator& b) const noexcept { return {.s = 0.0, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = b.s * xy, .xz = b.s * xz, .yz = b.s * yz, .i = (b.wx * yz + b.wz * xy - b.wy * xz)}; }
    constexpr Motor BivectorBulk::wedge(const Translator& b) const noexcept { return {.s = 0.0, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = xy, .xz = xz, .yz = yz, .i = (b.wx * yz + b.wz * xy - b.wy * xz)}; }
    constexpr ProjectivePoint BivectorBulk::wedge(const PlaneIdeal& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = (b.x * yz + b.z * xy - b.y * xz)}; }
    constexpr PseudoScalar BivectorBulk::wedge(const BivectorWeight& b) const noexcept { return {.i = (b.wx * yz + b.wz * xy - b.wy * xz)}; }

    constexpr Motor BivectorWeight::wedge(const Motor& b) const noexcept { return {.s = 0.0, .wx = b.s * wx, .wy = b.s * wy, .wz = b.s * wz, .xy = 0.0, .xz = 0.0, .yz = 0.0, .i = (b.xy * wz + b.yz * wx - b.xz * wy)}; }
    constexpr Vector BivectorWeight::wedge(const Plane& b) const noexcept { return {.x = (b.y * wz - b.z * wy), .y = (b.z * wx - b.x * wz), .z = (b.x * wy - b.y * wx)}; }
    constexpr PseudoScalar BivectorWeight::wedge(const Bivector& b) const noexcept { return {.i = (b.xy * wz + b.yz * wx - b.xz * wy)}; }
    constexpr Motor BivectorWeight::wedge(const Quaternion& b) const noexcept { return {.s = 0.0, .wx = b.s * wx, .wy = b.s * wy, .wz = b.s * wz, .xy = 0.0, .xz = 0.0, .yz = 0.0, .i = (b.xy * wz + b.yz * wx - b.xz * wy)}; }
    constexpr BivectorWeight BivectorWeight::wedge(const ProjectiveTranslator& b) const noexcept { return {.wx = b.s * wx, .wy = b.s * wy, .wz = b.s * wz}; }
    constexpr BivectorWeight BivectorWeight::wedge(const Translator& b) const noexcept { return {.wx = wx, .wy = wy, .wz = wz}; }
    constexpr Vector BivectorWeight::wedge(const PlaneIdeal& b) const noexcept { return {.x = (b.y * wz - b.z * wy), .y = (b.z * wx - b.x * wz), .z = (b.x * wy - b.y * wx)}; }
    constexpr PseudoScalar BivectorWeight::wedge(const BivectorBulk& b) const noexcept { return {.i = (b.xy * wz + b.yz * wx - b.xz * wy)}; }

    constexpr PseudoScalar PseudoScalar::wedge(const Motor& b) const noexcept { return {.i = b.s * i}; }
    constexpr PseudoScalar PseudoScalar::wedge(const Quaternion& b) const noexcept { return {.i = b.s * i}; }
    constexpr PseudoScalar PseudoScalar::wedge(const ProjectiveTranslator& b) const noexcept { return {.i = b.s * i}; }
    constexpr PseudoScalar PseudoScalar::wedge(const Translator& b) const noexcept { return {.i = i}; }

    constexpr ProjectivePoint PointCenter::wedge(const Motor& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = b.s}; }
    constexpr PseudoScalar PointCenter::wedge(const Plane& b) const noexcept { return {.i = -b.w}; }
    constexpr ProjectivePoint PointCenter::wedge(const Quaternion& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = b.s}; }
    constexpr ProjectivePoint PointCenter::wedge(const ProjectiveTranslator& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = b.s}; }
    constexpr PointCenter PointCenter::wedge(const Translator& b) const noexcept { return {}; }

}

// opsAntiWedge.h

// generated by com.github.kright.pga3d.codegen.cpp.ops.AntiWedgeOpGenerator

namespace pga3d {
    constexpr Multivector Multivector::antiWedge(const Multivector& b) const noexcept { return {.s = (b.i * s + b.s * i + b.w * xyz + b.wx * yz + b.wxy * z + b.wyz * x + b.wz * xy + b.xy * wz + b.y * wxz + b.yz * wx - b.wxz * y - b.wy * xz - b.x * wyz - b.xyz * w - b.xz * wy - b.z * wxy), .w = (b.i * w + b.w * i + b.wxz * wy + b.wy * wxz - b.wx * wyz - b.wxy * wz - b.wyz * wx - b.wz * wxy), .x = (b.i * x + b.wxz * xy + b.x * i + b.xy * wxz - b.wx * xyz - b.wxy * xz - b.xyz * wx - b.xz * wxy), .y = (b.i * y + b.wyz * xy + b.xy * wyz + b.y * i - b.wxy * yz - b.wy * xyz - b.xyz * wy - b.yz * wxy), .z = (b.i * z + b.wyz * xz + b.xz * wyz + b.z * i - b.wxz * yz - b.wz * xyz - b.xyz * wz - b.yz * wxz), .wx = (b.i * wx + b.wx * i + b.wxz * wxy - b.wxy * wxz), .wy = (b.i * wy + b.wy * i + b.wyz * wxy - b.wxy * wyz), .wz = (b.i * wz + b.wyz * wxz + b.wz * i - b.wxz * wyz), .xy = (b.i * xy + b.xy * i + b.xyz * wxy - b.wxy * xyz), .xz = (b.i * xz + b.xyz * wxz + b.xz * i - b.wxz * xyz), .yz = (b.i * yz + b.xyz * wyz + b.yz * i - b.wyz * xyz), .wxy = (b.i * wxy + b.wxy * i), .wxz = (b.i * wxz + b.wxz * i), .wyz = (b.i * wyz + b.wyz * i), .xyz = (b.i * xyz + b.xyz * i), .i = b.i * i}; }

    constexpr Motor Motor::antiWedge(const Motor& b) const noexcept { return {.s = (b.i * s + b.s * i + b.wx * yz + b.wz * xy + b.xy * wz + b.yz * wx - b.wy * xz - b.xz * wy), .wx = (b.i * wx + b.wx * i), .wy = (b.i * wy + b.wy * i), .wz = (b.i * wz + b.wz * i), .xy = (b.i * xy + b.xy * i), .xz = (b.i * xz + b.xz * i), .yz = (b.i * yz + b.yz * i), .i = b.i * i}; }
    constexpr Plane Motor::antiWedge(const Plane& b) const noexcept { return {.x = b.x * i, .y = b.y * i, .z = b.z * i, .w = b.w * i}; }
    constexpr Motor Motor::antiWedge(const Bivector& b) const noexcept { return {.s = (b.wx * yz + b.wz * xy + b.xy * wz + b.yz * wx - b.wy * xz - b.xz * wy), .wx = b.wx * i, .wy = b.wy * i, .wz = b.wz * i, .xy = b.xy * i, .xz = b.xz * i, .yz = b.yz * i, .i = 0.0}; }
    constexpr Multivector Motor::antiWedge(const ProjectivePoint& b) const noexcept { return {.s = 0.0, .w = (b.x * wx + b.y * wy + b.z * wz), .x = (b.y * xy + b.z * xz - b.w * wx), .y = (b.z * yz - b.w * wy - b.x * xy), .z = (-b.w * wz - b.x * xz - b.y * yz), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = -b.z * i, .wxz = b.y * i, .wyz = -b.x * i, .xyz = b.w * i, .i = 0.0}; }
    constexpr Quaternion Motor::antiWedge(const Quaternion& b) const noexcept { return {.s = (b.s * i + b.xy * wz + b.yz * wx - b.xz * wy), .xy = b.xy * i, .xz = b.xz * i, .yz = b.yz * i}; }
    constexpr ProjectiveTranslator Motor::antiWedge(const ProjectiveTranslator& b) const noexcept { return {.s = (b.s * i + b.wx * yz + b.wz * xy - b.wy * xz), .wx = b.wx * i, .wy = b.wy * i, .wz = b.wz * i}; }
    constexpr ProjectiveTranslator Motor::antiWedge(const Translator& b) const noexcept { return {.s = (i + b.wx * yz + b.wz * xy - b.wy * xz), .wx = b.wx * i, .wy = b.wy * i, .wz = b.wz * i}; }
    constexpr Multivector Motor::antiWedge(const Vector& b) const noexcept { return {.s = 0.0, .w = (b.x * wx + b.y * wy + b.z * wz), .x = (b.y * xy + b.z * xz), .y = (b.z * yz - b.x * xy), .z = (-b.x * xz - b.y * yz), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = -b.z * i, .wxz = b.y * i, .wyz = -b.x * i, .xyz = 0.0, .i = 0.0}; }
    constexpr Multivector Motor::antiWedge(const Point& b) const noexcept { return {.s = 0.0, .w = (b.x * wx + b.y * wy + b.z * wz), .x = (-wx + b.y * xy + b.z * xz), .y = (-wy + b.z * yz - b.x * xy), .z = (-wz - b.x * xz - b.y * yz), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = -b.z * i, .wxz = b.y * i, .wyz = -b.x * i, .xyz = i, .i = 0.0}; }
    constexpr PlaneIdeal Motor::antiWedge(const PlaneIdeal& b) const noexcept { return {.x = b.x * i, .y = b.y * i, .z = b.z * i}; }
    constexpr Quaternion Motor::antiWedge(const BivectorBulk& b) const noexcept { return {.s = (b.xy * wz + b.yz * wx - b.xz * wy), .xy = b.xy * i, .xz = b.xz * i, .yz = b.yz * i}; }
    constexpr ProjectiveTranslator Motor::antiWedge(const BivectorWeight& b) const noexcept { return {.s = (b.wx * yz + b.wz * xy - b.wy * xz), .wx = b.wx * i, .wy = b.wy * i, .wz = b.wz * i}; }
    constexpr Motor Motor::antiWedge(const PseudoScalar& b) const noexcept { return {.s = b.i * s, .wx = b.i * wx, .wy = b.i * wy, .wz = b.i * wz, .xy = b.i * xy, .xz = b.i * xz, .yz = b.i * yz, .i = b.i * i}; }
    constexpr Multivector Motor::antiWedge(const PointCenter& b) const noexcept { return {.s = 0.0, .w = 0.0, .x = -wx, .y = -wy, .z = -wz, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = 0.0, .wxz = 0.0, .wyz = 0.0, .xyz = i, .i = 0.0}; }

    constexpr Plane Plane::antiWedge(const Motor& b) const noexcept { return {.x = b.i * x, .y = b.i * y, .z = b.i * z, .w = b.i * w}; }
    constexpr double Plane::antiWedge(const ProjectivePoint& b) const noexcept { return (-b.w * w - b.x * x - b.y * y - b.z * z); }
    constexpr double Plane::antiWedge(const Vector& b) const noexcept { return (-b.x * x - b.y * y - b.z * z); }
    constexpr double Plane::antiWedge(const Point& b) const noexcept { return (-w - b.x * x - b.y * y - b.z * z); }
    constexpr Plane Plane::antiWedge(const PseudoScalar& b) const noexcept { return {.x = b.i * x, .y = b.i * y, .z = b.i * z, .w = b.i * w}; }
    constexpr double Plane::antiWedge(const PointCenter& b) const noexcept { return -w; }

    constexpr Motor Bivector::antiWedge(const Motor& b) const noexcept { return {.s = (b.wx * yz + b.wz * xy + b.xy * wz + b.yz * wx - b.wy * xz - b.xz * wy), .wx = b.i * wx, .wy = b.i * wy, .wz = b.i * wz, .xy = b.i * xy, .xz = b.i * xz, .yz = b.i * yz, .i = 0.0}; }
    constexpr double Bivector::antiWedge(const Bivector& b) const noexcept { return (b.wx * yz + b.wz * xy + b.xy * wz + b.yz * wx - b.wy * xz - b.xz * wy); }
    constexpr Plane Bivector::antiWedge(const ProjectivePoint& b) const noexcept { return {.x = (b.y * xy + b.z * xz - b.w * wx), .y = (b.z * yz - b.w * wy - b.x * xy), .z = (-b.w * wz - b.x * xz - b.y * yz), .w = (b.x * wx + b.y * wy + b.z * wz)}; }
    constexpr double Bivector::antiWedge(const Quaternion& b) const noexcept { return (b.xy * wz + b.yz * wx - b.xz * wy); }
    constexpr double Bivector::antiWedge(const ProjectiveTranslator& b) const noexcept { return (b.wx * yz + b.wz * xy - b.wy * xz); }
    constexpr double Bivector::antiWedge(const Translator& b) const noexcept { return (b.wx * yz + b.wz * xy - b.wy * xz); }
    constexpr Plane Bivector::antiWedge(const Vector& b) const noexcept { return {.x = (b.y * xy + b.z * xz), .y = (b.z * yz - b.x * xy), .z = (-b.x * xz - b.y * yz), .w = (b.x * wx + b.y * wy + b.z * wz)}; }
    constexpr Plane Bivector::antiWedge(const Point& b) const noexcept { return {.x = (-wx + b.y * xy + b.z * xz), .y = (-wy + b.z * yz - b.x * xy), .z = (-wz - b.x * xz - b.y * yz), .w = (b.x * wx + b.y * wy + b.z * wz)}; }
    constexpr double Bivector::antiWedge(const BivectorBulk& b) const noexcept { return (b.xy * wz + b.yz * wx - b.xz * wy); }
    constexpr double Bivector::antiWedge(const BivectorWeight& b) const noexcept { return (b.wx * yz + b.wz * xy - b.wy * xz); }
    constexpr Bivector Bivector::antiWedge(const PseudoScalar& b) const noexcept { return {.wx = b.i * wx, .wy = b.i * wy, .wz = b.i * wz, .xy = b.i * xy, .xz = b.i * xz, .yz = b.i * yz}; }
    constexpr PlaneIdeal Bivector::antiWedge(const PointCenter& b) const noexcept { return {.x = -wx, .y = -wy, .z = -wz}; }

    constexpr Multivector ProjectivePoint::antiWedge(const Motor& b) const noexcept { return {.s = 0.0, .w = (b.wx * x + b.wy * y + b.wz * z), .x = (b.xy * y + b.xz * z - b.wx * w), .y = (b.yz * z - b.wy * w - b.xy * x), .z = (-b.wz * w - b.xz * x - b.yz * y), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = -b.i * z, .wxz = b.i * y, .wyz = -b.i * x, .xyz = b.i * w, .i = 0.0}; }
    constexpr double ProjectivePoint::antiWedge(const Plane& b) const noexcept { return (b.w * w + b.x * x + b.y * y + b.z * z); }
    constexpr Plane ProjectivePoint::antiWedge(const Bivector& b) const noexcept { return {.x = (b.xy * y + b.xz * z - b.wx * w), .y = (b.yz * z - b.wy * w - b.xy * x), .z = (-b.wz * w - b.xz * x - b.yz * y), .w = (b.wx * x + b.wy * y + b.wz * z)}; }
    constexpr Bivector ProjectivePoint::antiWedge(const ProjectivePoint& b) const noexcept { return {.wx = (b.z * y - b.y * z), .wy = (b.x * z - b.z * x), .wz = (b.y * x - b.x * y), .xy = (b.z * w - b.w * z), .xz = (b.w * y - b.y * w), .yz = (b.x * w - b.w * x)}; }
    constexpr PlaneIdeal ProjectivePoint::antiWedge(const Quaternion& b) const noexcept { return {.x = (b.xy * y + b.xz * z), .y = (b.yz * z - b.xy * x), .z = (-b.xz * x - b.yz * y)}; }
    constexpr Plane ProjectivePoint::antiWedge(const ProjectiveTranslator& b) const noexcept { return {.x = -b.wx * w, .y = -b.wy * w, .z = -b.wz * w, .w = (b.wx * x + b.wy * y + b.wz * z)}; }
    constexpr Plane ProjectivePoint::antiWedge(const Translator& b) const noexcept { return {.x = -b.wx * w, .y = -b.wy * w, .z = -b.wz * w, .w = (b.wx * x + b.wy * y + b.wz * z)}; }
    constexpr Bivector ProjectivePoint::antiWedge(const Vector& b) const noexcept { return {.wx = (b.z * y - b.y * z), .wy = (b.x * z - b.z * x), .wz = (b.y * x - b.x * y), .xy = b.z * w, .xz = -b.y * w, .yz = b.x * w}; }
    constexpr Bivector ProjectivePoint::antiWedge(const Point& b) const noexcept { return {.wx = (b.z * y - b.y * z), .wy = (b.x * z - b.z * x), .wz = (b.y * x - b.x * y), .xy = (-z + b.z * w), .xz = (y - b.y * w), .yz = (-x + b.x * w)}; }
    constexpr double ProjectivePoint::antiWedge(const PlaneIdeal& b) const noexcept { return (b.x * x + b.y * y + b.z * z); }
    constexpr PlaneIdeal ProjectivePoint::antiWedge(const BivectorBulk& b) const noexcept { return {.x = (b.xy * y + b.xz * z), .y = (b.yz * z - b.xy * x), .z = (-b.xz * x - b.yz * y)}; }
    constexpr Plane ProjectivePoint::antiWedge(const BivectorWeight& b) const noexcept { return {.x = -b.wx * w, .y = -b.wy * w, .z = -b.wz * w, .w = (b.wx * x + b.wy * y + b.wz * z)}; }
    constexpr ProjectivePoint ProjectivePoint::antiWedge(const PseudoScalar& b) const noexcept { return {.x = b.i * x, .y = b.i * y, .z = b.i * z, .w = b.i * w}; }
    constexpr BivectorBulk ProjectivePoint::antiWedge(const PointCenter& b) const noexcept { return {.xy = -z, .xz = y, .yz = -x}; }

    constexpr Quaternion Quaternion::antiWedge(const Motor& b) const noexcept { return {.s = (b.i * s + b.wx * yz + b.wz * xy - b.wy * xz), .xy = b.i * xy, .xz = b.i * xz, .yz = b.i * yz}; }
    constexpr double Quaternion::antiWedge(const Bivector& b) const noexcept { return (b.wx * yz + b.wz * xy - b.wy * xz); }
    constexpr PlaneIdeal Quaternion::antiWedge(const ProjectivePoint& b) const noexcept { return {.x = (b.y * xy + b.z * xz), .y = (b.z * yz - b.x * xy), .z = (-b.x * xz - b.y * yz)}; }
    constexpr double Quaternion::antiWedge(const ProjectiveTranslator& b) const noexcept { return (b.wx * yz + b.wz * xy - b.wy * xz); }
    constexpr double Quaternion::antiWedge(const Translator& b) const noexcept { return (b.wx * yz + b.wz * xy - b.wy * xz); }
    constexpr PlaneIdeal Quaternion::antiWedge(const Vector& b) const noexcept { return {.x = (b.y * xy + b.z * xz), .y = (b.z * yz - b.x * xy), .z = (-b.x * xz - b.y * yz)}; }
    constexpr PlaneIdeal Quaternion::antiWedge(const Point& b) const noexcept { return {.x = (b.y * xy + b.z * xz), .y = (b.z * yz - b.x * xy), .z = (-b.x * xz - b.y * yz)}; }
    constexpr double Quaternion::antiWedge(const BivectorWeight& b) const noexcept { return (b.wx * yz + b.wz * xy - b.wy * xz); }
    constexpr Quaternion Quaternion::antiWedge(const PseudoScalar& b) const noexcept { return {.s = b.i * s, .xy = b.i * xy, .xz = b.i * xz, .yz = b.i * yz}; }

    constexpr ProjectiveTranslator ProjectiveTranslator::antiWedge(const Motor& b) const noexcept { return {.s = (b.i * s + b.xy * wz + b.yz * wx - b.xz * wy), .wx = b.i * wx, .wy = b.i * wy, .wz = b.i * wz}; }
    constexpr double ProjectiveTranslator::antiWedge(const Bivector& b) const noexcept { return (b.xy * wz + b.yz * wx - b.xz * wy); }
    constexpr Plane ProjectiveTranslator::antiWedge(const ProjectivePoint& b) const noexcept { return {.x = -b.w * wx, .y = -b.w * wy, .z = -b.w * wz, .w = (b.x * wx + b.y * wy + b.z * wz)}; }
    constexpr double ProjectiveTranslator::antiWedge(const Quaternion& b) const noexcept { return (b.xy * wz + b.yz * wx - b.xz * wy); }
    constexpr Plane ProjectiveTranslator::antiWedge(const Vector& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = (b.x * wx + b.y * wy + b.z * wz)}; }
    constexpr Plane ProjectiveTranslator::antiWedge(const Point& b) const noexcept { return {.x = -wx, .y = -wy, .z = -wz, .w = (b.x * wx + b.y * wy + b.z * wz)}; }
    constexpr double ProjectiveTranslator::antiWedge(const BivectorBulk& b) const noexcept { return (b.xy * wz + b.yz * wx - b.xz * wy); }
    constexpr ProjectiveTranslator ProjectiveTranslator::antiWedge(const PseudoScalar& b) const noexcept { return {.s = b.i * s, .wx = b.i * wx, .wy = b.i * wy, .wz = b.i * wz}; }
    constexpr PlaneIdeal ProjectiveTranslator::antiWedge(const PointCenter& b) const noexcept { return {.x = -wx, .y = -wy, .z = -wz}; }

    constexpr ProjectiveTranslator Translator::antiWedge(const Motor& b) const noexcept { return {.s = (b.i + b.xy * wz + b.yz * wx - b.xz * wy), .wx = b.i * wx, .wy = b.i * wy, .wz = b.i * wz}; }
    constexpr double Translator::antiWedge(const Bivector& b) const noexcept { return (b.xy * wz + b.yz * wx - b.xz * wy); }
    constexpr Plane Translator::antiWedge(const ProjectivePoint& b) const noexcept { return {.x = -b.w * wx, .y = -b.w * wy, .z = -b.w * wz, .w = (b.x * wx + b.y * wy + b.z * wz)}; }
    constexpr double Translator::antiWedge(const Quaternion& b) const noexcept { return (b.xy * wz + b.yz * wx - b.xz * wy); }
    constexpr Plane Translator::antiWedge(const Vector& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = (b.x * wx + b.y * wy + b.z * wz)}; }
    constexpr Plane Translator::antiWedge(const Point& b) const noexcept { return {.x = -wx, .y = -wy, .z = -wz, .w = (b.x * wx + b.y * wy + b.z * wz)}; }
    constexpr double Translator::antiWedge(const BivectorBulk& b) const noexcept { return (b.xy * wz + b.yz * wx - b.xz * wy); }
    constexpr ProjectiveTranslator Translator::antiWedge(const PseudoScalar& b) const noexcept { return {.s = b.i, .wx = b.i * wx, .wy = b.i * wy, .wz = b.i * wz}; }
    constexpr PlaneIdeal Translator::antiWedge(const PointCenter& b) const noexcept { return {.x = -wx, .y = -wy, .z = -wz}; }

    constexpr Multivector Vector::antiWedge(const Motor& b) const noexcept { return {.s = 0.0, .w = (b.wx * x + b.wy * y + b.wz * z), .x = (b.xy * y + b.xz * z), .y = (b.yz * z - b.xy * x), .z = (-b.xz * x - b.yz * y), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = -b.i * z, .wxz = b.i * y, .wyz = -b.i * x, .xyz = 0.0, .i = 0.0}; }
    constexpr double Vector::antiWedge(const Plane& b) const noexcept { return (b.x * x + b.y * y + b.z * z); }
    constexpr Plane Vector::antiWedge(const Bivector& b) const noexcept { return {.x = (b.xy * y + b.xz * z), .y = (b.yz * z - b.xy * x), .z = (-b.xz * x - b.yz * y), .w = (b.wx * x + b.wy * y + b.wz * z)}; }
    constexpr Bivector Vector::antiWedge(const ProjectivePoint& b) const noexcept { return {.wx = (b.z * y - b.y * z), .wy = (b.x * z - b.z * x), .wz = (b.y * x - b.x * y), .xy = -b.w * z, .xz = b.w * y, .yz = -b.w * x}; }
    constexpr PlaneIdeal Vector::antiWedge(const Quaternion& b) const noexcept { return {.x = (b.xy * y + b.xz * z), .y = (b.yz * z - b.xy * x), .z = (-b.xz * x - b.yz * y)}; }
    constexpr Plane Vector::antiWedge(const ProjectiveTranslator& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = (b.wx * x + b.wy * y + b.wz * z)}; }
    constexpr Plane Vector::antiWedge(const Translator& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = (b.wx * x + b.wy * y + b.wz * z)}; }
    constexpr BivectorWeight Vector::antiWedge(const Vector& b) const noexcept { return {.wx = (b.z * y - b.y * z), .wy = (b.x * z - b.z * x), .wz = (b.y * x - b.x * y)}; }
    constexpr Bivector Vector::antiWedge(const Point& b) const noexcept { return {.wx = (b.z * y - b.y * z), .wy = (b.x * z - b.z * x), .wz = (b.y * x - b.x * y), .xy = -z, .xz = y, .yz = -x}; }
    constexpr double Vector::antiWedge(const PlaneIdeal& b) const noexcept { return (b.x * x + b.y * y + b.z * z); }
    constexpr PlaneIdeal Vector::antiWedge(const BivectorBulk& b) const noexcept { return {.x = (b.xy * y + b.xz * z), .y = (b.yz * z - b.xy * x), .z = (-b.xz * x - b.yz * y)}; }
    constexpr Plane Vector::antiWedge(const BivectorWeight& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = (b.wx * x + b.wy * y + b.wz * z)}; }
    constexpr Vector Vector::antiWedge(const PseudoScalar& b) const noexcept { return {.x = b.i * x, .y = b.i * y, .z = b.i * z}; }
    constexpr BivectorBulk Vector::antiWedge(const PointCenter& b) const noexcept { return {.xy = -z, .xz = y, .yz = -x}; }

    constexpr Multivector Point::antiWedge(const Motor& b) const noexcept { return {.s = 0.0, .w = (b.wx * x + b.wy * y + b.wz * z), .x = (-b.wx + b.xy * y + b.xz * z), .y = (-b.wy + b.yz * z - b.xy * x), .z = (-b.wz - b.xz * x - b.yz * y), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = -b.i * z, .wxz = b.i * y, .wyz = -b.i * x, .xyz = b.i, .i = 0.0}; }
    constexpr double Point::antiWedge(const Plane& b) const noexcept { return (b.w + b.x * x + b.y * y + b.z * z); }
    constexpr Plane Point::antiWedge(const Bivector& b) const noexcept { return {.x = (-b.wx + b.xy * y + b.xz * z), .y = (-b.wy + b.yz * z - b.xy * x), .z = (-b.wz - b.xz * x - b.yz * y), .w = (b.wx * x + b.wy * y + b.wz * z)}; }
    constexpr Bivector Point::antiWedge(const ProjectivePoint& b) const noexcept { return {.wx = (b.z * y - b.y * z), .wy = (b.x * z - b.z * x), .wz = (b.y * x - b.x * y), .xy = (b.z - b.w * z), .xz = (-b.y + b.w * y), .yz = (b.x - b.w * x)}; }
    constexpr PlaneIdeal Point::antiWedge(const Quaternion& b) const noexcept { return {.x = (b.xy * y + b.xz * z), .y = (b.yz * z - b.xy * x), .z = (-b.xz * x - b.yz * y)}; }
    constexpr Plane Point::antiWedge(const ProjectiveTranslator& b) const noexcept { return {.x = -b.wx, .y = -b.wy, .z = -b.wz, .w = (b.wx * x + b.wy * y + b.wz * z)}; }
    constexpr Plane Point::antiWedge(const Translator& b) const noexcept { return {.x = -b.wx, .y = -b.wy, .z = -b.wz, .w = (b.wx * x + b.wy * y + b.wz * z)}; }
    constexpr Bivector Point::antiWedge(const Vector& b) const noexcept { return {.wx = (b.z * y - b.y * z), .wy = (b.x * z - b.z * x), .wz = (b.y * x - b.x * y), .xy = b.z, .xz = -b.y, .yz = b.x}; }
    constexpr Bivector Point::antiWedge(const Point& b) const noexcept { return {.wx = (b.z * y - b.y * z), .wy = (b.x * z - b.z * x), .wz = (b.y * x - b.x * y), .xy = (b.z - z), .xz = (y - b.y), .yz = (b.x - x)}; }
    constexpr double Point::antiWedge(const PlaneIdeal& b) const noexcept { return (b.x * x + b.y * y + b.z * z); }
    constexpr PlaneIdeal Point::antiWedge(const BivectorBulk& b) const noexcept { return {.x = (b.xy * y + b.xz * z), .y = (b.yz * z - b.xy * x), .z = (-b.xz * x - b.yz * y)}; }
    constexpr Plane Point::antiWedge(const BivectorWeight& b) const noexcept { return {.x = -b.wx, .y = -b.wy, .z = -b.wz, .w = (b.wx * x + b.wy * y + b.wz * z)}; }
    constexpr ProjectivePoint Point::antiWedge(const PseudoScalar& b) const noexcept { return {.x = b.i * x, .y = b.i * y, .z = b.i * z, .w = b.i}; }
    constexpr BivectorBulk Point::antiWedge(const PointCenter& b) const noexcept { return {.xy = -z, .xz = y, .yz = -x}; }

    constexpr PlaneIdeal PlaneIdeal::antiWedge(const Motor& b) const noexcept { return {.x = b.i * x, .y = b.i * y, .z = b.i * z}; }
    constexpr double PlaneIdeal::antiWedge(const ProjectivePoint& b) const noexcept { return (-b.x * x - b.y * y - b.z * z); }
    constexpr double PlaneIdeal::antiWedge(const Vector& b) const noexcept { return (-b.x * x - b.y * y - b.z * z); }
    constexpr double PlaneIdeal::antiWedge(const Point& b) const noexcept { return (-b.x * x - b.y * y - b.z * z); }
    constexpr PlaneIdeal PlaneIdeal::antiWedge(const PseudoScalar& b) const noexcept { return {.x = b.i * x, .y = b.i * y, .z = b.i * z}; }

    constexpr Quaternion BivectorBulk::antiWedge(const Motor& b) const noexcept { return {.s = (b.wx * yz + b.wz * xy - b.wy * xz), .xy = b.i * xy, .xz = b.i * xz, .yz = b.i * yz}; }
    constexpr double BivectorBulk::antiWedge(const Bivector& b) const noexcept { return (b.wx * yz + b.wz * xy - b.wy * xz); }
    constexpr PlaneIdeal BivectorBulk::antiWedge(const ProjectivePoint& b) const noexcept { return {.x = (b.y * xy + b.z * xz), .y = (b.z * yz - b.x * xy), .z = (-b.x * xz - b.y * yz)}; }
    constexpr double BivectorBulk::antiWedge(const ProjectiveTranslator& b) const noexcept { return (b.wx * yz + b.wz * xy - b.wy * xz); }
    constexpr double BivectorBulk::antiWedge(const Translator& b) const noexcept { return (b.wx * yz + b.wz * xy - b.wy * xz); }
    constexpr PlaneIdeal BivectorBulk::antiWedge(const Vector& b) const noexcept { return {.x = (b.y * xy + b.z * xz), .y = (b.z * yz - b.x * xy), .z = (-b.x * xz - b.y * yz)}; }
    constexpr PlaneIdeal BivectorBulk::antiWedge(const Point& b) const noexcept { return {.x = (b.y * xy + b.z * xz), .y = (b.z * yz - b.x * xy), .z = (-b.x * xz - b.y * yz)}; }
    constexpr double BivectorBulk::antiWedge(const BivectorWeight& b) const noexcept { return (b.wx * yz + b.wz * xy - b.wy * xz); }
    constexpr BivectorBulk BivectorBulk::antiWedge(const PseudoScalar& b) const noexcept { return {.xy = b.i * xy, .xz = b.i * xz, .yz = b.i * yz}; }

    constexpr ProjectiveTranslator BivectorWeight::antiWedge(const Motor& b) const noexcept { return {.s = (b.xy * wz + b.yz * wx - b.xz * wy), .wx = b.i * wx, .wy = b.i * wy, .wz = b.i * wz}; }
    constexpr double BivectorWeight::antiWedge(const Bivector& b) const noexcept { return (b.xy * wz + b.yz * wx - b.xz * wy); }
    constexpr Plane BivectorWeight::antiWedge(const ProjectivePoint& b) const noexcept { return {.x = -b.w * wx, .y = -b.w * wy, .z = -b.w * wz, .w = (b.x * wx + b.y * wy + b.z * wz)}; }
    constexpr double BivectorWeight::antiWedge(const Quaternion& b) const noexcept { return (b.xy * wz + b.yz * wx - b.xz * wy); }
    constexpr Plane BivectorWeight::antiWedge(const Vector& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = (b.x * wx + b.y * wy + b.z * wz)}; }
    constexpr Plane BivectorWeight::antiWedge(const Point& b) const noexcept { return {.x = -wx, .y = -wy, .z = -wz, .w = (b.x * wx + b.y * wy + b.z * wz)}; }
    constexpr double BivectorWeight::antiWedge(const BivectorBulk& b) const noexcept { return (b.xy * wz + b.yz * wx - b.xz * wy); }
    constexpr BivectorWeight BivectorWeight::antiWedge(const PseudoScalar& b) const noexcept { return {.wx = b.i * wx, .wy = b.i * wy, .wz = b.i * wz}; }
    constexpr PlaneIdeal BivectorWeight::antiWedge(const PointCenter& b) const noexcept { return {.x = -wx, .y = -wy, .z = -wz}; }

    constexpr Motor PseudoScalar::antiWedge(const Motor& b) const noexcept { return {.s = b.s * i, .wx = b.wx * i, .wy = b.wy * i, .wz = b.wz * i, .xy = b.xy * i, .xz = b.xz * i, .yz = b.yz * i, .i = b.i * i}; }
    constexpr Plane PseudoScalar::antiWedge(const Plane& b) const noexcept { return {.x = b.x * i, .y = b.y * i, .z = b.z * i, .w = b.w * i}; }
    constexpr Bivector PseudoScalar::antiWedge(const Bivector& b) const noexcept { return {.wx = b.wx * i, .wy = b.wy * i, .wz = b.wz * i, .xy = b.xy * i, .xz = b.xz * i, .yz = b.yz * i}; }
    constexpr ProjectivePoint PseudoScalar::antiWedge(const ProjectivePoint& b) const noexcept { return {.x = b.x * i, .y = b.y * i, .z = b.z * i, .w = b.w * i}; }
    constexpr Quaternion PseudoScalar::antiWedge(const Quaternion& b) const noexcept { return {.s = b.s * i, .xy = b.xy * i, .xz = b.xz * i, .yz = b.yz * i}; }
    constexpr ProjectiveTranslator PseudoScalar::antiWedge(const ProjectiveTranslator& b) const noexcept { return {.s = b.s * i, .wx = b.wx * i, .wy = b.wy * i, .wz = b.wz * i}; }
    constexpr ProjectiveTranslator PseudoScalar::antiWedge(const Translator& b) const noexcept { return {.s = i, .wx = b.wx * i, .wy = b.wy * i, .wz = b.wz * i}; }
    constexpr Vector PseudoScalar::antiWedge(const Vector& b) const noexcept { return {.x = b.x * i, .y = b.y * i, .z = b.z * i}; }
    constexpr ProjectivePoint PseudoScalar::antiWedge(const Point& b) const noexcept { return {.x = b.x * i, .y = b.y * i, .z = b.z * i, .w = i}; }
    constexpr PlaneIdeal PseudoScalar::antiWedge(const PlaneIdeal& b) const noexcept { return {.x = b.x * i, .y = b.y * i, .z = b.z * i}; }
    constexpr BivectorBulk PseudoScalar::antiWedge(const BivectorBulk& b) const noexcept { return {.xy = b.xy * i, .xz = b.xz * i, .yz = b.yz * i}; }
    constexpr BivectorWeight PseudoScalar::antiWedge(const BivectorWeight& b) const noexcept { return {.wx = b.wx * i, .wy = b.wy * i, .wz = b.wz * i}; }
    constexpr PseudoScalar PseudoScalar::antiWedge(const PseudoScalar& b) const noexcept { return {.i = b.i * i}; }
    constexpr ProjectivePoint PseudoScalar::antiWedge(const PointCenter& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = i}; }

    constexpr Multivector PointCenter::antiWedge(const Motor& b) const noexcept { return {.s = 0.0, .w = 0.0, .x = -b.wx, .y = -b.wy, .z = -b.wz, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = 0.0, .wxz = 0.0, .wyz = 0.0, .xyz = b.i, .i = 0.0}; }
    constexpr double PointCenter::antiWedge(const Plane& b) const noexcept { return b.w; }
    constexpr PlaneIdeal PointCenter::antiWedge(const Bivector& b) const noexcept { return {.x = -b.wx, .y = -b.wy, .z = -b.wz}; }
    constexpr BivectorBulk PointCenter::antiWedge(const ProjectivePoint& b) const noexcept { return {.xy = b.z, .xz = -b.y, .yz = b.x}; }
    constexpr PlaneIdeal PointCenter::antiWedge(const ProjectiveTranslator& b) const noexcept { return {.x = -b.wx, .y = -b.wy, .z = -b.wz}; }
    constexpr PlaneIdeal PointCenter::antiWedge(const Translator& b) const noexcept { return {.x = -b.wx, .y = -b.wy, .z = -b.wz}; }
    constexpr BivectorBulk PointCenter::antiWedge(const Vector& b) const noexcept { return {.xy = b.z, .xz = -b.y, .yz = b.x}; }
    constexpr BivectorBulk PointCenter::antiWedge(const Point& b) const noexcept { return {.xy = b.z, .xz = -b.y, .yz = b.x}; }
    constexpr PlaneIdeal PointCenter::antiWedge(const BivectorWeight& b) const noexcept { return {.x = -b.wx, .y = -b.wy, .z = -b.wz}; }
    constexpr ProjectivePoint PointCenter::antiWedge(const PseudoScalar& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = b.i}; }

}

// opsSandwich.h

// generated by com.github.kright.pga3d.codegen.cpp.ops.SandwichOpGenerator

namespace pga3d {
    constexpr Multivector Multivector::sandwich(const Multivector& b) const noexcept { return {.s = (2.0 * (b.x * (s * x + xyz * yz - xy * y - xz * z) + b.y * (s * y + x * xy - xyz * xz - yz * z) + b.z * (s * z + x * xz + xy * xyz + y * yz)) + b.s * (s * s + x * x + xy * xy + xyz * xyz + xz * xz + y * y + yz * yz + z * z)), .w = (2.0 * (b.i * (s * xyz + xz * y - x * yz - xy * z) + b.s * (i * xyz + s * w + wx * x + wxy * xy + wxz * xz + wy * y + wyz * yz + wz * z) + b.x * (i * yz + s * wx + w * x + wyz * xyz - wxy * y - wxz * z - wy * xy - wz * xz) + b.y * (s * wy + w * y + wx * xy + wxy * x - i * xz - wxz * xyz - wyz * z - wz * yz) + b.z * (i * xy + s * wz + w * z + wx * xz + wxy * xyz + wxz * x + wy * yz + wyz * y)) + b.w * (s * s + xy * xy + xz * xz + yz * yz - x * x - xyz * xyz - y * y - z * z)), .x = (2.0 * (b.s * (s * x + xy * y + xyz * yz + xz * z) + b.y * (s * xy + x * y - xyz * z - xz * yz) + b.z * (s * xz + x * z + xy * yz + xyz * y)) + b.x * (s * s + x * x + xyz * xyz + yz * yz - xy * xy - xz * xz - y * y - z * z)), .y = (2.0 * (b.s * (s * y + yz * z - x * xy - xyz * xz) + b.x * (x * y + xyz * z - s * xy - xz * yz) + b.z * (s * yz + y * z - x * xyz - xy * xz)) + b.y * (s * s + xyz * xyz + xz * xz + y * y - x * x - xy * xy - yz * yz - z * z)), .z = (2.0 * (b.s * (s * z + xy * xyz - x * xz - y * yz) + b.x * (x * z + xy * yz - s * xz - xyz * y) + b.y * (x * xyz + y * z - s * yz - xy * xz)) + b.z * (s * s + xy * xy + xyz * xyz + z * z - x * x - xz * xz - y * y - yz * yz)), .wx = (2.0 * (s * (b.wxy * y + b.wxz * z + b.wy * xy + b.wz * xz - b.xy * wy - b.xyz * wyz - b.xz * wz - b.yz * i) + x * (-b.wxy * xy - b.wxz * xz - b.wy * y - b.wyz * yz - b.wz * z - b.xy * wxy - b.xyz * i - b.xz * wxz - b.yz * wyz) + xy * (b.xy * wx + b.xyz * wxz + b.xz * i - b.yz * wz) + xyz * (b.wxy * xz + b.wy * z + b.wyz * s + b.xy * wxz + b.xyz * wx + b.yz * w - b.wxz * xy - b.wz * y - b.xz * wxy) + xz * (b.xz * wx + b.yz * wy - b.wyz * y - b.xy * i - b.xyz * wxy) + y * (b.xy * w + b.xyz * wz + b.xz * wyz - b.yz * wxz) + yz * (b.wxz * y + b.wz * xy + b.xy * wz + b.xyz * w + b.yz * wx - b.wxy * z - b.wy * xz - b.xz * wy) + z * (b.wyz * xy + b.xz * w + b.yz * wxy - b.xy * wyz - b.xyz * wy)) + b.wx * (s * s + y * y + yz * yz + z * z - x * x - xy * xy - xyz * xyz - xz * xz)), .wy = (2.0 * (s * (b.wyz * z + b.wz * yz + b.xy * wx + b.xyz * wxz + b.xz * i - b.wx * xy - b.wxy * x - b.wxz * xyz - b.yz * wz) + x * (b.yz * wxz - b.wxz * yz - b.xy * w - b.xyz * wz - b.xz * wyz) + xy * (b.xy * wy + b.xyz * wyz + b.xz * wz + b.yz * i - b.wxz * z) + xyz * (b.wxy * yz + b.wz * x + b.xy * wyz + b.xyz * wy - b.wx * z - b.wyz * xy - b.xz * w - b.yz * wxy) + xz * (b.wxy * z + b.wyz * x + b.xz * wy - b.wx * yz - b.wz * xy - b.xy * wz - b.xyz * w - b.yz * wx) + y * (-b.wx * x - b.wxy * xy - b.wxz * xz - b.wyz * yz - b.wz * z - b.xy * wxy - b.xyz * i - b.xz * wxz - b.yz * wyz) + yz * (b.xz * wx + b.yz * wy - b.xy * i - b.xyz * wxy) + z * (b.xy * wxz + b.xyz * wx + b.yz * w - b.xz * wxy)) + b.wy * (s * s + x * x + xz * xz + z * z - xy * xy - xyz * xyz - y * y - yz * yz)), .wz = (2.0 * (s * (b.wxy * xyz + b.xz * wx + b.yz * wy - b.wx * xz - b.wxz * x - b.wy * yz - b.wyz * y - b.xy * i - b.xyz * wxy) + x * (b.xy * wyz + b.xyz * wy - b.xz * w - b.yz * wxy) + xy * (b.wx * yz + b.wxz * y + b.xy * wz + b.xyz * w + b.yz * wx - b.wy * xz - b.wyz * x - b.xz * wy) + xyz * (b.wx * y + b.wxz * yz + b.xy * w + b.xyz * wz + b.xz * wyz - b.wy * x - b.wyz * xz - b.yz * wxz) + xz * (b.xy * wy + b.xyz * wyz + b.xz * wz + b.yz * i - b.wxy * y) + y * (b.xz * wxy - b.xy * wxz - b.xyz * wx - b.yz * w) + yz * (b.wxy * x + b.yz * wz - b.xy * wx - b.xyz * wxz - b.xz * i) + z * (-b.wx * x - b.wxy * xy - b.wxz * xz - b.wy * y - b.wyz * yz - b.xy * wxy - b.xyz * i - b.xz * wxz - b.yz * wyz)) + b.wz * (s * s + x * x + xy * xy + y * y - xyz * xyz - xz * xz - yz * yz - z * z)), .xy = (2.0 * (b.xyz * (s * z + xy * xyz - x * xz - y * yz) + b.xz * (s * yz + xy * xz - x * xyz - y * z) + b.yz * (x * z + xy * yz - s * xz - xyz * y)) + b.xy * (s * s + xy * xy + xyz * xyz + z * z - x * x - xz * xz - y * y - yz * yz)), .xz = (2.0 * (b.xy * (x * xyz + xy * xz - s * yz - y * z) + b.xyz * (x * xy + xyz * xz - s * y - yz * z) + b.yz * (s * xy + xz * yz - x * y - xyz * z)) + b.xz * (s * s + xyz * xyz + xz * xz + y * y - x * x - xy * xy - yz * yz - z * z)), .yz = (2.0 * (b.xy * (s * xz + x * z + xy * yz + xyz * y) + b.xyz * (s * x + xy * y + xyz * yz + xz * z) + b.xz * (xyz * z + xz * yz - s * xy - x * y)) + b.yz * (s * s + x * x + xyz * xyz + yz * yz - xy * xy - xz * xz - y * y - z * z)), .wxy = (2.0 * (s * (b.wx * y + b.wxz * yz + b.xy * w + b.xyz * wz + b.xz * wyz - b.wy * x - b.wyz * xz - b.wz * xyz - b.yz * wxz) + x * (b.yz * wz - b.wz * yz - b.xy * wx - b.xyz * wxz - b.xz * i) + xy * (b.wx * x + b.wxz * xz + b.wy * y + b.wyz * yz + b.xy * wxy + b.xyz * i + b.xz * wxz + b.yz * wyz) + xyz * (b.wx * xz + b.wxz * x + b.wy * yz + b.wyz * y + b.xy * i + b.xyz * wxy - b.xz * wx - b.yz * wy) + xz * (b.wz * y + b.xz * wxy - b.xy * wxz - b.xyz * wx - b.yz * w) + y * (-b.xy * wy - b.xyz * wyz - b.xz * wz - b.yz * i) + yz * (b.xz * w + b.yz * wxy - b.xy * wyz - b.xyz * wy) + z * (b.wx * yz + b.wxz * y + b.wz * xy + b.xy * wz + b.xyz * w + b.yz * wx - b.wy * xz - b.wyz * x - b.xz * wy)) + b.wxy * (s * s + x * x + xy * xy + y * y - xyz * xyz - xz * xz - yz * yz - z * z)), .wxz = (2.0 * (s * (b.wy * xyz + b.xz * w + b.yz * wxy - b.xy * wyz - b.xyz * wy) + x * (b.wx * xz + b.wyz * y + b.xy * i + b.xyz * wxy - b.wxy * xyz - b.wz * s - b.xz * wx - b.yz * wy) + xy * (b.wxy * xz + b.wy * z + b.wyz * s + b.xy * wxz + b.xyz * wx + b.yz * w - b.wx * xyz - b.wz * y - b.xz * wxy) + xyz * (b.xy * wx + b.xyz * wxz + b.xz * i - b.yz * wz) + xz * (b.xy * wxy + b.xyz * i + b.xz * wxz + b.yz * wyz) + y * (b.wy * xz + b.xz * wy - b.xy * wz - b.xyz * w - b.yz * wx) + yz * (b.wy * x + b.wyz * xz + b.wz * xyz + b.yz * wxz - b.wx * y - b.wxy * s - b.xy * w - b.xyz * wz - b.xz * wyz) + z * (b.wx * s + b.wxy * y + b.wyz * xyz + b.wz * xz - b.xy * wy - b.xyz * wyz - b.xz * wz - b.yz * i)) + b.wxz * (s * s + x * x + xz * xz + z * z - xy * xy - xyz * xyz - y * y - yz * yz)), .wyz = (2.0 * (s * (b.wxy * xz + b.wy * z + b.xy * wxz + b.xyz * wx + b.yz * w - b.wx * xyz - b.wxz * xy - b.wz * y - b.xz * wxy) + x * (b.wx * yz + b.wxz * y + b.wz * xy + b.xy * wz + b.xyz * w + b.yz * wx - b.wxy * z - b.wy * xz - b.xz * wy) + xy * (b.xy * wyz + b.xyz * wy - b.wx * z - b.xz * w - b.yz * wxy) + xyz * (b.xy * wy + b.xyz * wyz + b.xz * wz + b.yz * i - b.wxy * y - b.wxz * z - b.wy * xy - b.wz * xz) + xz * (b.xy * w + b.xyz * wz + b.xz * wyz - b.yz * wxz) + y * (b.wx * xz + b.xy * i + b.xyz * wxy - b.xz * wx - b.yz * wy) + yz * (b.wxy * xy + b.wxz * xz + b.wy * y + b.wz * z + b.xy * wxy + b.xyz * i + b.xz * wxz + b.yz * wyz) + z * (b.xy * wx + b.xyz * wxz + b.xz * i - b.yz * wz)) + b.wyz * (s * s + y * y + yz * yz + z * z - x * x - xy * xy - xyz * xyz - xz * xz)), .xyz = (2.0 * (b.xy * (s * z + x * xz + xy * xyz + y * yz) + b.xz * (xyz * xz + yz * z - s * y - x * xy) + b.yz * (s * x + xyz * yz - xy * y - xz * z)) + b.xyz * (s * s + x * x + xy * xy + xyz * xyz + xz * xz + y * y + yz * yz + z * z)), .i = (2.0 * (b.s * (i * s + wxy * z + wy * xz + wyz * x - w * xyz - wx * yz - wxz * y - wz * xy) + b.w * (x * yz + xy * z - s * xyz - xz * y) + b.x * (i * x + s * wyz + wxz * xy + wz * y - w * yz - wx * xyz - wxy * xz - wy * z) + b.y * (i * y + w * xz + wx * z + wyz * xy - s * wxz - wxy * yz - wy * xyz - wz * x) + b.z * (i * z + s * wxy + wy * x + wyz * xz - w * xy - wx * y - wxz * yz - wz * xyz)) + b.i * (s * s + xy * xy + xz * xz + yz * yz - x * x - xyz * xyz - y * y - z * z))}; }

    constexpr Motor Motor::sandwich(const Motor& b) const noexcept { return {.s = b.s * (s * s + xy * xy + xz * xz + yz * yz), .wx = (2.0 * (s * (-b.xy * wy - b.xz * wz - b.yz * i) + xy * (b.wy * s + b.wz * yz + b.xy * wx + b.xz * i - b.yz * wz) + xz * (b.wz * s + b.xz * wx + b.yz * wy - b.wy * yz - b.xy * i) + yz * (b.xy * wz + b.yz * wx - b.xz * wy)) + b.wx * (s * s + yz * yz - xy * xy - xz * xz)), .wy = (2.0 * (s * (b.wz * yz + b.xy * wx + b.xz * i - b.wx * xy - b.yz * wz) + xy * (b.xy * wy + b.xz * wz + b.yz * i) + xz * (b.xz * wy - b.wx * yz - b.wz * xy - b.xy * wz - b.yz * wx) + yz * (b.xz * wx + b.yz * wy - b.xy * i)) + b.wy * (s * s + xz * xz - xy * xy - yz * yz)), .wz = (2.0 * (s * (b.xz * wx + b.yz * wy - b.wx * xz - b.wy * yz - b.xy * i) + xy * (b.wx * yz + b.xy * wz + b.yz * wx - b.wy * xz - b.xz * wy) + xz * (b.xy * wy + b.xz * wz + b.yz * i) + yz * (b.yz * wz - b.xy * wx - b.xz * i)) + b.wz * (s * s + xy * xy - xz * xz - yz * yz)), .xy = (2.0 * (b.xz * (s * yz + xy * xz) + b.yz * (xy * yz - s * xz)) + b.xy * (s * s + xy * xy - xz * xz - yz * yz)), .xz = (2.0 * (b.xy * (xy * xz - s * yz) + b.yz * (s * xy + xz * yz)) + b.xz * (s * s + xz * xz - xy * xy - yz * yz)), .yz = (2.0 * (b.xy * (s * xz + xy * yz) + b.xz * (xz * yz - s * xy)) + b.yz * (s * s + yz * yz - xy * xy - xz * xz)), .i = (b.i * (s * s + xy * xy + xz * xz + yz * yz) + 2.0 * b.s * (i * s + wy * xz - wx * yz - wz * xy))}; }
    constexpr Plane Motor::sandwich(const Plane& b) const noexcept { return {.x = (2.0 * (b.y * (s * xy - xz * yz) + b.z * (s * xz + xy * yz)) + b.x * (s * s + yz * yz - xy * xy - xz * xz)), .y = (2.0 * (b.x * (-s * xy - xz * yz) + b.z * (s * yz - xy * xz)) + b.y * (s * s + xz * xz - xy * xy - yz * yz)), .z = (2.0 * (b.x * (xy * yz - s * xz) + b.y * (-s * yz - xy * xz)) + b.z * (s * s + xy * xy - xz * xz - yz * yz)), .w = (2.0 * (b.x * (i * yz + s * wx - wy * xy - wz * xz) + b.y * (s * wy + wx * xy - i * xz - wz * yz) + b.z * (i * xy + s * wz + wx * xz + wy * yz)) + b.w * (s * s + xy * xy + xz * xz + yz * yz))}; }
    constexpr Bivector Motor::sandwich(const Bivector& b) const noexcept { return {.wx = (2.0 * (s * (-b.xy * wy - b.xz * wz - b.yz * i) + xy * (b.wy * s + b.wz * yz + b.xy * wx + b.xz * i - b.yz * wz) + xz * (b.wz * s + b.xz * wx + b.yz * wy - b.wy * yz - b.xy * i) + yz * (b.xy * wz + b.yz * wx - b.xz * wy)) + b.wx * (s * s + yz * yz - xy * xy - xz * xz)), .wy = (2.0 * (s * (b.wz * yz + b.xy * wx + b.xz * i - b.wx * xy - b.yz * wz) + xy * (b.xy * wy + b.xz * wz + b.yz * i) + xz * (b.xz * wy - b.wx * yz - b.wz * xy - b.xy * wz - b.yz * wx) + yz * (b.xz * wx + b.yz * wy - b.xy * i)) + b.wy * (s * s + xz * xz - xy * xy - yz * yz)), .wz = (2.0 * (s * (b.xz * wx + b.yz * wy - b.wx * xz - b.wy * yz - b.xy * i) + xy * (b.wx * yz + b.xy * wz + b.yz * wx - b.wy * xz - b.xz * wy) + xz * (b.xy * wy + b.xz * wz + b.yz * i) + yz * (b.yz * wz - b.xy * wx - b.xz * i)) + b.wz * (s * s + xy * xy - xz * xz - yz * yz)), .xy = (2.0 * (b.xz * (s * yz + xy * xz) + b.yz * (xy * yz - s * xz)) + b.xy * (s * s + xy * xy - xz * xz - yz * yz)), .xz = (2.0 * (b.xy * (xy * xz - s * yz) + b.yz * (s * xy + xz * yz)) + b.xz * (s * s + xz * xz - xy * xy - yz * yz)), .yz = (2.0 * (b.xy * (s * xz + xy * yz) + b.xz * (xz * yz - s * xy)) + b.yz * (s * s + yz * yz - xy * xy - xz * xz))}; }
    constexpr ProjectivePoint Motor::sandwich(const ProjectivePoint& b) const noexcept { return {.x = (b.x * s * s + b.x * yz * yz - 2.0 * b.w * i * yz - 2.0 * b.w * s * wx - 2.0 * b.w * wy * xy - 2.0 * b.w * wz * xz - 2.0 * b.y * xz * yz - b.x * xy * xy - b.x * xz * xz + 2.0 * b.y * s * xy + 2.0 * b.z * s * xz + 2.0 * b.z * xy * yz), .y = (2.0 * (b.w * (i * xz + wx * xy - s * wy - wz * yz) + b.x * (-s * xy - xz * yz) + b.z * (s * yz - xy * xz)) + b.y * (s * s + xz * xz - xy * xy - yz * yz)), .z = (b.z * s * s + b.z * xy * xy - 2.0 * b.w * i * xy - 2.0 * b.w * s * wz - 2.0 * b.x * s * xz - 2.0 * b.y * s * yz - 2.0 * b.y * xy * xz - b.z * xz * xz - b.z * yz * yz + 2.0 * b.w * wx * xz + 2.0 * b.w * wy * yz + 2.0 * b.x * xy * yz), .w = b.w * (s * s + xy * xy + xz * xz + yz * yz)}; }
    constexpr Motor Motor::sandwich(const Quaternion& b) const noexcept { return {.s = b.s * (s * s + xy * xy + xz * xz + yz * yz), .wx = 2.0 * (b.xy * (wx * xy + wz * yz - i * xz - s * wy) + b.xz * (i * xy + wx * xz - s * wz - wy * yz) + b.yz * (wx * yz + wy * xz - i * s - wz * xy)), .wy = 2.0 * (b.xy * (s * wx + wy * xy - i * yz - wz * xz) + b.xz * (i * s + wx * yz + wy * xz + wz * xy) + b.yz * (i * xy + wy * yz - s * wz - wx * xz)), .wz = 2.0 * (b.xy * (wy * xz + wz * xy - i * s - wx * yz) + b.xz * (s * wx + wz * xz - i * yz - wy * xy) + b.yz * (i * xz + s * wy + wx * xy + wz * yz)), .xy = (2.0 * (b.xz * (s * yz + xy * xz) + b.yz * (xy * yz - s * xz)) + b.xy * (s * s + xy * xy - xz * xz - yz * yz)), .xz = (2.0 * (b.xy * (xy * xz - s * yz) + b.yz * (s * xy + xz * yz)) + b.xz * (s * s + xz * xz - xy * xy - yz * yz)), .yz = (2.0 * (b.xy * (s * xz + xy * yz) + b.xz * (xz * yz - s * xy)) + b.yz * (s * s + yz * yz - xy * xy - xz * xz)), .i = 2.0 * b.s * (i * s + wy * xz - wx * yz - wz * xy)}; }
    constexpr Motor Motor::sandwich(const ProjectiveTranslator& b) const noexcept { return {.s = b.s * (s * s + xy * xy + xz * xz + yz * yz), .wx = (2.0 * (b.wy * (s * xy - xz * yz) + b.wz * (s * xz + xy * yz)) + b.wx * (s * s + yz * yz - xy * xy - xz * xz)), .wy = (2.0 * (b.wx * (-s * xy - xz * yz) + b.wz * (s * yz - xy * xz)) + b.wy * (s * s + xz * xz - xy * xy - yz * yz)), .wz = (2.0 * (b.wx * (xy * yz - s * xz) + b.wy * (-s * yz - xy * xz)) + b.wz * (s * s + xy * xy - xz * xz - yz * yz)), .xy = 0.0, .xz = 0.0, .yz = 0.0, .i = 2.0 * b.s * (i * s + wy * xz - wx * yz - wz * xy)}; }
    constexpr Motor Motor::sandwich(const Translator& b) const noexcept { return {.s = (s * s + xy * xy + xz * xz + yz * yz), .wx = (2.0 * (b.wy * (s * xy - xz * yz) + b.wz * (s * xz + xy * yz)) + b.wx * (s * s + yz * yz - xy * xy - xz * xz)), .wy = (2.0 * (b.wx * (-s * xy - xz * yz) + b.wz * (s * yz - xy * xz)) + b.wy * (s * s + xz * xz - xy * xy - yz * yz)), .wz = (2.0 * (b.wx * (xy * yz - s * xz) + b.wy * (-s * yz - xy * xz)) + b.wz * (s * s + xy * xy - xz * xz - yz * yz)), .xy = 0.0, .xz = 0.0, .yz = 0.0, .i = 2.0 * (i * s + wy * xz - wx * yz - wz * xy)}; }
    constexpr Vector Motor::sandwich(const Vector& b) const noexcept { return {.x = (b.x * s * s + b.x * yz * yz - 2.0 * b.y * xz * yz - b.x * xy * xy - b.x * xz * xz + 2.0 * b.y * s * xy + 2.0 * b.z * s * xz + 2.0 * b.z * xy * yz), .y = (2.0 * (b.x * (-s * xy - xz * yz) + b.z * (s * yz - xy * xz)) + b.y * (s * s + xz * xz - xy * xy - yz * yz)), .z = (b.z * s * s + b.z * xy * xy - 2.0 * b.x * s * xz - 2.0 * b.y * s * yz - 2.0 * b.y * xy * xz - b.z * xz * xz - b.z * yz * yz + 2.0 * b.x * xy * yz)}; }
    constexpr ProjectivePoint Motor::sandwich(const Point& b) const noexcept { return {.x = -(2.0 * (s * (wx - b.y * xy - b.z * xz) + wy * xy + wz * xz + yz * (i + b.y * xz - b.z * xy)) + b.x * (xy * xy + xz * xz - s * s - yz * yz)), .y = (2.0 * (s * (-wy + b.z * yz - b.x * xy) + wx * xy + xz * (i - b.x * yz - b.z * xy) - wz * yz) + b.y * (s * s + xz * xz - xy * xy - yz * yz)), .z = (-2.0 * i * xy - 2.0 * s * wz + 2.0 * wx * xz + 2.0 * wy * yz + b.z * s * s + b.z * xy * xy - 2.0 * b.x * s * xz - 2.0 * b.y * s * yz - 2.0 * b.y * xy * xz - b.z * xz * xz - b.z * yz * yz + 2.0 * b.x * xy * yz), .w = (s * s + xy * xy + xz * xz + yz * yz)}; }
    constexpr Plane Motor::sandwich(const PlaneIdeal& b) const noexcept { return {.x = (2.0 * (b.y * (s * xy - xz * yz) + b.z * (s * xz + xy * yz)) + b.x * (s * s + yz * yz - xy * xy - xz * xz)), .y = (2.0 * (b.x * (-s * xy - xz * yz) + b.z * (s * yz - xy * xz)) + b.y * (s * s + xz * xz - xy * xy - yz * yz)), .z = (2.0 * (b.x * (xy * yz - s * xz) + b.y * (-s * yz - xy * xz)) + b.z * (s * s + xy * xy - xz * xz - yz * yz)), .w = 2.0 * (b.x * (i * yz + s * wx - wy * xy - wz * xz) + b.y * (s * wy + wx * xy - i * xz - wz * yz) + b.z * (i * xy + s * wz + wx * xz + wy * yz))}; }
    constexpr Bivector Motor::sandwich(const BivectorBulk& b) const noexcept { return {.wx = 2.0 * (b.xy * (wx * xy + wz * yz - i * xz - s * wy) + b.xz * (i * xy + wx * xz - s * wz - wy * yz) + b.yz * (wx * yz + wy * xz - i * s - wz * xy)), .wy = 2.0 * (b.xy * (s * wx + wy * xy - i * yz - wz * xz) + b.xz * (i * s + wx * yz + wy * xz + wz * xy) + b.yz * (i * xy + wy * yz - s * wz - wx * xz)), .wz = 2.0 * (b.xy * (wy * xz + wz * xy - i * s - wx * yz) + b.xz * (s * wx + wz * xz - i * yz - wy * xy) + b.yz * (i * xz + s * wy + wx * xy + wz * yz)), .xy = (2.0 * (b.xz * (s * yz + xy * xz) + b.yz * (xy * yz - s * xz)) + b.xy * (s * s + xy * xy - xz * xz - yz * yz)), .xz = (2.0 * (b.xy * (xy * xz - s * yz) + b.yz * (s * xy + xz * yz)) + b.xz * (s * s + xz * xz - xy * xy - yz * yz)), .yz = (2.0 * (b.xy * (s * xz + xy * yz) + b.xz * (xz * yz - s * xy)) + b.yz * (s * s + yz * yz - xy * xy - xz * xz))}; }
    constexpr BivectorWeight Motor::sandwich(const BivectorWeight& b) const noexcept { return {.wx = (2.0 * (b.wy * (s * xy - xz * yz) + b.wz * (s * xz + xy * yz)) + b.wx * (s * s + yz * yz - xy * xy - xz * xz)), .wy = (2.0 * (b.wx * (-s * xy - xz * yz) + b.wz * (s * yz - xy * xz)) + b.wy * (s * s + xz * xz - xy * xy - yz * yz)), .wz = (2.0 * (b.wx * (xy * yz - s * xz) + b.wy * (-s * yz - xy * xz)) + b.wz * (s * s + xy * xy - xz * xz - yz * yz))}; }
    constexpr PseudoScalar Motor::sandwich(const PseudoScalar& b) const noexcept { return {.i = b.i * (s * s + xy * xy + xz * xz + yz * yz)}; }
    constexpr ProjectivePoint Motor::sandwich(const PointCenter& b) const noexcept { return {.x = (-2.0 * i * yz - 2.0 * s * wx - 2.0 * wy * xy - 2.0 * wz * xz), .y = 2.0 * (i * xz + wx * xy - s * wy - wz * yz), .z = (-2.0 * i * xy - 2.0 * s * wz + 2.0 * wx * xz + 2.0 * wy * yz), .w = (s * s + xy * xy + xz * xz + yz * yz)}; }

    constexpr Motor Plane::sandwich(const Motor& b) const noexcept { return {.s = b.s * (x * x + y * y + z * z), .wx = (2.0 * (w * (b.xy * y + b.xz * z) + x * (-b.wy * y - b.wz * z)) + b.wx * (y * y + z * z - x * x)), .wy = (2.0 * (x * (-b.wx * y - b.xy * w) + z * (b.yz * w - b.wz * y)) + b.wy * (x * x + z * z - y * y)), .wz = (2.0 * (x * (-b.wx * z - b.xz * w) + y * (-b.wy * z - b.yz * w)) + b.wz * (x * x + y * y - z * z)), .xy = (b.xy * (z * z - x * x - y * y) + 2.0 * z * (b.yz * x - b.xz * y)), .xz = (b.xz * (y * y - x * x - z * z) + 2.0 * y * (-b.xy * z - b.yz * x)), .yz = (b.yz * (x * x - y * y - z * z) + 2.0 * x * (b.xy * z - b.xz * y)), .i = b.i * (-x * x - y * y - z * z)}; }
    constexpr Plane Plane::sandwich(const Plane& b) const noexcept { return {.x = (b.x * (x * x - y * y - z * z) + 2.0 * x * (b.y * y + b.z * z)), .y = (b.y * (y * y - x * x - z * z) + 2.0 * y * (b.x * x + b.z * z)), .z = (b.z * (z * z - x * x - y * y) + 2.0 * z * (b.x * x + b.y * y)), .w = (b.w * (-x * x - y * y - z * z) + 2.0 * w * (b.x * x + b.y * y + b.z * z))}; }
    constexpr Bivector Plane::sandwich(const Bivector& b) const noexcept { return {.wx = (2.0 * (w * (b.xy * y + b.xz * z) + x * (-b.wy * y - b.wz * z)) + b.wx * (y * y + z * z - x * x)), .wy = (2.0 * (x * (-b.wx * y - b.xy * w) + z * (b.yz * w - b.wz * y)) + b.wy * (x * x + z * z - y * y)), .wz = (2.0 * (x * (-b.wx * z - b.xz * w) + y * (-b.wy * z - b.yz * w)) + b.wz * (x * x + y * y - z * z)), .xy = (b.xy * (z * z - x * x - y * y) + 2.0 * z * (b.yz * x - b.xz * y)), .xz = (b.xz * (y * y - x * x - z * z) + 2.0 * y * (-b.xy * z - b.yz * x)), .yz = (b.yz * (x * x - y * y - z * z) + 2.0 * x * (b.xy * z - b.xz * y))}; }
    constexpr ProjectivePoint Plane::sandwich(const ProjectivePoint& b) const noexcept { return {.x = (b.x * y * y + b.x * z * z - 2.0 * b.w * w * x - 2.0 * b.y * x * y - 2.0 * b.z * x * z - b.x * x * x), .y = (b.y * (x * x + z * z) + y * (2.0 * (-b.w * w - b.x * x - b.z * z) - b.y * y)), .z = (b.z * x * x + b.z * y * y - 2.0 * b.w * w * z - 2.0 * b.x * x * z - 2.0 * b.y * y * z - b.z * z * z), .w = b.w * (x * x + y * y + z * z)}; }
    constexpr Motor Plane::sandwich(const Quaternion& b) const noexcept { return {.s = b.s * (x * x + y * y + z * z), .wx = 2.0 * w * (b.xy * y + b.xz * z), .wy = 2.0 * w * (b.yz * z - b.xy * x), .wz = 2.0 * w * (-b.xz * x - b.yz * y), .xy = (b.xy * (z * z - x * x - y * y) + 2.0 * z * (b.yz * x - b.xz * y)), .xz = (b.xz * (y * y - x * x - z * z) + 2.0 * y * (-b.xy * z - b.yz * x)), .yz = (b.yz * (x * x - y * y - z * z) + 2.0 * x * (b.xy * z - b.xz * y)), .i = 0.0}; }
    constexpr ProjectiveTranslator Plane::sandwich(const ProjectiveTranslator& b) const noexcept { return {.s = b.s * (x * x + y * y + z * z), .wx = (b.wx * (y * y + z * z - x * x) + 2.0 * x * (-b.wy * y - b.wz * z)), .wy = (b.wy * (x * x + z * z - y * y) + 2.0 * y * (-b.wx * x - b.wz * z)), .wz = (b.wz * (x * x + y * y - z * z) + 2.0 * z * (-b.wx * x - b.wy * y))}; }
    constexpr ProjectiveTranslator Plane::sandwich(const Translator& b) const noexcept { return {.s = (x * x + y * y + z * z), .wx = (b.wx * (y * y + z * z - x * x) + 2.0 * x * (-b.wy * y - b.wz * z)), .wy = (b.wy * (x * x + z * z - y * y) + 2.0 * y * (-b.wx * x - b.wz * z)), .wz = (b.wz * (x * x + y * y - z * z) + 2.0 * z * (-b.wx * x - b.wy * y))}; }
    constexpr Vector Plane::sandwich(const Vector& b) const noexcept { return {.x = (b.x * y * y + b.x * z * z - 2.0 * b.y * x * y - 2.0 * b.z * x * z - b.x * x * x), .y = (b.y * (x * x + z * z - y * y) + 2.0 * y * (-b.x * x - b.z * z)), .z = (b.z * x * x + b.z * y * y - 2.0 * b.x * x * z - 2.0 * b.y * y * z - b.z * z * z)}; }
    constexpr ProjectivePoint Plane::sandwich(const Point& b) const noexcept { return {.x = -(b.x * (-y * y - z * z) + x * (2.0 * (w + b.y * y + b.z * z) + b.x * x)), .y = (b.y * (x * x + z * z) + y * (2.0 * (-w - b.x * x - b.z * z) - b.y * y)), .z = -(b.z * (-x * x - y * y) + z * (2.0 * (w + b.x * x + b.y * y) + b.z * z)), .w = (x * x + y * y + z * z)}; }
    constexpr Plane Plane::sandwich(const PlaneIdeal& b) const noexcept { return {.x = (b.x * (x * x - y * y - z * z) + 2.0 * x * (b.y * y + b.z * z)), .y = (b.y * (y * y - x * x - z * z) + 2.0 * y * (b.x * x + b.z * z)), .z = (b.z * (z * z - x * x - y * y) + 2.0 * z * (b.x * x + b.y * y)), .w = 2.0 * w * (b.x * x + b.y * y + b.z * z)}; }
    constexpr Bivector Plane::sandwich(const BivectorBulk& b) const noexcept { return {.wx = 2.0 * w * (b.xy * y + b.xz * z), .wy = 2.0 * w * (b.yz * z - b.xy * x), .wz = 2.0 * w * (-b.xz * x - b.yz * y), .xy = (b.xy * (z * z - x * x - y * y) + 2.0 * z * (b.yz * x - b.xz * y)), .xz = (b.xz * (y * y - x * x - z * z) + 2.0 * y * (-b.xy * z - b.yz * x)), .yz = (b.yz * (x * x - y * y - z * z) + 2.0 * x * (b.xy * z - b.xz * y))}; }
    constexpr BivectorWeight Plane::sandwich(const BivectorWeight& b) const noexcept { return {.wx = (b.wx * (y * y + z * z - x * x) + 2.0 * x * (-b.wy * y - b.wz * z)), .wy = (b.wy * (x * x + z * z - y * y) + 2.0 * y * (-b.wx * x - b.wz * z)), .wz = (b.wz * (x * x + y * y - z * z) + 2.0 * z * (-b.wx * x - b.wy * y))}; }
    constexpr PseudoScalar Plane::sandwich(const PseudoScalar& b) const noexcept { return {.i = b.i * (-x * x - y * y - z * z)}; }
    constexpr ProjectivePoint Plane::sandwich(const PointCenter& b) const noexcept { return {.x = -2.0 * w * x, .y = -2.0 * w * y, .z = -2.0 * w * z, .w = (x * x + y * y + z * z)}; }

    constexpr Motor Bivector::sandwich(const Motor& b) const noexcept { return {.s = b.s * (xy * xy + xz * xz + yz * yz), .wx = (2.0 * (b.yz * (wy * xz - wz * xy) + wx * (b.xy * xy + b.xz * xz) + yz * (b.wz * xy + b.xy * wz + b.yz * wx - b.wy * xz - b.xz * wy)) + b.wx * (yz * yz - xy * xy - xz * xz)), .wy = (2.0 * (b.xz * (wx * yz + wz * xy) + wy * (b.xy * xy + b.yz * yz) + xz * (b.xz * wy - b.wx * yz - b.wz * xy - b.xy * wz - b.yz * wx)) + b.wy * (xz * xz - xy * xy - yz * yz)), .wz = (2.0 * (b.xy * (wy * xz - wx * yz) + wz * (b.xz * xz + b.yz * yz) + xy * (b.wx * yz + b.xy * wz + b.yz * wx - b.wy * xz - b.xz * wy)) + b.wz * (xy * xy - xz * xz - yz * yz)), .xy = (b.xy * (xy * xy - xz * xz - yz * yz) + 2.0 * xy * (b.xz * xz + b.yz * yz)), .xz = (b.xz * (xz * xz - xy * xy - yz * yz) + 2.0 * xz * (b.xy * xy + b.yz * yz)), .yz = (b.yz * (yz * yz - xy * xy - xz * xz) + 2.0 * yz * (b.xy * xy + b.xz * xz)), .i = (b.i * (xy * xy + xz * xz + yz * yz) + 2.0 * b.s * (wy * xz - wx * yz - wz * xy))}; }
    constexpr Plane Bivector::sandwich(const Plane& b) const noexcept { return {.x = (b.x * (yz * yz - xy * xy - xz * xz) + 2.0 * yz * (b.z * xy - b.y * xz)), .y = (b.y * (xz * xz - xy * xy - yz * yz) + 2.0 * xz * (-b.x * yz - b.z * xy)), .z = (b.z * (xy * xy - xz * xz - yz * yz) + 2.0 * xy * (b.x * yz - b.y * xz)), .w = (2.0 * (b.x * (-wy * xy - wz * xz) + b.y * (wx * xy - wz * yz) + b.z * (wx * xz + wy * yz)) + b.w * (xy * xy + xz * xz + yz * yz))}; }
    constexpr Bivector Bivector::sandwich(const Bivector& b) const noexcept { return {.wx = (2.0 * (b.yz * (wy * xz - wz * xy) + wx * (b.xy * xy + b.xz * xz) + yz * (b.wz * xy + b.xy * wz + b.yz * wx - b.wy * xz - b.xz * wy)) + b.wx * (yz * yz - xy * xy - xz * xz)), .wy = (2.0 * (b.xz * (wx * yz + wz * xy) + wy * (b.xy * xy + b.yz * yz) + xz * (b.xz * wy - b.wx * yz - b.wz * xy - b.xy * wz - b.yz * wx)) + b.wy * (xz * xz - xy * xy - yz * yz)), .wz = (2.0 * (b.xy * (wy * xz - wx * yz) + wz * (b.xz * xz + b.yz * yz) + xy * (b.wx * yz + b.xy * wz + b.yz * wx - b.wy * xz - b.xz * wy)) + b.wz * (xy * xy - xz * xz - yz * yz)), .xy = (b.xy * (xy * xy - xz * xz - yz * yz) + 2.0 * xy * (b.xz * xz + b.yz * yz)), .xz = (b.xz * (xz * xz - xy * xy - yz * yz) + 2.0 * xz * (b.xy * xy + b.yz * yz)), .yz = (b.yz * (yz * yz - xy * xy - xz * xz) + 2.0 * yz * (b.xy * xy + b.xz * xz))}; }
    constexpr ProjectivePoint Bivector::sandwich(const ProjectivePoint& b) const noexcept { return {.x = (b.x * yz * yz - 2.0 * b.w * wy * xy - 2.0 * b.w * wz * xz - 2.0 * b.y * xz * yz - b.x * xy * xy - b.x * xz * xz + 2.0 * b.z * xy * yz), .y = (2.0 * (b.w * (wx * xy - wz * yz) + xz * (-b.x * yz - b.z * xy)) + b.y * (xz * xz - xy * xy - yz * yz)), .z = (b.z * xy * xy - 2.0 * b.y * xy * xz - b.z * xz * xz - b.z * yz * yz + 2.0 * b.w * wx * xz + 2.0 * b.w * wy * yz + 2.0 * b.x * xy * yz), .w = b.w * (xy * xy + xz * xz + yz * yz)}; }
    constexpr Motor Bivector::sandwich(const Quaternion& b) const noexcept { return {.s = b.s * (xy * xy + xz * xz + yz * yz), .wx = 2.0 * (b.yz * (wy * xz - wz * xy) + wx * (b.xy * xy + b.xz * xz) + yz * (b.xy * wz + b.yz * wx - b.xz * wy)), .wy = 2.0 * (b.xz * (wx * yz + wz * xy) + wy * (b.xy * xy + b.yz * yz) + xz * (b.xz * wy - b.xy * wz - b.yz * wx)), .wz = 2.0 * (b.xy * (wy * xz + wz * xy - wx * yz) + b.xz * (wz * xz - wy * xy) + b.yz * (wx * xy + wz * yz)), .xy = (b.xy * (xy * xy - xz * xz - yz * yz) + 2.0 * xy * (b.xz * xz + b.yz * yz)), .xz = (b.xz * (xz * xz - xy * xy - yz * yz) + 2.0 * xz * (b.xy * xy + b.yz * yz)), .yz = (b.yz * (yz * yz - xy * xy - xz * xz) + 2.0 * yz * (b.xy * xy + b.xz * xz)), .i = 2.0 * b.s * (wy * xz - wx * yz - wz * xy)}; }
    constexpr Motor Bivector::sandwich(const ProjectiveTranslator& b) const noexcept { return {.s = b.s * (xy * xy + xz * xz + yz * yz), .wx = (b.wx * (yz * yz - xy * xy - xz * xz) + 2.0 * yz * (b.wz * xy - b.wy * xz)), .wy = (b.wy * (xz * xz - xy * xy - yz * yz) + 2.0 * xz * (-b.wx * yz - b.wz * xy)), .wz = (b.wz * (xy * xy - xz * xz - yz * yz) + 2.0 * xy * (b.wx * yz - b.wy * xz)), .xy = 0.0, .xz = 0.0, .yz = 0.0, .i = 2.0 * b.s * (wy * xz - wx * yz - wz * xy)}; }
    constexpr Motor Bivector::sandwich(const Translator& b) const noexcept { return {.s = (xy * xy + xz * xz + yz * yz), .wx = (b.wx * (yz * yz - xy * xy - xz * xz) + 2.0 * yz * (b.wz * xy - b.wy * xz)), .wy = (b.wy * (xz * xz - xy * xy - yz * yz) + 2.0 * xz * (-b.wx * yz - b.wz * xy)), .wz = (b.wz * (xy * xy - xz * xz - yz * yz) + 2.0 * xy * (b.wx * yz - b.wy * xz)), .xy = 0.0, .xz = 0.0, .yz = 0.0, .i = 2.0 * (wy * xz - wx * yz - wz * xy)}; }
    constexpr Vector Bivector::sandwich(const Vector& b) const noexcept { return {.x = (b.x * yz * yz - 2.0 * b.y * xz * yz - b.x * xy * xy - b.x * xz * xz + 2.0 * b.z * xy * yz), .y = (b.y * (xz * xz - xy * xy - yz * yz) + 2.0 * xz * (-b.x * yz - b.z * xy)), .z = (b.z * xy * xy - 2.0 * b.y * xy * xz - b.z * xz * xz - b.z * yz * yz + 2.0 * b.x * xy * yz)}; }
    constexpr ProjectivePoint Bivector::sandwich(const Point& b) const noexcept { return {.x = -(2.0 * (xy * (wy - b.z * yz) + xz * (wz + b.y * yz)) + b.x * (xy * xy + xz * xz - yz * yz)), .y = (2.0 * (xy * (wx - b.z * xz) + yz * (-wz - b.x * xz)) + b.y * (xz * xz - xy * xy - yz * yz)), .z = (2.0 * wx * xz + 2.0 * wy * yz + b.z * xy * xy - 2.0 * b.y * xy * xz - b.z * xz * xz - b.z * yz * yz + 2.0 * b.x * xy * yz), .w = (xy * xy + xz * xz + yz * yz)}; }
    constexpr Plane Bivector::sandwich(const PlaneIdeal& b) const noexcept { return {.x = (b.x * (yz * yz - xy * xy - xz * xz) + 2.0 * yz * (b.z * xy - b.y * xz)), .y = (b.y * (xz * xz - xy * xy - yz * yz) + 2.0 * xz * (-b.x * yz - b.z * xy)), .z = (b.z * (xy * xy - xz * xz - yz * yz) + 2.0 * xy * (b.x * yz - b.y * xz)), .w = 2.0 * (b.x * (-wy * xy - wz * xz) + b.y * (wx * xy - wz * yz) + b.z * (wx * xz + wy * yz))}; }
    constexpr Bivector Bivector::sandwich(const BivectorBulk& b) const noexcept { return {.wx = 2.0 * (b.yz * (wy * xz - wz * xy) + wx * (b.xy * xy + b.xz * xz) + yz * (b.xy * wz + b.yz * wx - b.xz * wy)), .wy = 2.0 * (b.xz * (wx * yz + wz * xy) + wy * (b.xy * xy + b.yz * yz) + xz * (b.xz * wy - b.xy * wz - b.yz * wx)), .wz = 2.0 * (b.xy * (wy * xz + wz * xy - wx * yz) + b.xz * (wz * xz - wy * xy) + b.yz * (wx * xy + wz * yz)), .xy = (b.xy * (xy * xy - xz * xz - yz * yz) + 2.0 * xy * (b.xz * xz + b.yz * yz)), .xz = (b.xz * (xz * xz - xy * xy - yz * yz) + 2.0 * xz * (b.xy * xy + b.yz * yz)), .yz = (b.yz * (yz * yz - xy * xy - xz * xz) + 2.0 * yz * (b.xy * xy + b.xz * xz))}; }
    constexpr BivectorWeight Bivector::sandwich(const BivectorWeight& b) const noexcept { return {.wx = (b.wx * (yz * yz - xy * xy - xz * xz) + 2.0 * yz * (b.wz * xy - b.wy * xz)), .wy = (b.wy * (xz * xz - xy * xy - yz * yz) + 2.0 * xz * (-b.wx * yz - b.wz * xy)), .wz = (b.wz * (xy * xy - xz * xz - yz * yz) + 2.0 * xy * (b.wx * yz - b.wy * xz))}; }
    constexpr PseudoScalar Bivector::sandwich(const PseudoScalar& b) const noexcept { return {.i = b.i * (xy * xy + xz * xz + yz * yz)}; }
    constexpr ProjectivePoint Bivector::sandwich(const PointCenter& b) const noexcept { return {.x = (-2.0 * wy * xy - 2.0 * wz * xz), .y = 2.0 * (wx * xy - wz * yz), .z = (2.0 * wx * xz + 2.0 * wy * yz), .w = (xy * xy + xz * xz + yz * yz)}; }

    constexpr Motor ProjectivePoint::sandwich(const Motor& b) const noexcept { return {.s = b.s * w * w, .wx = w * (2.0 * (b.xy * y + b.xz * z) - b.wx * w), .wy = w * (2.0 * (b.yz * z - b.xy * x) - b.wy * w), .wz = w * (2.0 * (-b.xz * x - b.yz * y) - b.wz * w), .xy = b.xy * w * w, .xz = b.xz * w * w, .yz = b.yz * w * w, .i = -b.i * w * w}; }
    constexpr Plane ProjectivePoint::sandwich(const Plane& b) const noexcept { return {.x = b.x * w * w, .y = b.y * w * w, .z = b.z * w * w, .w = w * (2.0 * (-b.x * x - b.y * y - b.z * z) - b.w * w)}; }
    constexpr Bivector ProjectivePoint::sandwich(const Bivector& b) const noexcept { return {.wx = w * (2.0 * (b.xy * y + b.xz * z) - b.wx * w), .wy = w * (2.0 * (b.yz * z - b.xy * x) - b.wy * w), .wz = w * (2.0 * (-b.xz * x - b.yz * y) - b.wz * w), .xy = b.xy * w * w, .xz = b.xz * w * w, .yz = b.yz * w * w}; }
    constexpr ProjectivePoint ProjectivePoint::sandwich(const ProjectivePoint& b) const noexcept { return {.x = (-b.x * w * w + 2.0 * b.w * w * x), .y = w * (-b.y * w + 2.0 * b.w * y), .z = (-b.z * w * w + 2.0 * b.w * w * z), .w = b.w * w * w}; }
    constexpr Motor ProjectivePoint::sandwich(const Quaternion& b) const noexcept { return {.s = b.s * w * w, .wx = 2.0 * w * (b.xy * y + b.xz * z), .wy = 2.0 * w * (b.yz * z - b.xy * x), .wz = 2.0 * w * (-b.xz * x - b.yz * y), .xy = b.xy * w * w, .xz = b.xz * w * w, .yz = b.yz * w * w, .i = 0.0}; }
    constexpr ProjectiveTranslator ProjectivePoint::sandwich(const ProjectiveTranslator& b) const noexcept { return {.s = b.s * w * w, .wx = -b.wx * w * w, .wy = -b.wy * w * w, .wz = -b.wz * w * w}; }
    constexpr ProjectiveTranslator ProjectivePoint::sandwich(const Translator& b) const noexcept { return {.s = w * w, .wx = -b.wx * w * w, .wy = -b.wy * w * w, .wz = -b.wz * w * w}; }
    constexpr Vector ProjectivePoint::sandwich(const Vector& b) const noexcept { return {.x = -b.x * w * w, .y = -b.y * w * w, .z = -b.z * w * w}; }
    constexpr ProjectivePoint ProjectivePoint::sandwich(const Point& b) const noexcept { return {.x = (2.0 * w * x - b.x * w * w), .y = w * (2.0 * y - b.y * w), .z = (2.0 * w * z - b.z * w * w), .w = w * w}; }
    constexpr Plane ProjectivePoint::sandwich(const PlaneIdeal& b) const noexcept { return {.x = b.x * w * w, .y = b.y * w * w, .z = b.z * w * w, .w = 2.0 * w * (-b.x * x - b.y * y - b.z * z)}; }
    constexpr Bivector ProjectivePoint::sandwich(const BivectorBulk& b) const noexcept { return {.wx = 2.0 * w * (b.xy * y + b.xz * z), .wy = 2.0 * w * (b.yz * z - b.xy * x), .wz = 2.0 * w * (-b.xz * x - b.yz * y), .xy = b.xy * w * w, .xz = b.xz * w * w, .yz = b.yz * w * w}; }
    constexpr BivectorWeight ProjectivePoint::sandwich(const BivectorWeight& b) const noexcept { return {.wx = -b.wx * w * w, .wy = -b.wy * w * w, .wz = -b.wz * w * w}; }
    constexpr PseudoScalar ProjectivePoint::sandwich(const PseudoScalar& b) const noexcept { return {.i = -b.i * w * w}; }
    constexpr ProjectivePoint ProjectivePoint::sandwich(const PointCenter& b) const noexcept { return {.x = 2.0 * w * x, .y = 2.0 * w * y, .z = 2.0 * w * z, .w = w * w}; }

    constexpr Motor Quaternion::sandwich(const Motor& b) const noexcept { return {.s = b.s * (s * s + xy * xy + xz * xz + yz * yz), .wx = (2.0 * (b.wy * (s * xy - xz * yz) + b.wz * (s * xz + xy * yz)) + b.wx * (s * s + yz * yz - xy * xy - xz * xz)), .wy = (2.0 * (b.wx * (-s * xy - xz * yz) + b.wz * (s * yz - xy * xz)) + b.wy * (s * s + xz * xz - xy * xy - yz * yz)), .wz = (2.0 * (b.wx * (xy * yz - s * xz) + b.wy * (-s * yz - xy * xz)) + b.wz * (s * s + xy * xy - xz * xz - yz * yz)), .xy = (2.0 * (b.xz * (s * yz + xy * xz) + b.yz * (xy * yz - s * xz)) + b.xy * (s * s + xy * xy - xz * xz - yz * yz)), .xz = (2.0 * (b.xy * (xy * xz - s * yz) + b.yz * (s * xy + xz * yz)) + b.xz * (s * s + xz * xz - xy * xy - yz * yz)), .yz = (2.0 * (b.xy * (s * xz + xy * yz) + b.xz * (xz * yz - s * xy)) + b.yz * (s * s + yz * yz - xy * xy - xz * xz)), .i = b.i * (s * s + xy * xy + xz * xz + yz * yz)}; }
    constexpr Plane Quaternion::sandwich(const Plane& b) const noexcept { return {.x = (2.0 * (b.y * (s * xy - xz * yz) + b.z * (s * xz + xy * yz)) + b.x * (s * s + yz * yz - xy * xy - xz * xz)), .y = (2.0 * (b.x * (-s * xy - xz * yz) + b.z * (s * yz - xy * xz)) + b.y * (s * s + xz * xz - xy * xy - yz * yz)), .z = (2.0 * (b.x * (xy * yz - s * xz) + b.y * (-s * yz - xy * xz)) + b.z * (s * s + xy * xy - xz * xz - yz * yz)), .w = b.w * (s * s + xy * xy + xz * xz + yz * yz)}; }
    constexpr Bivector Quaternion::sandwich(const Bivector& b) const noexcept { return {.wx = (2.0 * (b.wy * (s * xy - xz * yz) + b.wz * (s * xz + xy * yz)) + b.wx * (s * s + yz * yz - xy * xy - xz * xz)), .wy = (2.0 * (b.wx * (-s * xy - xz * yz) + b.wz * (s * yz - xy * xz)) + b.wy * (s * s + xz * xz - xy * xy - yz * yz)), .wz = (2.0 * (b.wx * (xy * yz - s * xz) + b.wy * (-s * yz - xy * xz)) + b.wz * (s * s + xy * xy - xz * xz - yz * yz)), .xy = (2.0 * (b.xz * (s * yz + xy * xz) + b.yz * (xy * yz - s * xz)) + b.xy * (s * s + xy * xy - xz * xz - yz * yz)), .xz = (2.0 * (b.xy * (xy * xz - s * yz) + b.yz * (s * xy + xz * yz)) + b.xz * (s * s + xz * xz - xy * xy - yz * yz)), .yz = (2.0 * (b.xy * (s * xz + xy * yz) + b.xz * (xz * yz - s * xy)) + b.yz * (s * s + yz * yz - xy * xy - xz * xz))}; }
    constexpr ProjectivePoint Quaternion::sandwich(const ProjectivePoint& b) const noexcept { return {.x = (b.x * s * s + b.x * yz * yz - 2.0 * b.y * xz * yz - b.x * xy * xy - b.x * xz * xz + 2.0 * b.y * s * xy + 2.0 * b.z * s * xz + 2.0 * b.z * xy * yz), .y = (2.0 * (b.x * (-s * xy - xz * yz) + b.z * (s * yz - xy * xz)) + b.y * (s * s + xz * xz - xy * xy - yz * yz)), .z = (b.z * s * s + b.z * xy * xy - 2.0 * b.x * s * xz - 2.0 * b.y * s * yz - 2.0 * b.y * xy * xz - b.z * xz * xz - b.z * yz * yz + 2.0 * b.x * xy * yz), .w = b.w * (s * s + xy * xy + xz * xz + yz * yz)}; }
    constexpr Quaternion Quaternion::sandwich(const Quaternion& b) const noexcept { return {.s = b.s * (s * s + xy * xy + xz * xz + yz * yz), .xy = (2.0 * (b.xz * (s * yz + xy * xz) + b.yz * (xy * yz - s * xz)) + b.xy * (s * s + xy * xy - xz * xz - yz * yz)), .xz = (2.0 * (b.xy * (xy * xz - s * yz) + b.yz * (s * xy + xz * yz)) + b.xz * (s * s + xz * xz - xy * xy - yz * yz)), .yz = (2.0 * (b.xy * (s * xz + xy * yz) + b.xz * (xz * yz - s * xy)) + b.yz * (s * s + yz * yz - xy * xy - xz * xz))}; }
    constexpr ProjectiveTranslator Quaternion::sandwich(const ProjectiveTranslator& b) const noexcept { return {.s = b.s * (s * s + xy * xy + xz * xz + yz * yz), .wx = (2.0 * (b.wy * (s * xy - xz * yz) + b.wz * (s * xz + xy * yz)) + b.wx * (s * s + yz * yz - xy * xy - xz * xz)), .wy = (2.0 * (b.wx * (-s * xy - xz * yz) + b.wz * (s * yz - xy * xz)) + b.wy * (s * s + xz * xz - xy * xy - yz * yz)), .wz = (2.0 * (b.wx * (xy * yz - s * xz) + b.wy * (-s * yz - xy * xz)) + b.wz * (s * s + xy * xy - xz * xz - yz * yz))}; }
    constexpr ProjectiveTranslator Quaternion::sandwich(const Translator& b) const noexcept { return {.s = (s * s + xy * xy + xz * xz + yz * yz), .wx = (2.0 * (b.wy * (s * xy - xz * yz) + b.wz * (s * xz + xy * yz)) + b.wx * (s * s + yz * yz - xy * xy - xz * xz)), .wy = (2.0 * (b.wx * (-s * xy - xz * yz) + b.wz * (s * yz - xy * xz)) + b.wy * (s * s + xz * xz - xy * xy - yz * yz)), .wz = (2.0 * (b.wx * (xy * yz - s * xz) + b.wy * (-s * yz - xy * xz)) + b.wz * (s * s + xy * xy - xz * xz - yz * yz))}; }
    constexpr Vector Quaternion::sandwich(const Vector& b) const noexcept { return {.x = (b.x * s * s + b.x * yz * yz - 2.0 * b.y * xz * yz - b.x * xy * xy - b.x * xz * xz + 2.0 * b.y * s * xy + 2.0 * b.z * s * xz + 2.0 * b.z * xy * yz), .y = (2.0 * (b.x * (-s * xy - xz * yz) + b.z * (s * yz - xy * xz)) + b.y * (s * s + xz * xz - xy * xy - yz * yz)), .z = (b.z * s * s + b.z * xy * xy - 2.0 * b.x * s * xz - 2.0 * b.y * s * yz - 2.0 * b.y * xy * xz - b.z * xz * xz - b.z * yz * yz + 2.0 * b.x * xy * yz)}; }
    constexpr ProjectivePoint Quaternion::sandwich(const Point& b) const noexcept { return {.x = (b.x * s * s + b.x * yz * yz - 2.0 * b.y * xz * yz - b.x * xy * xy - b.x * xz * xz + 2.0 * b.y * s * xy + 2.0 * b.z * s * xz + 2.0 * b.z * xy * yz), .y = (2.0 * (b.x * (-s * xy - xz * yz) + b.z * (s * yz - xy * xz)) + b.y * (s * s + xz * xz - xy * xy - yz * yz)), .z = (b.z * s * s + b.z * xy * xy - 2.0 * b.x * s * xz - 2.0 * b.y * s * yz - 2.0 * b.y * xy * xz - b.z * xz * xz - b.z * yz * yz + 2.0 * b.x * xy * yz), .w = (s * s + xy * xy + xz * xz + yz * yz)}; }
    constexpr PlaneIdeal Quaternion::sandwich(const PlaneIdeal& b) const noexcept { return {.x = (2.0 * (b.y * (s * xy - xz * yz) + b.z * (s * xz + xy * yz)) + b.x * (s * s + yz * yz - xy * xy - xz * xz)), .y = (2.0 * (b.x * (-s * xy - xz * yz) + b.z * (s * yz - xy * xz)) + b.y * (s * s + xz * xz - xy * xy - yz * yz)), .z = (2.0 * (b.x * (xy * yz - s * xz) + b.y * (-s * yz - xy * xz)) + b.z * (s * s + xy * xy - xz * xz - yz * yz))}; }
    constexpr BivectorBulk Quaternion::sandwich(const BivectorBulk& b) const noexcept { return {.xy = (2.0 * (b.xz * (s * yz + xy * xz) + b.yz * (xy * yz - s * xz)) + b.xy * (s * s + xy * xy - xz * xz - yz * yz)), .xz = (2.0 * (b.xy * (xy * xz - s * yz) + b.yz * (s * xy + xz * yz)) + b.xz * (s * s + xz * xz - xy * xy - yz * yz)), .yz = (2.0 * (b.xy * (s * xz + xy * yz) + b.xz * (xz * yz - s * xy)) + b.yz * (s * s + yz * yz - xy * xy - xz * xz))}; }
    constexpr BivectorWeight Quaternion::sandwich(const BivectorWeight& b) const noexcept { return {.wx = (2.0 * (b.wy * (s * xy - xz * yz) + b.wz * (s * xz + xy * yz)) + b.wx * (s * s + yz * yz - xy * xy - xz * xz)), .wy = (2.0 * (b.wx * (-s * xy - xz * yz) + b.wz * (s * yz - xy * xz)) + b.wy * (s * s + xz * xz - xy * xy - yz * yz)), .wz = (2.0 * (b.wx * (xy * yz - s * xz) + b.wy * (-s * yz - xy * xz)) + b.wz * (s * s + xy * xy - xz * xz - yz * yz))}; }
    constexpr PseudoScalar Quaternion::sandwich(const PseudoScalar& b) const noexcept { return {.i = b.i * (s * s + xy * xy + xz * xz + yz * yz)}; }
    constexpr ProjectivePoint Quaternion::sandwich(const PointCenter& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = (s * s + xy * xy + xz * xz + yz * yz)}; }

    constexpr Motor ProjectiveTranslator::sandwich(const Motor& b) const noexcept { return {.s = b.s * s * s, .wx = s * (2.0 * (-b.xy * wy - b.xz * wz) + b.wx * s), .wy = s * (2.0 * (b.xy * wx - b.yz * wz) + b.wy * s), .wz = s * (2.0 * (b.xz * wx + b.yz * wy) + b.wz * s), .xy = b.xy * s * s, .xz = b.xz * s * s, .yz = b.yz * s * s, .i = b.i * s * s}; }
    constexpr Plane ProjectiveTranslator::sandwich(const Plane& b) const noexcept { return {.x = b.x * s * s, .y = b.y * s * s, .z = b.z * s * s, .w = s * (2.0 * (b.x * wx + b.y * wy + b.z * wz) + b.w * s)}; }
    constexpr Bivector ProjectiveTranslator::sandwich(const Bivector& b) const noexcept { return {.wx = s * (2.0 * (-b.xy * wy - b.xz * wz) + b.wx * s), .wy = s * (2.0 * (b.xy * wx - b.yz * wz) + b.wy * s), .wz = s * (2.0 * (b.xz * wx + b.yz * wy) + b.wz * s), .xy = b.xy * s * s, .xz = b.xz * s * s, .yz = b.yz * s * s}; }
    constexpr ProjectivePoint ProjectiveTranslator::sandwich(const ProjectivePoint& b) const noexcept { return {.x = (b.x * s * s - 2.0 * b.w * s * wx), .y = s * (b.y * s - 2.0 * b.w * wy), .z = (b.z * s * s - 2.0 * b.w * s * wz), .w = b.w * s * s}; }
    constexpr Motor ProjectiveTranslator::sandwich(const Quaternion& b) const noexcept { return {.s = b.s * s * s, .wx = 2.0 * s * (-b.xy * wy - b.xz * wz), .wy = 2.0 * s * (b.xy * wx - b.yz * wz), .wz = 2.0 * s * (b.xz * wx + b.yz * wy), .xy = b.xy * s * s, .xz = b.xz * s * s, .yz = b.yz * s * s, .i = 0.0}; }
    constexpr ProjectiveTranslator ProjectiveTranslator::sandwich(const ProjectiveTranslator& b) const noexcept { return {.s = b.s * s * s, .wx = b.wx * s * s, .wy = b.wy * s * s, .wz = b.wz * s * s}; }
    constexpr ProjectiveTranslator ProjectiveTranslator::sandwich(const Translator& b) const noexcept { return {.s = s * s, .wx = b.wx * s * s, .wy = b.wy * s * s, .wz = b.wz * s * s}; }
    constexpr Vector ProjectiveTranslator::sandwich(const Vector& b) const noexcept { return {.x = b.x * s * s, .y = b.y * s * s, .z = b.z * s * s}; }
    constexpr ProjectivePoint ProjectiveTranslator::sandwich(const Point& b) const noexcept { return {.x = (-2.0 * s * wx + b.x * s * s), .y = s * (b.y * s - 2.0 * wy), .z = (-2.0 * s * wz + b.z * s * s), .w = s * s}; }
    constexpr Plane ProjectiveTranslator::sandwich(const PlaneIdeal& b) const noexcept { return {.x = b.x * s * s, .y = b.y * s * s, .z = b.z * s * s, .w = 2.0 * s * (b.x * wx + b.y * wy + b.z * wz)}; }
    constexpr Bivector ProjectiveTranslator::sandwich(const BivectorBulk& b) const noexcept { return {.wx = 2.0 * s * (-b.xy * wy - b.xz * wz), .wy = 2.0 * s * (b.xy * wx - b.yz * wz), .wz = 2.0 * s * (b.xz * wx + b.yz * wy), .xy = b.xy * s * s, .xz = b.xz * s * s, .yz = b.yz * s * s}; }
    constexpr BivectorWeight ProjectiveTranslator::sandwich(const BivectorWeight& b) const noexcept { return {.wx = b.wx * s * s, .wy = b.wy * s * s, .wz = b.wz * s * s}; }
    constexpr PseudoScalar ProjectiveTranslator::sandwich(const PseudoScalar& b) const noexcept { return {.i = b.i * s * s}; }
    constexpr ProjectivePoint ProjectiveTranslator::sandwich(const PointCenter& b) const noexcept { return {.x = -2.0 * s * wx, .y = -2.0 * s * wy, .z = -2.0 * s * wz, .w = s * s}; }

    constexpr Motor Translator::sandwich(const Motor& b) const noexcept { return {.s = b.s, .wx = (b.wx - 2.0 * b.xy * wy - 2.0 * b.xz * wz), .wy = (b.wy - 2.0 * b.yz * wz + 2.0 * b.xy * wx), .wz = (b.wz + 2.0 * b.xz * wx + 2.0 * b.yz * wy), .xy = b.xy, .xz = b.xz, .yz = b.yz, .i = b.i}; }
    constexpr Plane Translator::sandwich(const Plane& b) const noexcept { return {.x = b.x, .y = b.y, .z = b.z, .w = (b.w + 2.0 * b.x * wx + 2.0 * b.y * wy + 2.0 * b.z * wz)}; }
    constexpr Bivector Translator::sandwich(const Bivector& b) const noexcept { return {.wx = (b.wx - 2.0 * b.xy * wy - 2.0 * b.xz * wz), .wy = (b.wy - 2.0 * b.yz * wz + 2.0 * b.xy * wx), .wz = (b.wz + 2.0 * b.xz * wx + 2.0 * b.yz * wy), .xy = b.xy, .xz = b.xz, .yz = b.yz}; }
    constexpr ProjectivePoint Translator::sandwich(const ProjectivePoint& b) const noexcept { return {.x = (b.x - 2.0 * b.w * wx), .y = (b.y - 2.0 * b.w * wy), .z = (b.z - 2.0 * b.w * wz), .w = b.w}; }
    constexpr Motor Translator::sandwich(const Quaternion& b) const noexcept { return {.s = b.s, .wx = 2.0 * (-b.xy * wy - b.xz * wz), .wy = 2.0 * (b.xy * wx - b.yz * wz), .wz = 2.0 * (b.xz * wx + b.yz * wy), .xy = b.xy, .xz = b.xz, .yz = b.yz, .i = 0.0}; }
    constexpr ProjectiveTranslator Translator::sandwich(const ProjectiveTranslator& b) const noexcept { return {.s = b.s, .wx = b.wx, .wy = b.wy, .wz = b.wz}; }
    constexpr Translator Translator::sandwich(const Translator& b) const noexcept { return {.wx = b.wx, .wy = b.wy, .wz = b.wz}; }
    constexpr Vector Translator::sandwich(const Vector& b) const noexcept { return {.x = b.x, .y = b.y, .z = b.z}; }
    constexpr Point Translator::sandwich(const Point& b) const noexcept { return {.x = (b.x - 2.0 * wx), .y = (b.y - 2.0 * wy), .z = (b.z - 2.0 * wz)}; }
    constexpr Plane Translator::sandwich(const PlaneIdeal& b) const noexcept { return {.x = b.x, .y = b.y, .z = b.z, .w = 2.0 * (b.x * wx + b.y * wy + b.z * wz)}; }
    constexpr Bivector Translator::sandwich(const BivectorBulk& b) const noexcept { return {.wx = 2.0 * (-b.xy * wy - b.xz * wz), .wy = 2.0 * (b.xy * wx - b.yz * wz), .wz = 2.0 * (b.xz * wx + b.yz * wy), .xy = b.xy, .xz = b.xz, .yz = b.yz}; }
    constexpr BivectorWeight Translator::sandwich(const BivectorWeight& b) const noexcept { return {.wx = b.wx, .wy = b.wy, .wz = b.wz}; }
    constexpr PseudoScalar Translator::sandwich(const PseudoScalar& b) const noexcept { return {.i = b.i}; }
    constexpr Point Translator::sandwich(const PointCenter& b) const noexcept { return {.x = -2.0 * wx, .y = -2.0 * wy, .z = -2.0 * wz}; }

    constexpr Motor Point::sandwich(const Motor& b) const noexcept { return {.s = b.s, .wx = (-b.wx + 2.0 * (b.xy * y + b.xz * z)), .wy = (-b.wy + 2.0 * (b.yz * z - b.xy * x)), .wz = (-b.wz + 2.0 * (-b.xz * x - b.yz * y)), .xy = b.xy, .xz = b.xz, .yz = b.yz, .i = -b.i}; }
    constexpr Plane Point::sandwich(const Plane& b) const noexcept { return {.x = b.x, .y = b.y, .z = b.z, .w = (-b.w + 2.0 * (-b.x * x - b.y * y - b.z * z))}; }
    constexpr Bivector Point::sandwich(const Bivector& b) const noexcept { return {.wx = (-b.wx + 2.0 * (b.xy * y + b.xz * z)), .wy = (-b.wy + 2.0 * (b.yz * z - b.xy * x)), .wz = (-b.wz + 2.0 * (-b.xz * x - b.yz * y)), .xy = b.xy, .xz = b.xz, .yz = b.yz}; }
    constexpr ProjectivePoint Point::sandwich(const ProjectivePoint& b) const noexcept { return {.x = (-b.x + 2.0 * b.w * x), .y = (-b.y + 2.0 * b.w * y), .z = (-b.z + 2.0 * b.w * z), .w = b.w}; }
    constexpr Motor Point::sandwich(const Quaternion& b) const noexcept { return {.s = b.s, .wx = 2.0 * (b.xy * y + b.xz * z), .wy = 2.0 * (b.yz * z - b.xy * x), .wz = 2.0 * (-b.xz * x - b.yz * y), .xy = b.xy, .xz = b.xz, .yz = b.yz, .i = 0.0}; }
    constexpr ProjectiveTranslator Point::sandwich(const ProjectiveTranslator& b) const noexcept { return {.s = b.s, .wx = -b.wx, .wy = -b.wy, .wz = -b.wz}; }
    constexpr Translator Point::sandwich(const Translator& b) const noexcept { return {.wx = -b.wx, .wy = -b.wy, .wz = -b.wz}; }
    constexpr Vector Point::sandwich(const Vector& b) const noexcept { return {.x = -b.x, .y = -b.y, .z = -b.z}; }
    constexpr Point Point::sandwich(const Point& b) const noexcept { return {.x = (-b.x + 2.0 * x), .y = (-b.y + 2.0 * y), .z = (-b.z + 2.0 * z)}; }
    constexpr Plane Point::sandwich(const PlaneIdeal& b) const noexcept { return {.x = b.x, .y = b.y, .z = b.z, .w = 2.0 * (-b.x * x - b.y * y - b.z * z)}; }
    constexpr Bivector Point::sandwich(const BivectorBulk& b) const noexcept { return {.wx = 2.0 * (b.xy * y + b.xz * z), .wy = 2.0 * (b.yz * z - b.xy * x), .wz = 2.0 * (-b.xz * x - b.yz * y), .xy = b.xy, .xz = b.xz, .yz = b.yz}; }
    constexpr BivectorWeight Point::sandwich(const BivectorWeight& b) const noexcept { return {.wx = -b.wx, .wy = -b.wy, .wz = -b.wz}; }
    constexpr PseudoScalar Point::sandwich(const PseudoScalar& b) const noexcept { return {.i = -b.i}; }
    constexpr Point Point::sandwich(const PointCenter& b) const noexcept { return {.x = 2.0 * x, .y = 2.0 * y, .z = 2.0 * z}; }

    constexpr Motor PlaneIdeal::sandwich(const Motor& b) const noexcept { return {.s = b.s * (x * x + y * y + z * z), .wx = (b.wx * (y * y + z * z - x * x) + 2.0 * x * (-b.wy * y - b.wz * z)), .wy = (b.wy * (x * x + z * z - y * y) + 2.0 * y * (-b.wx * x - b.wz * z)), .wz = (b.wz * (x * x + y * y - z * z) + 2.0 * z * (-b.wx * x - b.wy * y)), .xy = (b.xy * (z * z - x * x - y * y) + 2.0 * z * (b.yz * x - b.xz * y)), .xz = (b.xz * (y * y - x * x - z * z) + 2.0 * y * (-b.xy * z - b.yz * x)), .yz = (b.yz * (x * x - y * y - z * z) + 2.0 * x * (b.xy * z - b.xz * y)), .i = b.i * (-x * x - y * y - z * z)}; }
    constexpr Plane PlaneIdeal::sandwich(const Plane& b) const noexcept { return {.x = (b.x * (x * x - y * y - z * z) + 2.0 * x * (b.y * y + b.z * z)), .y = (b.y * (y * y - x * x - z * z) + 2.0 * y * (b.x * x + b.z * z)), .z = (b.z * (z * z - x * x - y * y) + 2.0 * z * (b.x * x + b.y * y)), .w = b.w * (-x * x - y * y - z * z)}; }
    constexpr Bivector PlaneIdeal::sandwich(const Bivector& b) const noexcept { return {.wx = (b.wx * (y * y + z * z - x * x) + 2.0 * x * (-b.wy * y - b.wz * z)), .wy = (b.wy * (x * x + z * z - y * y) + 2.0 * y * (-b.wx * x - b.wz * z)), .wz = (b.wz * (x * x + y * y - z * z) + 2.0 * z * (-b.wx * x - b.wy * y)), .xy = (b.xy * (z * z - x * x - y * y) + 2.0 * z * (b.yz * x - b.xz * y)), .xz = (b.xz * (y * y - x * x - z * z) + 2.0 * y * (-b.xy * z - b.yz * x)), .yz = (b.yz * (x * x - y * y - z * z) + 2.0 * x * (b.xy * z - b.xz * y))}; }
    constexpr ProjectivePoint PlaneIdeal::sandwich(const ProjectivePoint& b) const noexcept { return {.x = (b.x * y * y + b.x * z * z - 2.0 * b.y * x * y - 2.0 * b.z * x * z - b.x * x * x), .y = (b.y * (x * x + z * z - y * y) + 2.0 * y * (-b.x * x - b.z * z)), .z = (b.z * x * x + b.z * y * y - 2.0 * b.x * x * z - 2.0 * b.y * y * z - b.z * z * z), .w = b.w * (x * x + y * y + z * z)}; }
    constexpr Quaternion PlaneIdeal::sandwich(const Quaternion& b) const noexcept { return {.s = b.s * (x * x + y * y + z * z), .xy = (b.xy * (z * z - x * x - y * y) + 2.0 * z * (b.yz * x - b.xz * y)), .xz = (b.xz * (y * y - x * x - z * z) + 2.0 * y * (-b.xy * z - b.yz * x)), .yz = (b.yz * (x * x - y * y - z * z) + 2.0 * x * (b.xy * z - b.xz * y))}; }
    constexpr ProjectiveTranslator PlaneIdeal::sandwich(const ProjectiveTranslator& b) const noexcept { return {.s = b.s * (x * x + y * y + z * z), .wx = (b.wx * (y * y + z * z - x * x) + 2.0 * x * (-b.wy * y - b.wz * z)), .wy = (b.wy * (x * x + z * z - y * y) + 2.0 * y * (-b.wx * x - b.wz * z)), .wz = (b.wz * (x * x + y * y - z * z) + 2.0 * z * (-b.wx * x - b.wy * y))}; }
    constexpr ProjectiveTranslator PlaneIdeal::sandwich(const Translator& b) const noexcept { return {.s = (x * x + y * y + z * z), .wx = (b.wx * (y * y + z * z - x * x) + 2.0 * x * (-b.wy * y - b.wz * z)), .wy = (b.wy * (x * x + z * z - y * y) + 2.0 * y * (-b.wx * x - b.wz * z)), .wz = (b.wz * (x * x + y * y - z * z) + 2.0 * z * (-b.wx * x - b.wy * y))}; }
    constexpr Vector PlaneIdeal::sandwich(const Vector& b) const noexcept { return {.x = (b.x * y * y + b.x * z * z - 2.0 * b.y * x * y - 2.0 * b.z * x * z - b.x * x * x), .y = (b.y * (x * x + z * z - y * y) + 2.0 * y * (-b.x * x - b.z * z)), .z = (b.z * x * x + b.z * y * y - 2.0 * b.x * x * z - 2.0 * b.y * y * z - b.z * z * z)}; }
    constexpr ProjectivePoint PlaneIdeal::sandwich(const Point& b) const noexcept { return {.x = (b.x * y * y + b.x * z * z - 2.0 * b.y * x * y - 2.0 * b.z * x * z - b.x * x * x), .y = (b.y * (x * x + z * z - y * y) + 2.0 * y * (-b.x * x - b.z * z)), .z = (b.z * x * x + b.z * y * y - 2.0 * b.x * x * z - 2.0 * b.y * y * z - b.z * z * z), .w = (x * x + y * y + z * z)}; }
    constexpr PlaneIdeal PlaneIdeal::sandwich(const PlaneIdeal& b) const noexcept { return {.x = (b.x * (x * x - y * y - z * z) + 2.0 * x * (b.y * y + b.z * z)), .y = (b.y * (y * y - x * x - z * z) + 2.0 * y * (b.x * x + b.z * z)), .z = (b.z * (z * z - x * x - y * y) + 2.0 * z * (b.x * x + b.y * y))}; }
    constexpr BivectorBulk PlaneIdeal::sandwich(const BivectorBulk& b) const noexcept { return {.xy = (b.xy * (z * z - x * x - y * y) + 2.0 * z * (b.yz * x - b.xz * y)), .xz = (b.xz * (y * y - x * x - z * z) + 2.0 * y * (-b.xy * z - b.yz * x)), .yz = (b.yz * (x * x - y * y - z * z) + 2.0 * x * (b.xy * z - b.xz * y))}; }
    constexpr BivectorWeight PlaneIdeal::sandwich(const BivectorWeight& b) const noexcept { return {.wx = (b.wx * (y * y + z * z - x * x) + 2.0 * x * (-b.wy * y - b.wz * z)), .wy = (b.wy * (x * x + z * z - y * y) + 2.0 * y * (-b.wx * x - b.wz * z)), .wz = (b.wz * (x * x + y * y - z * z) + 2.0 * z * (-b.wx * x - b.wy * y))}; }
    constexpr PseudoScalar PlaneIdeal::sandwich(const PseudoScalar& b) const noexcept { return {.i = b.i * (-x * x - y * y - z * z)}; }
    constexpr ProjectivePoint PlaneIdeal::sandwich(const PointCenter& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = (x * x + y * y + z * z)}; }

    constexpr Motor BivectorBulk::sandwich(const Motor& b) const noexcept { return {.s = b.s * (xy * xy + xz * xz + yz * yz), .wx = (b.wx * (yz * yz - xy * xy - xz * xz) + 2.0 * yz * (b.wz * xy - b.wy * xz)), .wy = (b.wy * (xz * xz - xy * xy - yz * yz) + 2.0 * xz * (-b.wx * yz - b.wz * xy)), .wz = (b.wz * (xy * xy - xz * xz - yz * yz) + 2.0 * xy * (b.wx * yz - b.wy * xz)), .xy = (b.xy * (xy * xy - xz * xz - yz * yz) + 2.0 * xy * (b.xz * xz + b.yz * yz)), .xz = (b.xz * (xz * xz - xy * xy - yz * yz) + 2.0 * xz * (b.xy * xy + b.yz * yz)), .yz = (b.yz * (yz * yz - xy * xy - xz * xz) + 2.0 * yz * (b.xy * xy + b.xz * xz)), .i = b.i * (xy * xy + xz * xz + yz * yz)}; }
    constexpr Plane BivectorBulk::sandwich(const Plane& b) const noexcept { return {.x = (b.x * (yz * yz - xy * xy - xz * xz) + 2.0 * yz * (b.z * xy - b.y * xz)), .y = (b.y * (xz * xz - xy * xy - yz * yz) + 2.0 * xz * (-b.x * yz - b.z * xy)), .z = (b.z * (xy * xy - xz * xz - yz * yz) + 2.0 * xy * (b.x * yz - b.y * xz)), .w = b.w * (xy * xy + xz * xz + yz * yz)}; }
    constexpr Bivector BivectorBulk::sandwich(const Bivector& b) const noexcept { return {.wx = (b.wx * (yz * yz - xy * xy - xz * xz) + 2.0 * yz * (b.wz * xy - b.wy * xz)), .wy = (b.wy * (xz * xz - xy * xy - yz * yz) + 2.0 * xz * (-b.wx * yz - b.wz * xy)), .wz = (b.wz * (xy * xy - xz * xz - yz * yz) + 2.0 * xy * (b.wx * yz - b.wy * xz)), .xy = (b.xy * (xy * xy - xz * xz - yz * yz) + 2.0 * xy * (b.xz * xz + b.yz * yz)), .xz = (b.xz * (xz * xz - xy * xy - yz * yz) + 2.0 * xz * (b.xy * xy + b.yz * yz)), .yz = (b.yz * (yz * yz - xy * xy - xz * xz) + 2.0 * yz * (b.xy * xy + b.xz * xz))}; }
    constexpr ProjectivePoint BivectorBulk::sandwich(const ProjectivePoint& b) const noexcept { return {.x = (b.x * yz * yz - 2.0 * b.y * xz * yz - b.x * xy * xy - b.x * xz * xz + 2.0 * b.z * xy * yz), .y = (b.y * (xz * xz - xy * xy - yz * yz) + 2.0 * xz * (-b.x * yz - b.z * xy)), .z = (b.z * xy * xy - 2.0 * b.y * xy * xz - b.z * xz * xz - b.z * yz * yz + 2.0 * b.x * xy * yz), .w = b.w * (xy * xy + xz * xz + yz * yz)}; }
    constexpr Quaternion BivectorBulk::sandwich(const Quaternion& b) const noexcept { return {.s = b.s * (xy * xy + xz * xz + yz * yz), .xy = (b.xy * (xy * xy - xz * xz - yz * yz) + 2.0 * xy * (b.xz * xz + b.yz * yz)), .xz = (b.xz * (xz * xz - xy * xy - yz * yz) + 2.0 * xz * (b.xy * xy + b.yz * yz)), .yz = (b.yz * (yz * yz - xy * xy - xz * xz) + 2.0 * yz * (b.xy * xy + b.xz * xz))}; }
    constexpr ProjectiveTranslator BivectorBulk::sandwich(const ProjectiveTranslator& b) const noexcept { return {.s = b.s * (xy * xy + xz * xz + yz * yz), .wx = (b.wx * (yz * yz - xy * xy - xz * xz) + 2.0 * yz * (b.wz * xy - b.wy * xz)), .wy = (b.wy * (xz * xz - xy * xy - yz * yz) + 2.0 * xz * (-b.wx * yz - b.wz * xy)), .wz = (b.wz * (xy * xy - xz * xz - yz * yz) + 2.0 * xy * (b.wx * yz - b.wy * xz))}; }
    constexpr ProjectiveTranslator BivectorBulk::sandwich(const Translator& b) const noexcept { return {.s = (xy * xy + xz * xz + yz * yz), .wx = (b.wx * (yz * yz - xy * xy - xz * xz) + 2.0 * yz * (b.wz * xy - b.wy * xz)), .wy = (b.wy * (xz * xz - xy * xy - yz * yz) + 2.0 * xz * (-b.wx * yz - b.wz * xy)), .wz = (b.wz * (xy * xy - xz * xz - yz * yz) + 2.0 * xy * (b.wx * yz - b.wy * xz))}; }
    constexpr Vector BivectorBulk::sandwich(const Vector& b) const noexcept { return {.x = (b.x * yz * yz - 2.0 * b.y * xz * yz - b.x * xy * xy - b.x * xz * xz + 2.0 * b.z * xy * yz), .y = (b.y * (xz * xz - xy * xy - yz * yz) + 2.0 * xz * (-b.x * yz - b.z * xy)), .z = (b.z * xy * xy - 2.0 * b.y * xy * xz - b.z * xz * xz - b.z * yz * yz + 2.0 * b.x * xy * yz)}; }
    constexpr ProjectivePoint BivectorBulk::sandwich(const Point& b) const noexcept { return {.x = (b.x * yz * yz - 2.0 * b.y * xz * yz - b.x * xy * xy - b.x * xz * xz + 2.0 * b.z * xy * yz), .y = (b.y * (xz * xz - xy * xy - yz * yz) + 2.0 * xz * (-b.x * yz - b.z * xy)), .z = (b.z * xy * xy - 2.0 * b.y * xy * xz - b.z * xz * xz - b.z * yz * yz + 2.0 * b.x * xy * yz), .w = (xy * xy + xz * xz + yz * yz)}; }
    constexpr PlaneIdeal BivectorBulk::sandwich(const PlaneIdeal& b) const noexcept { return {.x = (b.x * (yz * yz - xy * xy - xz * xz) + 2.0 * yz * (b.z * xy - b.y * xz)), .y = (b.y * (xz * xz - xy * xy - yz * yz) + 2.0 * xz * (-b.x * yz - b.z * xy)), .z = (b.z * (xy * xy - xz * xz - yz * yz) + 2.0 * xy * (b.x * yz - b.y * xz))}; }
    constexpr BivectorBulk BivectorBulk::sandwich(const BivectorBulk& b) const noexcept { return {.xy = (b.xy * (xy * xy - xz * xz - yz * yz) + 2.0 * xy * (b.xz * xz + b.yz * yz)), .xz = (b.xz * (xz * xz - xy * xy - yz * yz) + 2.0 * xz * (b.xy * xy + b.yz * yz)), .yz = (b.yz * (yz * yz - xy * xy - xz * xz) + 2.0 * yz * (b.xy * xy + b.xz * xz))}; }
    constexpr BivectorWeight BivectorBulk::sandwich(const BivectorWeight& b) const noexcept { return {.wx = (b.wx * (yz * yz - xy * xy - xz * xz) + 2.0 * yz * (b.wz * xy - b.wy * xz)), .wy = (b.wy * (xz * xz - xy * xy - yz * yz) + 2.0 * xz * (-b.wx * yz - b.wz * xy)), .wz = (b.wz * (xy * xy - xz * xz - yz * yz) + 2.0 * xy * (b.wx * yz - b.wy * xz))}; }
    constexpr PseudoScalar BivectorBulk::sandwich(const PseudoScalar& b) const noexcept { return {.i = b.i * (xy * xy + xz * xz + yz * yz)}; }
    constexpr ProjectivePoint BivectorBulk::sandwich(const PointCenter& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = (xy * xy + xz * xz + yz * yz)}; }

    constexpr Motor PointCenter::sandwich(const Motor& b) const noexcept { return {.s = b.s, .wx = -b.wx, .wy = -b.wy, .wz = -b.wz, .xy = b.xy, .xz = b.xz, .yz = b.yz, .i = -b.i}; }
    constexpr Plane PointCenter::sandwich(const Plane& b) const noexcept { return {.x = b.x, .y = b.y, .z = b.z, .w = -b.w}; }
    constexpr Bivector PointCenter::sandwich(const Bivector& b) const noexcept { return {.wx = -b.wx, .wy = -b.wy, .wz = -b.wz, .xy = b.xy, .xz = b.xz, .yz = b.yz}; }
    constexpr ProjectivePoint PointCenter::sandwich(const ProjectivePoint& b) const noexcept { return {.x = -b.x, .y = -b.y, .z = -b.z, .w = b.w}; }
    constexpr Quaternion PointCenter::sandwich(const Quaternion& b) const noexcept { return {.s = b.s, .xy = b.xy, .xz = b.xz, .yz = b.yz}; }
    constexpr ProjectiveTranslator PointCenter::sandwich(const ProjectiveTranslator& b) const noexcept { return {.s = b.s, .wx = -b.wx, .wy = -b.wy, .wz = -b.wz}; }
    constexpr Translator PointCenter::sandwich(const Translator& b) const noexcept { return {.wx = -b.wx, .wy = -b.wy, .wz = -b.wz}; }
    constexpr Vector PointCenter::sandwich(const Vector& b) const noexcept { return {.x = -b.x, .y = -b.y, .z = -b.z}; }
    constexpr Point PointCenter::sandwich(const Point& b) const noexcept { return {.x = -b.x, .y = -b.y, .z = -b.z}; }
    constexpr PlaneIdeal PointCenter::sandwich(const PlaneIdeal& b) const noexcept { return {.x = b.x, .y = b.y, .z = b.z}; }
    constexpr BivectorBulk PointCenter::sandwich(const BivectorBulk& b) const noexcept { return {.xy = b.xy, .xz = b.xz, .yz = b.yz}; }
    constexpr BivectorWeight PointCenter::sandwich(const BivectorWeight& b) const noexcept { return {.wx = -b.wx, .wy = -b.wy, .wz = -b.wz}; }
    constexpr PseudoScalar PointCenter::sandwich(const PseudoScalar& b) const noexcept { return {.i = -b.i}; }
    constexpr PointCenter PointCenter::sandwich(const PointCenter& b) const noexcept { return {}; }

}

// opsReverseSandwich.h

// generated by com.github.kright.pga3d.codegen.cpp.ops.ReverseSandwichOpGenerator

namespace pga3d {
    constexpr Multivector Multivector::reverseSandwich(const Multivector& b) const noexcept { return {.s = (2.0 * (b.x * (s * x + xy * y + xyz * yz + xz * z) + b.y * (s * y + yz * z - x * xy - xyz * xz) + b.z * (s * z + xy * xyz - x * xz - y * yz)) + b.s * (s * s + x * x + xy * xy + xyz * xyz + xz * xz + y * y + yz * yz + z * z)), .w = (2.0 * (b.i * (x * yz + xy * z - s * xyz - xz * y) + b.s * (s * w + wxy * xy + wxz * xz + wyz * yz - i * xyz - wx * x - wy * y - wz * z) + b.x * (w * x + wxy * y + wxz * z + wyz * xyz - i * yz - s * wx - wy * xy - wz * xz) + b.y * (i * xz + w * y + wx * xy + wyz * z - s * wy - wxy * x - wxz * xyz - wz * yz) + b.z * (w * z + wx * xz + wxy * xyz + wy * yz - i * xy - s * wz - wxz * x - wyz * y)) + b.w * (s * s + xy * xy + xz * xz + yz * yz - x * x - xyz * xyz - y * y - z * z)), .x = (2.0 * (b.s * (s * x + xyz * yz - xy * y - xz * z) + b.y * (x * y + xyz * z - s * xy - xz * yz) + b.z * (x * z + xy * yz - s * xz - xyz * y)) + b.x * (s * s + x * x + xyz * xyz + yz * yz - xy * xy - xz * xz - y * y - z * z)), .y = (2.0 * (b.s * (s * y + x * xy - xyz * xz - yz * z) + b.x * (s * xy + x * y - xyz * z - xz * yz) + b.z * (x * xyz + y * z - s * yz - xy * xz)) + b.y * (s * s + xyz * xyz + xz * xz + y * y - x * x - xy * xy - yz * yz - z * z)), .z = (2.0 * (b.s * (s * z + x * xz + xy * xyz + y * yz) + b.x * (s * xz + x * z + xy * yz + xyz * y) + b.y * (s * yz + y * z - x * xyz - xy * xz)) + b.z * (s * s + xy * xy + xyz * xyz + z * z - x * x - xz * xz - y * y - yz * yz)), .wx = (2.0 * (s * (b.xy * wy + b.xyz * wyz + b.xz * wz - b.wyz * xyz - b.yz * i) + x * (b.wyz * yz + b.xy * wxy + b.xz * wxz + b.yz * wyz - b.xyz * i) + xy * (b.wxy * x + b.wz * yz + b.xy * wx + b.xyz * wxz - b.wxz * xyz - b.wy * s - b.wyz * z - b.xz * i - b.yz * wz) + xyz * (b.xy * wxz + b.xyz * wx - b.xz * wxy - b.yz * w) + xz * (b.wxy * xyz + b.wxz * x + b.xy * i + b.xz * wx + b.yz * wy - b.wy * yz - b.wz * s - b.xyz * wxy) + y * (b.wxy * s + b.wyz * xz + b.wz * xyz + b.xy * w + b.yz * wxz - b.wxz * yz - b.wy * x - b.xyz * wz - b.xz * wyz) + yz * (b.xy * wz + b.yz * wx - b.xyz * w - b.xz * wy) + z * (b.wxy * yz + b.wxz * s + b.xy * wyz + b.xyz * wy + b.xz * w - b.wy * xyz - b.wz * x - b.yz * wxy)) + b.wx * (s * s + y * y + yz * yz + z * z - x * x - xy * xy - xyz * xyz - xz * xz)), .wy = (2.0 * (s * (b.wxz * xyz + b.xz * i + b.yz * wz - b.xy * wx - b.xyz * wxz) + x * (b.wxz * yz + b.xyz * wz + b.xz * wyz - b.wx * y - b.wxy * s - b.wyz * xz - b.wz * xyz - b.xy * w - b.yz * wxz) + xy * (b.wx * s + b.wxy * y + b.xy * wy + b.xyz * wyz + b.xz * wz - b.wyz * xyz - b.wz * xz - b.yz * i) + xyz * (b.xy * wyz + b.xyz * wy + b.xz * w - b.yz * wxy) + xz * (b.wxz * y + b.xyz * w + b.xz * wy - b.xy * wz - b.yz * wx) + y * (b.xy * wxy + b.xz * wxz + b.yz * wyz - b.xyz * i) + yz * (b.wxy * xyz + b.wyz * y + b.xy * i + b.xz * wx + b.yz * wy - b.wx * xz - b.wz * s - b.xyz * wxy) + z * (b.wx * xyz + b.wxz * xy + b.wyz * s + b.xz * wxy + b.yz * w - b.wxy * xz - b.wz * y - b.xy * wxz - b.xyz * wx)) + b.wy * (s * s + x * x + xz * xz + z * z - xy * xy - xyz * xyz - y * y - yz * yz)), .wz = (2.0 * (s * (b.xyz * wxy - b.wxy * xyz - b.xy * i - b.xz * wx - b.yz * wy) + x * (b.wy * xyz + b.wyz * xy + b.yz * wxy - b.wx * z - b.wxy * yz - b.wxz * s - b.xy * wyz - b.xyz * wy - b.xz * w) + xy * (b.xy * wz + b.yz * wx - b.xyz * w - b.xz * wy) + xyz * (b.xyz * wz + b.xz * wyz - b.xy * w - b.yz * wxz) + xz * (b.wx * s + b.wxz * z + b.xy * wy + b.xyz * wyz + b.xz * wz - b.wy * xy - b.wyz * xyz - b.yz * i) + y * (b.wxy * xz + b.xy * wxz + b.xyz * wx - b.wx * xyz - b.wxz * xy - b.wy * z - b.wyz * s - b.xz * wxy - b.yz * w) + yz * (b.wx * xy + b.wxz * xyz + b.wy * s + b.wyz * z + b.xz * i + b.yz * wz - b.xy * wx - b.xyz * wxz) + z * (b.wxy * xy + b.xy * wxy + b.xz * wxz + b.yz * wyz - b.xyz * i)) + b.wz * (s * s + x * x + xy * xy + y * y - xyz * xyz - xz * xz - yz * yz - z * z)), .xy = (2.0 * (b.xyz * (s * z + x * xz + xy * xyz + y * yz) + b.xz * (x * xyz + xy * xz - s * yz - y * z) + b.yz * (s * xz + x * z + xy * yz + xyz * y)) + b.xy * (s * s + xy * xy + xyz * xyz + z * z - x * x - xz * xz - y * y - yz * yz)), .xz = (2.0 * (b.xy * (s * yz + xy * xz - x * xyz - y * z) + b.xyz * (xyz * xz + yz * z - s * y - x * xy) + b.yz * (xyz * z + xz * yz - s * xy - x * y)) + b.xz * (s * s + xyz * xyz + xz * xz + y * y - x * x - xy * xy - yz * yz - z * z)), .yz = (2.0 * (b.xy * (x * z + xy * yz - s * xz - xyz * y) + b.xyz * (s * x + xyz * yz - xy * y - xz * z) + b.xz * (s * xy + xz * yz - x * y - xyz * z)) + b.yz * (s * s + x * x + xyz * xyz + yz * yz - xy * xy - xz * xz - y * y - z * z)), .wxy = (2.0 * (s * (b.xy * w + b.yz * wxz - b.xyz * wz - b.xz * wyz) + x * (b.wz * yz + b.xy * wx + b.xyz * wxz - b.wx * xy - b.wxz * xyz - b.wy * s - b.wyz * z - b.xz * i - b.yz * wz) + xy * (b.xy * wxy + b.xz * wxz + b.yz * wyz - b.wz * z - b.xyz * i) + xyz * (b.wz * s + b.xyz * wxy - b.xy * i - b.xz * wx - b.yz * wy) + xz * (b.wx * xyz + b.wxz * xy + b.wy * z + b.wyz * s + b.xz * wxy + b.yz * w - b.xy * wxz - b.xyz * wx) + y * (b.wx * s + b.wxz * z + b.xy * wy + b.xyz * wyz + b.xz * wz - b.wy * xy - b.wyz * xyz - b.wz * xz - b.yz * i) + yz * (b.wy * xyz + b.wyz * xy + b.yz * wxy - b.wx * z - b.wxz * s - b.xy * wyz - b.xyz * wy - b.xz * w) + z * (b.xyz * w + b.xz * wy - b.xy * wz - b.yz * wx)) + b.wxy * (s * s + x * x + xy * xy + y * y - xyz * xyz - xz * xz - yz * yz - z * z)), .wxz = (2.0 * (s * (b.xy * wyz + b.xyz * wy + b.xz * w - b.wy * xyz - b.yz * wxy) + x * (b.wxy * xyz + b.wyz * y + b.xy * i + b.xz * wx + b.yz * wy - b.wx * xz - b.wy * yz - b.wz * s - b.xyz * wxy) + xy * (b.wxy * xz + b.wz * y + b.xy * wxz + b.xyz * wx - b.wx * xyz - b.wy * z - b.wyz * s - b.xz * wxy - b.yz * w) + xyz * (b.xy * wx + b.xyz * wxz - b.xz * i - b.yz * wz) + xz * (b.xy * wxy + b.xz * wxz + b.yz * wyz - b.wy * y - b.xyz * i) + y * (b.xy * wz + b.yz * wx - b.xyz * w - b.xz * wy) + yz * (b.wx * y + b.wxy * s + b.wyz * xz + b.wz * xyz + b.xy * w + b.yz * wxz - b.xyz * wz - b.xz * wyz) + z * (b.wx * s + b.wxy * y + b.xy * wy + b.xyz * wyz + b.xz * wz - b.wyz * xyz - b.wz * xz - b.yz * i)) + b.wxz * (s * s + x * x + xz * xz + z * z - xy * xy - xyz * xyz - y * y - yz * yz)), .wyz = (2.0 * (s * (b.wx * xyz + b.wxz * xy + b.wy * z + b.xz * wxy + b.yz * w - b.wxy * xz - b.wz * y - b.xy * wxz - b.xyz * wx) + x * (b.wxz * y + b.wy * xz + b.xyz * w + b.xz * wy - b.wx * yz - b.wxy * z - b.wz * xy - b.xy * wz - b.yz * wx) + xy * (b.xy * wyz + b.xyz * wy + b.xz * w - b.yz * wxy) + xyz * (b.wxy * y + b.wxz * z + b.xy * wy + b.xyz * wyz + b.xz * wz - b.wy * xy - b.wz * xz - b.yz * i) + xz * (b.xyz * wz + b.xz * wyz - b.wx * y - b.xy * w - b.yz * wxz) + y * (b.xy * i + b.xz * wx + b.yz * wy - b.xyz * wxy) + yz * (b.wxy * xy + b.wxz * xz + b.xy * wxy + b.xz * wxz + b.yz * wyz - b.wy * y - b.wz * z - b.xyz * i) + z * (b.wx * xy + b.xz * i + b.yz * wz - b.xy * wx - b.xyz * wxz)) + b.wyz * (s * s + y * y + yz * yz + z * z - x * x - xy * xy - xyz * xyz - xz * xz)), .xyz = (2.0 * (b.xy * (s * z + xy * xyz - x * xz - y * yz) + b.xz * (x * xy + xyz * xz - s * y - yz * z) + b.yz * (s * x + xy * y + xyz * yz + xz * z)) + b.xyz * (s * s + x * x + xy * xy + xyz * xyz + xz * xz + y * y + yz * yz + z * z)), .i = (2.0 * (b.s * (i * s + w * xyz + wxz * y + wy * xz - wx * yz - wxy * z - wyz * x - wz * xy) + b.w * (s * xyz + xz * y - x * yz - xy * z) + b.x * (i * x + w * yz + wxz * xy + wy * z - s * wyz - wx * xyz - wxy * xz - wz * y) + b.y * (i * y + s * wxz + wyz * xy + wz * x - w * xz - wx * z - wxy * yz - wy * xyz) + b.z * (i * z + w * xy + wx * y + wyz * xz - s * wxy - wxz * yz - wy * x - wz * xyz)) + b.i * (s * s + xy * xy + xz * xz + yz * yz - x * x - xyz * xyz - y * y - z * z))}; }

    constexpr Motor Motor::reverseSandwich(const Motor& b) const noexcept { return {.s = b.s * (s * s + xy * xy + xz * xz + yz * yz), .wx = (2.0 * (s * (b.xy * wy + b.xz * wz - b.wy * xy - b.wz * xz - b.yz * i) + xy * (b.xy * wx - b.xz * i - b.yz * wz) + xz * (b.xy * i + b.xz * wx + b.yz * wy) + yz * (b.wz * xy + b.xy * wz + b.yz * wx - b.wy * xz - b.xz * wy)) + b.wx * (s * s + yz * yz - xy * xy - xz * xz)), .wy = (2.0 * (s * (b.wx * xy + b.xz * i + b.yz * wz - b.wz * yz - b.xy * wx) + xy * (b.xy * wy + b.xz * wz - b.yz * i) + xz * (b.xz * wy - b.wx * yz - b.wz * xy - b.xy * wz - b.yz * wx) + yz * (b.xy * i + b.xz * wx + b.yz * wy)) + b.wy * (s * s + xz * xz - xy * xy - yz * yz)), .wz = (2.0 * (s * (b.wx * xz + b.wy * yz - b.xy * i - b.xz * wx - b.yz * wy) + xy * (b.wx * yz + b.xy * wz + b.yz * wx - b.wy * xz - b.xz * wy) + xz * (b.xy * wy + b.xz * wz - b.yz * i) + yz * (b.xz * i + b.yz * wz - b.xy * wx)) + b.wz * (s * s + xy * xy - xz * xz - yz * yz)), .xy = (2.0 * (b.xz * (xy * xz - s * yz) + b.yz * (s * xz + xy * yz)) + b.xy * (s * s + xy * xy - xz * xz - yz * yz)), .xz = (2.0 * (b.xy * (s * yz + xy * xz) + b.yz * (xz * yz - s * xy)) + b.xz * (s * s + xz * xz - xy * xy - yz * yz)), .yz = (2.0 * (b.xy * (xy * yz - s * xz) + b.xz * (s * xy + xz * yz)) + b.yz * (s * s + yz * yz - xy * xy - xz * xz)), .i = (b.i * (s * s + xy * xy + xz * xz + yz * yz) + 2.0 * b.s * (i * s + wy * xz - wx * yz - wz * xy))}; }
    constexpr Plane Motor::reverseSandwich(const Plane& b) const noexcept { return {.x = (2.0 * (b.y * (-s * xy - xz * yz) + b.z * (xy * yz - s * xz)) + b.x * (s * s + yz * yz - xy * xy - xz * xz)), .y = (2.0 * (b.x * (s * xy - xz * yz) + b.z * (-s * yz - xy * xz)) + b.y * (s * s + xz * xz - xy * xy - yz * yz)), .z = (2.0 * (b.x * (s * xz + xy * yz) + b.y * (s * yz - xy * xz)) + b.z * (s * s + xy * xy - xz * xz - yz * yz)), .w = (2.0 * (b.x * (-i * yz - s * wx - wy * xy - wz * xz) + b.y * (i * xz + wx * xy - s * wy - wz * yz) + b.z * (wx * xz + wy * yz - i * xy - s * wz)) + b.w * (s * s + xy * xy + xz * xz + yz * yz))}; }
    constexpr Bivector Motor::reverseSandwich(const Bivector& b) const noexcept { return {.wx = (2.0 * (s * (b.xy * wy + b.xz * wz - b.wy * xy - b.wz * xz - b.yz * i) + xy * (b.xy * wx - b.xz * i - b.yz * wz) + xz * (b.xy * i + b.xz * wx + b.yz * wy) + yz * (b.wz * xy + b.xy * wz + b.yz * wx - b.wy * xz - b.xz * wy)) + b.wx * (s * s + yz * yz - xy * xy - xz * xz)), .wy = (2.0 * (s * (b.wx * xy + b.xz * i + b.yz * wz - b.wz * yz - b.xy * wx) + xy * (b.xy * wy + b.xz * wz - b.yz * i) + xz * (b.xz * wy - b.wx * yz - b.wz * xy - b.xy * wz - b.yz * wx) + yz * (b.xy * i + b.xz * wx + b.yz * wy)) + b.wy * (s * s + xz * xz - xy * xy - yz * yz)), .wz = (2.0 * (s * (b.wx * xz + b.wy * yz - b.xy * i - b.xz * wx - b.yz * wy) + xy * (b.wx * yz + b.xy * wz + b.yz * wx - b.wy * xz - b.xz * wy) + xz * (b.xy * wy + b.xz * wz - b.yz * i) + yz * (b.xz * i + b.yz * wz - b.xy * wx)) + b.wz * (s * s + xy * xy - xz * xz - yz * yz)), .xy = (2.0 * (b.xz * (xy * xz - s * yz) + b.yz * (s * xz + xy * yz)) + b.xy * (s * s + xy * xy - xz * xz - yz * yz)), .xz = (2.0 * (b.xy * (s * yz + xy * xz) + b.yz * (xz * yz - s * xy)) + b.xz * (s * s + xz * xz - xy * xy - yz * yz)), .yz = (2.0 * (b.xy * (xy * yz - s * xz) + b.xz * (s * xy + xz * yz)) + b.yz * (s * s + yz * yz - xy * xy - xz * xz))}; }
    constexpr ProjectivePoint Motor::reverseSandwich(const ProjectivePoint& b) const noexcept { return {.x = (b.x * s * s + b.x * yz * yz - 2.0 * b.w * wy * xy - 2.0 * b.w * wz * xz - 2.0 * b.y * s * xy - 2.0 * b.y * xz * yz - 2.0 * b.z * s * xz - b.x * xy * xy - b.x * xz * xz + 2.0 * b.w * i * yz + 2.0 * b.w * s * wx + 2.0 * b.z * xy * yz), .y = (2.0 * (b.w * (s * wy + wx * xy - i * xz - wz * yz) + b.x * (s * xy - xz * yz) + b.z * (-s * yz - xy * xz)) + b.y * (s * s + xz * xz - xy * xy - yz * yz)), .z = (b.z * s * s + b.z * xy * xy - 2.0 * b.y * xy * xz - b.z * xz * xz - b.z * yz * yz + 2.0 * b.w * i * xy + 2.0 * b.w * s * wz + 2.0 * b.w * wx * xz + 2.0 * b.w * wy * yz + 2.0 * b.x * s * xz + 2.0 * b.x * xy * yz + 2.0 * b.y * s * yz), .w = b.w * (s * s + xy * xy + xz * xz + yz * yz)}; }
    constexpr Motor Motor::reverseSandwich(const Quaternion& b) const noexcept { return {.s = b.s * (s * s + xy * xy + xz * xz + yz * yz), .wx = 2.0 * (b.xy * (i * xz + s * wy + wx * xy + wz * yz) + b.xz * (s * wz + wx * xz - i * xy - wy * yz) + b.yz * (wx * yz + wy * xz - i * s - wz * xy)), .wy = 2.0 * (b.xy * (i * yz + wy * xy - s * wx - wz * xz) + b.xz * (i * s + wx * yz + wy * xz + wz * xy) + b.yz * (s * wz + wy * yz - i * xy - wx * xz)), .wz = 2.0 * (b.xy * (wy * xz + wz * xy - i * s - wx * yz) + b.xz * (i * yz + wz * xz - s * wx - wy * xy) + b.yz * (wx * xy + wz * yz - i * xz - s * wy)), .xy = (2.0 * (b.xz * (xy * xz - s * yz) + b.yz * (s * xz + xy * yz)) + b.xy * (s * s + xy * xy - xz * xz - yz * yz)), .xz = (2.0 * (b.xy * (s * yz + xy * xz) + b.yz * (xz * yz - s * xy)) + b.xz * (s * s + xz * xz - xy * xy - yz * yz)), .yz = (2.0 * (b.xy * (xy * yz - s * xz) + b.xz * (s * xy + xz * yz)) + b.yz * (s * s + yz * yz - xy * xy - xz * xz)), .i = 2.0 * b.s * (i * s + wy * xz - wx * yz - wz * xy)}; }
    constexpr Motor Motor::reverseSandwich(const ProjectiveTranslator& b) const noexcept { return {.s = b.s * (s * s + xy * xy + xz * xz + yz * yz), .wx = (2.0 * (b.wy * (-s * xy - xz * yz) + b.wz * (xy * yz - s * xz)) + b.wx * (s * s + yz * yz - xy * xy - xz * xz)), .wy = (2.0 * (b.wx * (s * xy - xz * yz) + b.wz * (-s * yz - xy * xz)) + b.wy * (s * s + xz * xz - xy * xy - yz * yz)), .wz = (2.0 * (b.wx * (s * xz + xy * yz) + b.wy * (s * yz - xy * xz)) + b.wz * (s * s + xy * xy - xz * xz - yz * yz)), .xy = 0.0, .xz = 0.0, .yz = 0.0, .i = 2.0 * b.s * (i * s + wy * xz - wx * yz - wz * xy)}; }
    constexpr Motor Motor::reverseSandwich(const Translator& b) const noexcept { return {.s = (s * s + xy * xy + xz * xz + yz * yz), .wx = (2.0 * (b.wy * (-s * xy - xz * yz) + b.wz * (xy * yz - s * xz)) + b.wx * (s * s + yz * yz - xy * xy - xz * xz)), .wy = (2.0 * (b.wx * (s * xy - xz * yz) + b.wz * (-s * yz - xy * xz)) + b.wy * (s * s + xz * xz - xy * xy - yz * yz)), .wz = (2.0 * (b.wx * (s * xz + xy * yz) + b.wy * (s * yz - xy * xz)) + b.wz * (s * s + xy * xy - xz * xz - yz * yz)), .xy = 0.0, .xz = 0.0, .yz = 0.0, .i = 2.0 * (i * s + wy * xz - wx * yz - wz * xy)}; }
    constexpr Vector Motor::reverseSandwich(const Vector& b) const noexcept { return {.x = (b.x * s * s + b.x * yz * yz - 2.0 * b.y * s * xy - 2.0 * b.y * xz * yz - 2.0 * b.z * s * xz - b.x * xy * xy - b.x * xz * xz + 2.0 * b.z * xy * yz), .y = (2.0 * (b.x * (s * xy - xz * yz) + b.z * (-s * yz - xy * xz)) + b.y * (s * s + xz * xz - xy * xy - yz * yz)), .z = (b.z * s * s + b.z * xy * xy - 2.0 * b.y * xy * xz - b.z * xz * xz - b.z * yz * yz + 2.0 * b.x * s * xz + 2.0 * b.x * xy * yz + 2.0 * b.y * s * yz)}; }
    constexpr ProjectivePoint Motor::reverseSandwich(const Point& b) const noexcept { return {.x = (-2.0 * wy * xy - 2.0 * wz * xz + 2.0 * i * yz + 2.0 * s * wx + b.x * s * s + b.x * yz * yz - 2.0 * b.y * s * xy - 2.0 * b.y * xz * yz - 2.0 * b.z * s * xz - b.x * xy * xy - b.x * xz * xz + 2.0 * b.z * xy * yz), .y = (2.0 * (s * (wy + b.x * xy - b.z * yz) + wx * xy + xz * (-i - b.x * yz - b.z * xy) - wz * yz) + b.y * (s * s + xz * xz - xy * xy - yz * yz)), .z = (2.0 * i * xy + 2.0 * s * wz + 2.0 * wx * xz + 2.0 * wy * yz + b.z * s * s + b.z * xy * xy - 2.0 * b.y * xy * xz - b.z * xz * xz - b.z * yz * yz + 2.0 * b.x * s * xz + 2.0 * b.x * xy * yz + 2.0 * b.y * s * yz), .w = (s * s + xy * xy + xz * xz + yz * yz)}; }
    constexpr Plane Motor::reverseSandwich(const PlaneIdeal& b) const noexcept { return {.x = (2.0 * (b.y * (-s * xy - xz * yz) + b.z * (xy * yz - s * xz)) + b.x * (s * s + yz * yz - xy * xy - xz * xz)), .y = (2.0 * (b.x * (s * xy - xz * yz) + b.z * (-s * yz - xy * xz)) + b.y * (s * s + xz * xz - xy * xy - yz * yz)), .z = (2.0 * (b.x * (s * xz + xy * yz) + b.y * (s * yz - xy * xz)) + b.z * (s * s + xy * xy - xz * xz - yz * yz)), .w = 2.0 * (b.x * (-i * yz - s * wx - wy * xy - wz * xz) + b.y * (i * xz + wx * xy - s * wy - wz * yz) + b.z * (wx * xz + wy * yz - i * xy - s * wz))}; }
    constexpr Bivector Motor::reverseSandwich(const BivectorBulk& b) const noexcept { return {.wx = 2.0 * (b.xy * (i * xz + s * wy + wx * xy + wz * yz) + b.xz * (s * wz + wx * xz - i * xy - wy * yz) + b.yz * (wx * yz + wy * xz - i * s - wz * xy)), .wy = 2.0 * (b.xy * (i * yz + wy * xy - s * wx - wz * xz) + b.xz * (i * s + wx * yz + wy * xz + wz * xy) + b.yz * (s * wz + wy * yz - i * xy - wx * xz)), .wz = 2.0 * (b.xy * (wy * xz + wz * xy - i * s - wx * yz) + b.xz * (i * yz + wz * xz - s * wx - wy * xy) + b.yz * (wx * xy + wz * yz - i * xz - s * wy)), .xy = (2.0 * (b.xz * (xy * xz - s * yz) + b.yz * (s * xz + xy * yz)) + b.xy * (s * s + xy * xy - xz * xz - yz * yz)), .xz = (2.0 * (b.xy * (s * yz + xy * xz) + b.yz * (xz * yz - s * xy)) + b.xz * (s * s + xz * xz - xy * xy - yz * yz)), .yz = (2.0 * (b.xy * (xy * yz - s * xz) + b.xz * (s * xy + xz * yz)) + b.yz * (s * s + yz * yz - xy * xy - xz * xz))}; }
    constexpr BivectorWeight Motor::reverseSandwich(const BivectorWeight& b) const noexcept { return {.wx = (2.0 * (b.wy * (-s * xy - xz * yz) + b.wz * (xy * yz - s * xz)) + b.wx * (s * s + yz * yz - xy * xy - xz * xz)), .wy = (2.0 * (b.wx * (s * xy - xz * yz) + b.wz * (-s * yz - xy * xz)) + b.wy * (s * s + xz * xz - xy * xy - yz * yz)), .wz = (2.0 * (b.wx * (s * xz + xy * yz) + b.wy * (s * yz - xy * xz)) + b.wz * (s * s + xy * xy - xz * xz - yz * yz))}; }
    constexpr PseudoScalar Motor::reverseSandwich(const PseudoScalar& b) const noexcept { return {.i = b.i * (s * s + xy * xy + xz * xz + yz * yz)}; }
    constexpr ProjectivePoint Motor::reverseSandwich(const PointCenter& b) const noexcept { return {.x = (-2.0 * wy * xy - 2.0 * wz * xz + 2.0 * i * yz + 2.0 * s * wx), .y = 2.0 * (s * wy + wx * xy - i * xz - wz * yz), .z = (2.0 * i * xy + 2.0 * s * wz + 2.0 * wx * xz + 2.0 * wy * yz), .w = (s * s + xy * xy + xz * xz + yz * yz)}; }

    constexpr Motor Plane::reverseSandwich(const Motor& b) const noexcept { return {.s = b.s * (x * x + y * y + z * z), .wx = (2.0 * (w * (b.xy * y + b.xz * z) + x * (-b.wy * y - b.wz * z)) + b.wx * (y * y + z * z - x * x)), .wy = (2.0 * (x * (-b.wx * y - b.xy * w) + z * (b.yz * w - b.wz * y)) + b.wy * (x * x + z * z - y * y)), .wz = (2.0 * (x * (-b.wx * z - b.xz * w) + y * (-b.wy * z - b.yz * w)) + b.wz * (x * x + y * y - z * z)), .xy = (b.xy * (z * z - x * x - y * y) + 2.0 * z * (b.yz * x - b.xz * y)), .xz = (b.xz * (y * y - x * x - z * z) + 2.0 * y * (-b.xy * z - b.yz * x)), .yz = (b.yz * (x * x - y * y - z * z) + 2.0 * x * (b.xy * z - b.xz * y)), .i = b.i * (-x * x - y * y - z * z)}; }
    constexpr Plane Plane::reverseSandwich(const Plane& b) const noexcept { return {.x = (b.x * (x * x - y * y - z * z) + 2.0 * x * (b.y * y + b.z * z)), .y = (b.y * (y * y - x * x - z * z) + 2.0 * y * (b.x * x + b.z * z)), .z = (b.z * (z * z - x * x - y * y) + 2.0 * z * (b.x * x + b.y * y)), .w = (b.w * (-x * x - y * y - z * z) + 2.0 * w * (b.x * x + b.y * y + b.z * z))}; }
    constexpr Bivector Plane::reverseSandwich(const Bivector& b) const noexcept { return {.wx = (2.0 * (w * (b.xy * y + b.xz * z) + x * (-b.wy * y - b.wz * z)) + b.wx * (y * y + z * z - x * x)), .wy = (2.0 * (x * (-b.wx * y - b.xy * w) + z * (b.yz * w - b.wz * y)) + b.wy * (x * x + z * z - y * y)), .wz = (2.0 * (x * (-b.wx * z - b.xz * w) + y * (-b.wy * z - b.yz * w)) + b.wz * (x * x + y * y - z * z)), .xy = (b.xy * (z * z - x * x - y * y) + 2.0 * z * (b.yz * x - b.xz * y)), .xz = (b.xz * (y * y - x * x - z * z) + 2.0 * y * (-b.xy * z - b.yz * x)), .yz = (b.yz * (x * x - y * y - z * z) + 2.0 * x * (b.xy * z - b.xz * y))}; }
    constexpr ProjectivePoint Plane::reverseSandwich(const ProjectivePoint& b) const noexcept { return {.x = (b.x * y * y + b.x * z * z - 2.0 * b.w * w * x - 2.0 * b.y * x * y - 2.0 * b.z * x * z - b.x * x * x), .y = (b.y * (x * x + z * z) + y * (2.0 * (-b.w * w - b.x * x - b.z * z) - b.y * y)), .z = (b.z * x * x + b.z * y * y - 2.0 * b.w * w * z - 2.0 * b.x * x * z - 2.0 * b.y * y * z - b.z * z * z), .w = b.w * (x * x + y * y + z * z)}; }
    constexpr Motor Plane::reverseSandwich(const Quaternion& b) const noexcept { return {.s = b.s * (x * x + y * y + z * z), .wx = 2.0 * w * (b.xy * y + b.xz * z), .wy = 2.0 * w * (b.yz * z - b.xy * x), .wz = 2.0 * w * (-b.xz * x - b.yz * y), .xy = (b.xy * (z * z - x * x - y * y) + 2.0 * z * (b.yz * x - b.xz * y)), .xz = (b.xz * (y * y - x * x - z * z) + 2.0 * y * (-b.xy * z - b.yz * x)), .yz = (b.yz * (x * x - y * y - z * z) + 2.0 * x * (b.xy * z - b.xz * y)), .i = 0.0}; }
    constexpr ProjectiveTranslator Plane::reverseSandwich(const ProjectiveTranslator& b) const noexcept { return {.s = b.s * (x * x + y * y + z * z), .wx = (b.wx * (y * y + z * z - x * x) + 2.0 * x * (-b.wy * y - b.wz * z)), .wy = (b.wy * (x * x + z * z - y * y) + 2.0 * y * (-b.wx * x - b.wz * z)), .wz = (b.wz * (x * x + y * y - z * z) + 2.0 * z * (-b.wx * x - b.wy * y))}; }
    constexpr ProjectiveTranslator Plane::reverseSandwich(const Translator& b) const noexcept { return {.s = (x * x + y * y + z * z), .wx = (b.wx * (y * y + z * z - x * x) + 2.0 * x * (-b.wy * y - b.wz * z)), .wy = (b.wy * (x * x + z * z - y * y) + 2.0 * y * (-b.wx * x - b.wz * z)), .wz = (b.wz * (x * x + y * y - z * z) + 2.0 * z * (-b.wx * x - b.wy * y))}; }
    constexpr Vector Plane::reverseSandwich(const Vector& b) const noexcept { return {.x = (b.x * y * y + b.x * z * z - 2.0 * b.y * x * y - 2.0 * b.z * x * z - b.x * x * x), .y = (b.y * (x * x + z * z - y * y) + 2.0 * y * (-b.x * x - b.z * z)), .z = (b.z * x * x + b.z * y * y - 2.0 * b.x * x * z - 2.0 * b.y * y * z - b.z * z * z)}; }
    constexpr ProjectivePoint Plane::reverseSandwich(const Point& b) const noexcept { return {.x = -(b.x * (-y * y - z * z) + x * (2.0 * (w + b.y * y + b.z * z) + b.x * x)), .y = (b.y * (x * x + z * z) + y * (2.0 * (-w - b.x * x - b.z * z) - b.y * y)), .z = -(b.z * (-x * x - y * y) + z * (2.0 * (w + b.x * x + b.y * y) + b.z * z)), .w = (x * x + y * y + z * z)}; }
    constexpr Plane Plane::reverseSandwich(const PlaneIdeal& b) const noexcept { return {.x = (b.x * (x * x - y * y - z * z) + 2.0 * x * (b.y * y + b.z * z)), .y = (b.y * (y * y - x * x - z * z) + 2.0 * y * (b.x * x + b.z * z)), .z = (b.z * (z * z - x * x - y * y) + 2.0 * z * (b.x * x + b.y * y)), .w = 2.0 * w * (b.x * x + b.y * y + b.z * z)}; }
    constexpr Bivector Plane::reverseSandwich(const BivectorBulk& b) const noexcept { return {.wx = 2.0 * w * (b.xy * y + b.xz * z), .wy = 2.0 * w * (b.yz * z - b.xy * x), .wz = 2.0 * w * (-b.xz * x - b.yz * y), .xy = (b.xy * (z * z - x * x - y * y) + 2.0 * z * (b.yz * x - b.xz * y)), .xz = (b.xz * (y * y - x * x - z * z) + 2.0 * y * (-b.xy * z - b.yz * x)), .yz = (b.yz * (x * x - y * y - z * z) + 2.0 * x * (b.xy * z - b.xz * y))}; }
    constexpr BivectorWeight Plane::reverseSandwich(const BivectorWeight& b) const noexcept { return {.wx = (b.wx * (y * y + z * z - x * x) + 2.0 * x * (-b.wy * y - b.wz * z)), .wy = (b.wy * (x * x + z * z - y * y) + 2.0 * y * (-b.wx * x - b.wz * z)), .wz = (b.wz * (x * x + y * y - z * z) + 2.0 * z * (-b.wx * x - b.wy * y))}; }
    constexpr PseudoScalar Plane::reverseSandwich(const PseudoScalar& b) const noexcept { return {.i = b.i * (-x * x - y * y - z * z)}; }
    constexpr ProjectivePoint Plane::reverseSandwich(const PointCenter& b) const noexcept { return {.x = -2.0 * w * x, .y = -2.0 * w * y, .z = -2.0 * w * z, .w = (x * x + y * y + z * z)}; }

    constexpr Motor Bivector::reverseSandwich(const Motor& b) const noexcept { return {.s = b.s * (xy * xy + xz * xz + yz * yz), .wx = (2.0 * (b.yz * (wy * xz - wz * xy) + wx * (b.xy * xy + b.xz * xz) + yz * (b.wz * xy + b.xy * wz + b.yz * wx - b.wy * xz - b.xz * wy)) + b.wx * (yz * yz - xy * xy - xz * xz)), .wy = (2.0 * (b.xz * (wx * yz + wz * xy) + wy * (b.xy * xy + b.yz * yz) + xz * (b.xz * wy - b.wx * yz - b.wz * xy - b.xy * wz - b.yz * wx)) + b.wy * (xz * xz - xy * xy - yz * yz)), .wz = (2.0 * (b.xy * (wy * xz - wx * yz) + wz * (b.xz * xz + b.yz * yz) + xy * (b.wx * yz + b.xy * wz + b.yz * wx - b.wy * xz - b.xz * wy)) + b.wz * (xy * xy - xz * xz - yz * yz)), .xy = (b.xy * (xy * xy - xz * xz - yz * yz) + 2.0 * xy * (b.xz * xz + b.yz * yz)), .xz = (b.xz * (xz * xz - xy * xy - yz * yz) + 2.0 * xz * (b.xy * xy + b.yz * yz)), .yz = (b.yz * (yz * yz - xy * xy - xz * xz) + 2.0 * yz * (b.xy * xy + b.xz * xz)), .i = (b.i * (xy * xy + xz * xz + yz * yz) + 2.0 * b.s * (wy * xz - wx * yz - wz * xy))}; }
    constexpr Plane Bivector::reverseSandwich(const Plane& b) const noexcept { return {.x = (b.x * (yz * yz - xy * xy - xz * xz) + 2.0 * yz * (b.z * xy - b.y * xz)), .y = (b.y * (xz * xz - xy * xy - yz * yz) + 2.0 * xz * (-b.x * yz - b.z * xy)), .z = (b.z * (xy * xy - xz * xz - yz * yz) + 2.0 * xy * (b.x * yz - b.y * xz)), .w = (2.0 * (b.x * (-wy * xy - wz * xz) + b.y * (wx * xy - wz * yz) + b.z * (wx * xz + wy * yz)) + b.w * (xy * xy + xz * xz + yz * yz))}; }
    constexpr Bivector Bivector::reverseSandwich(const Bivector& b) const noexcept { return {.wx = (2.0 * (b.yz * (wy * xz - wz * xy) + wx * (b.xy * xy + b.xz * xz) + yz * (b.wz * xy + b.xy * wz + b.yz * wx - b.wy * xz - b.xz * wy)) + b.wx * (yz * yz - xy * xy - xz * xz)), .wy = (2.0 * (b.xz * (wx * yz + wz * xy) + wy * (b.xy * xy + b.yz * yz) + xz * (b.xz * wy - b.wx * yz - b.wz * xy - b.xy * wz - b.yz * wx)) + b.wy * (xz * xz - xy * xy - yz * yz)), .wz = (2.0 * (b.xy * (wy * xz - wx * yz) + wz * (b.xz * xz + b.yz * yz) + xy * (b.wx * yz + b.xy * wz + b.yz * wx - b.wy * xz - b.xz * wy)) + b.wz * (xy * xy - xz * xz - yz * yz)), .xy = (b.xy * (xy * xy - xz * xz - yz * yz) + 2.0 * xy * (b.xz * xz + b.yz * yz)), .xz = (b.xz * (xz * xz - xy * xy - yz * yz) + 2.0 * xz * (b.xy * xy + b.yz * yz)), .yz = (b.yz * (yz * yz - xy * xy - xz * xz) + 2.0 * yz * (b.xy * xy + b.xz * xz))}; }
    constexpr ProjectivePoint Bivector::reverseSandwich(const ProjectivePoint& b) const noexcept { return {.x = (b.x * yz * yz - 2.0 * b.w * wy * xy - 2.0 * b.w * wz * xz - 2.0 * b.y * xz * yz - b.x * xy * xy - b.x * xz * xz + 2.0 * b.z * xy * yz), .y = (2.0 * (b.w * (wx * xy - wz * yz) + xz * (-b.x * yz - b.z * xy)) + b.y * (xz * xz - xy * xy - yz * yz)), .z = (b.z * xy * xy - 2.0 * b.y * xy * xz - b.z * xz * xz - b.z * yz * yz + 2.0 * b.w * wx * xz + 2.0 * b.w * wy * yz + 2.0 * b.x * xy * yz), .w = b.w * (xy * xy + xz * xz + yz * yz)}; }
    constexpr Motor Bivector::reverseSandwich(const Quaternion& b) const noexcept { return {.s = b.s * (xy * xy + xz * xz + yz * yz), .wx = 2.0 * (b.yz * (wy * xz - wz * xy) + wx * (b.xy * xy + b.xz * xz) + yz * (b.xy * wz + b.yz * wx - b.xz * wy)), .wy = 2.0 * (b.xz * (wx * yz + wz * xy) + wy * (b.xy * xy + b.yz * yz) + xz * (b.xz * wy - b.xy * wz - b.yz * wx)), .wz = 2.0 * (b.xy * (wy * xz + wz * xy - wx * yz) + b.xz * (wz * xz - wy * xy) + b.yz * (wx * xy + wz * yz)), .xy = (b.xy * (xy * xy - xz * xz - yz * yz) + 2.0 * xy * (b.xz * xz + b.yz * yz)), .xz = (b.xz * (xz * xz - xy * xy - yz * yz) + 2.0 * xz * (b.xy * xy + b.yz * yz)), .yz = (b.yz * (yz * yz - xy * xy - xz * xz) + 2.0 * yz * (b.xy * xy + b.xz * xz)), .i = 2.0 * b.s * (wy * xz - wx * yz - wz * xy)}; }
    constexpr Motor Bivector::reverseSandwich(const ProjectiveTranslator& b) const noexcept { return {.s = b.s * (xy * xy + xz * xz + yz * yz), .wx = (b.wx * (yz * yz - xy * xy - xz * xz) + 2.0 * yz * (b.wz * xy - b.wy * xz)), .wy = (b.wy * (xz * xz - xy * xy - yz * yz) + 2.0 * xz * (-b.wx * yz - b.wz * xy)), .wz = (b.wz * (xy * xy - xz * xz - yz * yz) + 2.0 * xy * (b.wx * yz - b.wy * xz)), .xy = 0.0, .xz = 0.0, .yz = 0.0, .i = 2.0 * b.s * (wy * xz - wx * yz - wz * xy)}; }
    constexpr Motor Bivector::reverseSandwich(const Translator& b) const noexcept { return {.s = (xy * xy + xz * xz + yz * yz), .wx = (b.wx * (yz * yz - xy * xy - xz * xz) + 2.0 * yz * (b.wz * xy - b.wy * xz)), .wy = (b.wy * (xz * xz - xy * xy - yz * yz) + 2.0 * xz * (-b.wx * yz - b.wz * xy)), .wz = (b.wz * (xy * xy - xz * xz - yz * yz) + 2.0 * xy * (b.wx * yz - b.wy * xz)), .xy = 0.0, .xz = 0.0, .yz = 0.0, .i = 2.0 * (wy * xz - wx * yz - wz * xy)}; }
    constexpr Vector Bivector::reverseSandwich(const Vector& b) const noexcept { return {.x = (b.x * yz * yz - 2.0 * b.y * xz * yz - b.x * xy * xy - b.x * xz * xz + 2.0 * b.z * xy * yz), .y = (b.y * (xz * xz - xy * xy - yz * yz) + 2.0 * xz * (-b.x * yz - b.z * xy)), .z = (b.z * xy * xy - 2.0 * b.y * xy * xz - b.z * xz * xz - b.z * yz * yz + 2.0 * b.x * xy * yz)}; }
    constexpr ProjectivePoint Bivector::reverseSandwich(const Point& b) const noexcept { return {.x = -(2.0 * (xy * (wy - b.z * yz) + xz * (wz + b.y * yz)) + b.x * (xy * xy + xz * xz - yz * yz)), .y = (2.0 * (xy * (wx - b.z * xz) + yz * (-wz - b.x * xz)) + b.y * (xz * xz - xy * xy - yz * yz)), .z = (2.0 * wx * xz + 2.0 * wy * yz + b.z * xy * xy - 2.0 * b.y * xy * xz - b.z * xz * xz - b.z * yz * yz + 2.0 * b.x * xy * yz), .w = (xy * xy + xz * xz + yz * yz)}; }
    constexpr Plane Bivector::reverseSandwich(const PlaneIdeal& b) const noexcept { return {.x = (b.x * (yz * yz - xy * xy - xz * xz) + 2.0 * yz * (b.z * xy - b.y * xz)), .y = (b.y * (xz * xz - xy * xy - yz * yz) + 2.0 * xz * (-b.x * yz - b.z * xy)), .z = (b.z * (xy * xy - xz * xz - yz * yz) + 2.0 * xy * (b.x * yz - b.y * xz)), .w = 2.0 * (b.x * (-wy * xy - wz * xz) + b.y * (wx * xy - wz * yz) + b.z * (wx * xz + wy * yz))}; }
    constexpr Bivector Bivector::reverseSandwich(const BivectorBulk& b) const noexcept { return {.wx = 2.0 * (b.yz * (wy * xz - wz * xy) + wx * (b.xy * xy + b.xz * xz) + yz * (b.xy * wz + b.yz * wx - b.xz * wy)), .wy = 2.0 * (b.xz * (wx * yz + wz * xy) + wy * (b.xy * xy + b.yz * yz) + xz * (b.xz * wy - b.xy * wz - b.yz * wx)), .wz = 2.0 * (b.xy * (wy * xz + wz * xy - wx * yz) + b.xz * (wz * xz - wy * xy) + b.yz * (wx * xy + wz * yz)), .xy = (b.xy * (xy * xy - xz * xz - yz * yz) + 2.0 * xy * (b.xz * xz + b.yz * yz)), .xz = (b.xz * (xz * xz - xy * xy - yz * yz) + 2.0 * xz * (b.xy * xy + b.yz * yz)), .yz = (b.yz * (yz * yz - xy * xy - xz * xz) + 2.0 * yz * (b.xy * xy + b.xz * xz))}; }
    constexpr BivectorWeight Bivector::reverseSandwich(const BivectorWeight& b) const noexcept { return {.wx = (b.wx * (yz * yz - xy * xy - xz * xz) + 2.0 * yz * (b.wz * xy - b.wy * xz)), .wy = (b.wy * (xz * xz - xy * xy - yz * yz) + 2.0 * xz * (-b.wx * yz - b.wz * xy)), .wz = (b.wz * (xy * xy - xz * xz - yz * yz) + 2.0 * xy * (b.wx * yz - b.wy * xz))}; }
    constexpr PseudoScalar Bivector::reverseSandwich(const PseudoScalar& b) const noexcept { return {.i = b.i * (xy * xy + xz * xz + yz * yz)}; }
    constexpr ProjectivePoint Bivector::reverseSandwich(const PointCenter& b) const noexcept { return {.x = (-2.0 * wy * xy - 2.0 * wz * xz), .y = 2.0 * (wx * xy - wz * yz), .z = (2.0 * wx * xz + 2.0 * wy * yz), .w = (xy * xy + xz * xz + yz * yz)}; }

    constexpr Motor ProjectivePoint::reverseSandwich(const Motor& b) const noexcept { return {.s = b.s * w * w, .wx = w * (2.0 * (b.xy * y + b.xz * z) - b.wx * w), .wy = w * (2.0 * (b.yz * z - b.xy * x) - b.wy * w), .wz = w * (2.0 * (-b.xz * x - b.yz * y) - b.wz * w), .xy = b.xy * w * w, .xz = b.xz * w * w, .yz = b.yz * w * w, .i = -b.i * w * w}; }
    constexpr Plane ProjectivePoint::reverseSandwich(const Plane& b) const noexcept { return {.x = b.x * w * w, .y = b.y * w * w, .z = b.z * w * w, .w = w * (2.0 * (-b.x * x - b.y * y - b.z * z) - b.w * w)}; }
    constexpr Bivector ProjectivePoint::reverseSandwich(const Bivector& b) const noexcept { return {.wx = w * (2.0 * (b.xy * y + b.xz * z) - b.wx * w), .wy = w * (2.0 * (b.yz * z - b.xy * x) - b.wy * w), .wz = w * (2.0 * (-b.xz * x - b.yz * y) - b.wz * w), .xy = b.xy * w * w, .xz = b.xz * w * w, .yz = b.yz * w * w}; }
    constexpr ProjectivePoint ProjectivePoint::reverseSandwich(const ProjectivePoint& b) const noexcept { return {.x = (-b.x * w * w + 2.0 * b.w * w * x), .y = w * (-b.y * w + 2.0 * b.w * y), .z = (-b.z * w * w + 2.0 * b.w * w * z), .w = b.w * w * w}; }
    constexpr Motor ProjectivePoint::reverseSandwich(const Quaternion& b) const noexcept { return {.s = b.s * w * w, .wx = 2.0 * w * (b.xy * y + b.xz * z), .wy = 2.0 * w * (b.yz * z - b.xy * x), .wz = 2.0 * w * (-b.xz * x - b.yz * y), .xy = b.xy * w * w, .xz = b.xz * w * w, .yz = b.yz * w * w, .i = 0.0}; }
    constexpr ProjectiveTranslator ProjectivePoint::reverseSandwich(const ProjectiveTranslator& b) const noexcept { return {.s = b.s * w * w, .wx = -b.wx * w * w, .wy = -b.wy * w * w, .wz = -b.wz * w * w}; }
    constexpr ProjectiveTranslator ProjectivePoint::reverseSandwich(const Translator& b) const noexcept { return {.s = w * w, .wx = -b.wx * w * w, .wy = -b.wy * w * w, .wz = -b.wz * w * w}; }
    constexpr Vector ProjectivePoint::reverseSandwich(const Vector& b) const noexcept { return {.x = -b.x * w * w, .y = -b.y * w * w, .z = -b.z * w * w}; }
    constexpr ProjectivePoint ProjectivePoint::reverseSandwich(const Point& b) const noexcept { return {.x = (2.0 * w * x - b.x * w * w), .y = w * (2.0 * y - b.y * w), .z = (2.0 * w * z - b.z * w * w), .w = w * w}; }
    constexpr Plane ProjectivePoint::reverseSandwich(const PlaneIdeal& b) const noexcept { return {.x = b.x * w * w, .y = b.y * w * w, .z = b.z * w * w, .w = 2.0 * w * (-b.x * x - b.y * y - b.z * z)}; }
    constexpr Bivector ProjectivePoint::reverseSandwich(const BivectorBulk& b) const noexcept { return {.wx = 2.0 * w * (b.xy * y + b.xz * z), .wy = 2.0 * w * (b.yz * z - b.xy * x), .wz = 2.0 * w * (-b.xz * x - b.yz * y), .xy = b.xy * w * w, .xz = b.xz * w * w, .yz = b.yz * w * w}; }
    constexpr BivectorWeight ProjectivePoint::reverseSandwich(const BivectorWeight& b) const noexcept { return {.wx = -b.wx * w * w, .wy = -b.wy * w * w, .wz = -b.wz * w * w}; }
    constexpr PseudoScalar ProjectivePoint::reverseSandwich(const PseudoScalar& b) const noexcept { return {.i = -b.i * w * w}; }
    constexpr ProjectivePoint ProjectivePoint::reverseSandwich(const PointCenter& b) const noexcept { return {.x = 2.0 * w * x, .y = 2.0 * w * y, .z = 2.0 * w * z, .w = w * w}; }

    constexpr Motor Quaternion::reverseSandwich(const Motor& b) const noexcept { return {.s = b.s * (s * s + xy * xy + xz * xz + yz * yz), .wx = (2.0 * (b.wy * (-s * xy - xz * yz) + b.wz * (xy * yz - s * xz)) + b.wx * (s * s + yz * yz - xy * xy - xz * xz)), .wy = (2.0 * (b.wx * (s * xy - xz * yz) + b.wz * (-s * yz - xy * xz)) + b.wy * (s * s + xz * xz - xy * xy - yz * yz)), .wz = (2.0 * (b.wx * (s * xz + xy * yz) + b.wy * (s * yz - xy * xz)) + b.wz * (s * s + xy * xy - xz * xz - yz * yz)), .xy = (2.0 * (b.xz * (xy * xz - s * yz) + b.yz * (s * xz + xy * yz)) + b.xy * (s * s + xy * xy - xz * xz - yz * yz)), .xz = (2.0 * (b.xy * (s * yz + xy * xz) + b.yz * (xz * yz - s * xy)) + b.xz * (s * s + xz * xz - xy * xy - yz * yz)), .yz = (2.0 * (b.xy * (xy * yz - s * xz) + b.xz * (s * xy + xz * yz)) + b.yz * (s * s + yz * yz - xy * xy - xz * xz)), .i = b.i * (s * s + xy * xy + xz * xz + yz * yz)}; }
    constexpr Plane Quaternion::reverseSandwich(const Plane& b) const noexcept { return {.x = (2.0 * (b.y * (-s * xy - xz * yz) + b.z * (xy * yz - s * xz)) + b.x * (s * s + yz * yz - xy * xy - xz * xz)), .y = (2.0 * (b.x * (s * xy - xz * yz) + b.z * (-s * yz - xy * xz)) + b.y * (s * s + xz * xz - xy * xy - yz * yz)), .z = (2.0 * (b.x * (s * xz + xy * yz) + b.y * (s * yz - xy * xz)) + b.z * (s * s + xy * xy - xz * xz - yz * yz)), .w = b.w * (s * s + xy * xy + xz * xz + yz * yz)}; }
    constexpr Bivector Quaternion::reverseSandwich(const Bivector& b) const noexcept { return {.wx = (2.0 * (b.wy * (-s * xy - xz * yz) + b.wz * (xy * yz - s * xz)) + b.wx * (s * s + yz * yz - xy * xy - xz * xz)), .wy = (2.0 * (b.wx * (s * xy - xz * yz) + b.wz * (-s * yz - xy * xz)) + b.wy * (s * s + xz * xz - xy * xy - yz * yz)), .wz = (2.0 * (b.wx * (s * xz + xy * yz) + b.wy * (s * yz - xy * xz)) + b.wz * (s * s + xy * xy - xz * xz - yz * yz)), .xy = (2.0 * (b.xz * (xy * xz - s * yz) + b.yz * (s * xz + xy * yz)) + b.xy * (s * s + xy * xy - xz * xz - yz * yz)), .xz = (2.0 * (b.xy * (s * yz + xy * xz) + b.yz * (xz * yz - s * xy)) + b.xz * (s * s + xz * xz - xy * xy - yz * yz)), .yz = (2.0 * (b.xy * (xy * yz - s * xz) + b.xz * (s * xy + xz * yz)) + b.yz * (s * s + yz * yz - xy * xy - xz * xz))}; }
    constexpr ProjectivePoint Quaternion::reverseSandwich(const ProjectivePoint& b) const noexcept { return {.x = (b.x * s * s + b.x * yz * yz - 2.0 * b.y * s * xy - 2.0 * b.y * xz * yz - 2.0 * b.z * s * xz - b.x * xy * xy - b.x * xz * xz + 2.0 * b.z * xy * yz), .y = (2.0 * (b.x * (s * xy - xz * yz) + b.z * (-s * yz - xy * xz)) + b.y * (s * s + xz * xz - xy * xy - yz * yz)), .z = (b.z * s * s + b.z * xy * xy - 2.0 * b.y * xy * xz - b.z * xz * xz - b.z * yz * yz + 2.0 * b.x * s * xz + 2.0 * b.x * xy * yz + 2.0 * b.y * s * yz), .w = b.w * (s * s + xy * xy + xz * xz + yz * yz)}; }
    constexpr Quaternion Quaternion::reverseSandwich(const Quaternion& b) const noexcept { return {.s = b.s * (s * s + xy * xy + xz * xz + yz * yz), .xy = (2.0 * (b.xz * (xy * xz - s * yz) + b.yz * (s * xz + xy * yz)) + b.xy * (s * s + xy * xy - xz * xz - yz * yz)), .xz = (2.0 * (b.xy * (s * yz + xy * xz) + b.yz * (xz * yz - s * xy)) + b.xz * (s * s + xz * xz - xy * xy - yz * yz)), .yz = (2.0 * (b.xy * (xy * yz - s * xz) + b.xz * (s * xy + xz * yz)) + b.yz * (s * s + yz * yz - xy * xy - xz * xz))}; }
    constexpr ProjectiveTranslator Quaternion::reverseSandwich(const ProjectiveTranslator& b) const noexcept { return {.s = b.s * (s * s + xy * xy + xz * xz + yz * yz), .wx = (2.0 * (b.wy * (-s * xy - xz * yz) + b.wz * (xy * yz - s * xz)) + b.wx * (s * s + yz * yz - xy * xy - xz * xz)), .wy = (2.0 * (b.wx * (s * xy - xz * yz) + b.wz * (-s * yz - xy * xz)) + b.wy * (s * s + xz * xz - xy * xy - yz * yz)), .wz = (2.0 * (b.wx * (s * xz + xy * yz) + b.wy * (s * yz - xy * xz)) + b.wz * (s * s + xy * xy - xz * xz - yz * yz))}; }
    constexpr ProjectiveTranslator Quaternion::reverseSandwich(const Translator& b) const noexcept { return {.s = (s * s + xy * xy + xz * xz + yz * yz), .wx = (2.0 * (b.wy * (-s * xy - xz * yz) + b.wz * (xy * yz - s * xz)) + b.wx * (s * s + yz * yz - xy * xy - xz * xz)), .wy = (2.0 * (b.wx * (s * xy - xz * yz) + b.wz * (-s * yz - xy * xz)) + b.wy * (s * s + xz * xz - xy * xy - yz * yz)), .wz = (2.0 * (b.wx * (s * xz + xy * yz) + b.wy * (s * yz - xy * xz)) + b.wz * (s * s + xy * xy - xz * xz - yz * yz))}; }
    constexpr Vector Quaternion::reverseSandwich(const Vector& b) const noexcept { return {.x = (b.x * s * s + b.x * yz * yz - 2.0 * b.y * s * xy - 2.0 * b.y * xz * yz - 2.0 * b.z * s * xz - b.x * xy * xy - b.x * xz * xz + 2.0 * b.z * xy * yz), .y = (2.0 * (b.x * (s * xy - xz * yz) + b.z * (-s * yz - xy * xz)) + b.y * (s * s + xz * xz - xy * xy - yz * yz)), .z = (b.z * s * s + b.z * xy * xy - 2.0 * b.y * xy * xz - b.z * xz * xz - b.z * yz * yz + 2.0 * b.x * s * xz + 2.0 * b.x * xy * yz + 2.0 * b.y * s * yz)}; }
    constexpr ProjectivePoint Quaternion::reverseSandwich(const Point& b) const noexcept { return {.x = (b.x * s * s + b.x * yz * yz - 2.0 * b.y * s * xy - 2.0 * b.y * xz * yz - 2.0 * b.z * s * xz - b.x * xy * xy - b.x * xz * xz + 2.0 * b.z * xy * yz), .y = (2.0 * (b.x * (s * xy - xz * yz) + b.z * (-s * yz - xy * xz)) + b.y * (s * s + xz * xz - xy * xy - yz * yz)), .z = (b.z * s * s + b.z * xy * xy - 2.0 * b.y * xy * xz - b.z * xz * xz - b.z * yz * yz + 2.0 * b.x * s * xz + 2.0 * b.x * xy * yz + 2.0 * b.y * s * yz), .w = (s * s + xy * xy + xz * xz + yz * yz)}; }
    constexpr PlaneIdeal Quaternion::reverseSandwich(const PlaneIdeal& b) const noexcept { return {.x = (2.0 * (b.y * (-s * xy - xz * yz) + b.z * (xy * yz - s * xz)) + b.x * (s * s + yz * yz - xy * xy - xz * xz)), .y = (2.0 * (b.x * (s * xy - xz * yz) + b.z * (-s * yz - xy * xz)) + b.y * (s * s + xz * xz - xy * xy - yz * yz)), .z = (2.0 * (b.x * (s * xz + xy * yz) + b.y * (s * yz - xy * xz)) + b.z * (s * s + xy * xy - xz * xz - yz * yz))}; }
    constexpr BivectorBulk Quaternion::reverseSandwich(const BivectorBulk& b) const noexcept { return {.xy = (2.0 * (b.xz * (xy * xz - s * yz) + b.yz * (s * xz + xy * yz)) + b.xy * (s * s + xy * xy - xz * xz - yz * yz)), .xz = (2.0 * (b.xy * (s * yz + xy * xz) + b.yz * (xz * yz - s * xy)) + b.xz * (s * s + xz * xz - xy * xy - yz * yz)), .yz = (2.0 * (b.xy * (xy * yz - s * xz) + b.xz * (s * xy + xz * yz)) + b.yz * (s * s + yz * yz - xy * xy - xz * xz))}; }
    constexpr BivectorWeight Quaternion::reverseSandwich(const BivectorWeight& b) const noexcept { return {.wx = (2.0 * (b.wy * (-s * xy - xz * yz) + b.wz * (xy * yz - s * xz)) + b.wx * (s * s + yz * yz - xy * xy - xz * xz)), .wy = (2.0 * (b.wx * (s * xy - xz * yz) + b.wz * (-s * yz - xy * xz)) + b.wy * (s * s + xz * xz - xy * xy - yz * yz)), .wz = (2.0 * (b.wx * (s * xz + xy * yz) + b.wy * (s * yz - xy * xz)) + b.wz * (s * s + xy * xy - xz * xz - yz * yz))}; }
    constexpr PseudoScalar Quaternion::reverseSandwich(const PseudoScalar& b) const noexcept { return {.i = b.i * (s * s + xy * xy + xz * xz + yz * yz)}; }
    constexpr ProjectivePoint Quaternion::reverseSandwich(const PointCenter& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = (s * s + xy * xy + xz * xz + yz * yz)}; }

    constexpr Motor ProjectiveTranslator::reverseSandwich(const Motor& b) const noexcept { return {.s = b.s * s * s, .wx = s * (2.0 * (b.xy * wy + b.xz * wz) + b.wx * s), .wy = s * (2.0 * (b.yz * wz - b.xy * wx) + b.wy * s), .wz = s * (2.0 * (-b.xz * wx - b.yz * wy) + b.wz * s), .xy = b.xy * s * s, .xz = b.xz * s * s, .yz = b.yz * s * s, .i = b.i * s * s}; }
    constexpr Plane ProjectiveTranslator::reverseSandwich(const Plane& b) const noexcept { return {.x = b.x * s * s, .y = b.y * s * s, .z = b.z * s * s, .w = s * (2.0 * (-b.x * wx - b.y * wy - b.z * wz) + b.w * s)}; }
    constexpr Bivector ProjectiveTranslator::reverseSandwich(const Bivector& b) const noexcept { return {.wx = s * (2.0 * (b.xy * wy + b.xz * wz) + b.wx * s), .wy = s * (2.0 * (b.yz * wz - b.xy * wx) + b.wy * s), .wz = s * (2.0 * (-b.xz * wx - b.yz * wy) + b.wz * s), .xy = b.xy * s * s, .xz = b.xz * s * s, .yz = b.yz * s * s}; }
    constexpr ProjectivePoint ProjectiveTranslator::reverseSandwich(const ProjectivePoint& b) const noexcept { return {.x = (b.x * s * s + 2.0 * b.w * s * wx), .y = s * (b.y * s + 2.0 * b.w * wy), .z = (b.z * s * s + 2.0 * b.w * s * wz), .w = b.w * s * s}; }
    constexpr Motor ProjectiveTranslator::reverseSandwich(const Quaternion& b) const noexcept { return {.s = b.s * s * s, .wx = 2.0 * s * (b.xy * wy + b.xz * wz), .wy = 2.0 * s * (b.yz * wz - b.xy * wx), .wz = 2.0 * s * (-b.xz * wx - b.yz * wy), .xy = b.xy * s * s, .xz = b.xz * s * s, .yz = b.yz * s * s, .i = 0.0}; }
    constexpr ProjectiveTranslator ProjectiveTranslator::reverseSandwich(const ProjectiveTranslator& b) const noexcept { return {.s = b.s * s * s, .wx = b.wx * s * s, .wy = b.wy * s * s, .wz = b.wz * s * s}; }
    constexpr ProjectiveTranslator ProjectiveTranslator::reverseSandwich(const Translator& b) const noexcept { return {.s = s * s, .wx = b.wx * s * s, .wy = b.wy * s * s, .wz = b.wz * s * s}; }
    constexpr Vector ProjectiveTranslator::reverseSandwich(const Vector& b) const noexcept { return {.x = b.x * s * s, .y = b.y * s * s, .z = b.z * s * s}; }
    constexpr ProjectivePoint ProjectiveTranslator::reverseSandwich(const Point& b) const noexcept { return {.x = (2.0 * s * wx + b.x * s * s), .y = s * (2.0 * wy + b.y * s), .z = (2.0 * s * wz + b.z * s * s), .w = s * s}; }
    constexpr Plane ProjectiveTranslator::reverseSandwich(const PlaneIdeal& b) const noexcept { return {.x = b.x * s * s, .y = b.y * s * s, .z = b.z * s * s, .w = 2.0 * s * (-b.x * wx - b.y * wy - b.z * wz)}; }
    constexpr Bivector ProjectiveTranslator::reverseSandwich(const BivectorBulk& b) const noexcept { return {.wx = 2.0 * s * (b.xy * wy + b.xz * wz), .wy = 2.0 * s * (b.yz * wz - b.xy * wx), .wz = 2.0 * s * (-b.xz * wx - b.yz * wy), .xy = b.xy * s * s, .xz = b.xz * s * s, .yz = b.yz * s * s}; }
    constexpr BivectorWeight ProjectiveTranslator::reverseSandwich(const BivectorWeight& b) const noexcept { return {.wx = b.wx * s * s, .wy = b.wy * s * s, .wz = b.wz * s * s}; }
    constexpr PseudoScalar ProjectiveTranslator::reverseSandwich(const PseudoScalar& b) const noexcept { return {.i = b.i * s * s}; }
    constexpr ProjectivePoint ProjectiveTranslator::reverseSandwich(const PointCenter& b) const noexcept { return {.x = 2.0 * s * wx, .y = 2.0 * s * wy, .z = 2.0 * s * wz, .w = s * s}; }

    constexpr Motor Translator::reverseSandwich(const Motor& b) const noexcept { return {.s = b.s, .wx = (b.wx + 2.0 * b.xy * wy + 2.0 * b.xz * wz), .wy = (b.wy - 2.0 * b.xy * wx + 2.0 * b.yz * wz), .wz = (b.wz - 2.0 * b.xz * wx - 2.0 * b.yz * wy), .xy = b.xy, .xz = b.xz, .yz = b.yz, .i = b.i}; }
    constexpr Plane Translator::reverseSandwich(const Plane& b) const noexcept { return {.x = b.x, .y = b.y, .z = b.z, .w = (b.w - 2.0 * b.x * wx - 2.0 * b.y * wy - 2.0 * b.z * wz)}; }
    constexpr Bivector Translator::reverseSandwich(const Bivector& b) const noexcept { return {.wx = (b.wx + 2.0 * b.xy * wy + 2.0 * b.xz * wz), .wy = (b.wy - 2.0 * b.xy * wx + 2.0 * b.yz * wz), .wz = (b.wz - 2.0 * b.xz * wx - 2.0 * b.yz * wy), .xy = b.xy, .xz = b.xz, .yz = b.yz}; }
    constexpr ProjectivePoint Translator::reverseSandwich(const ProjectivePoint& b) const noexcept { return {.x = (b.x + 2.0 * b.w * wx), .y = (b.y + 2.0 * b.w * wy), .z = (b.z + 2.0 * b.w * wz), .w = b.w}; }
    constexpr Motor Translator::reverseSandwich(const Quaternion& b) const noexcept { return {.s = b.s, .wx = 2.0 * (b.xy * wy + b.xz * wz), .wy = 2.0 * (b.yz * wz - b.xy * wx), .wz = 2.0 * (-b.xz * wx - b.yz * wy), .xy = b.xy, .xz = b.xz, .yz = b.yz, .i = 0.0}; }
    constexpr ProjectiveTranslator Translator::reverseSandwich(const ProjectiveTranslator& b) const noexcept { return {.s = b.s, .wx = b.wx, .wy = b.wy, .wz = b.wz}; }
    constexpr Translator Translator::reverseSandwich(const Translator& b) const noexcept { return {.wx = b.wx, .wy = b.wy, .wz = b.wz}; }
    constexpr Vector Translator::reverseSandwich(const Vector& b) const noexcept { return {.x = b.x, .y = b.y, .z = b.z}; }
    constexpr Point Translator::reverseSandwich(const Point& b) const noexcept { return {.x = (b.x + 2.0 * wx), .y = (b.y + 2.0 * wy), .z = (b.z + 2.0 * wz)}; }
    constexpr Plane Translator::reverseSandwich(const PlaneIdeal& b) const noexcept { return {.x = b.x, .y = b.y, .z = b.z, .w = 2.0 * (-b.x * wx - b.y * wy - b.z * wz)}; }
    constexpr Bivector Translator::reverseSandwich(const BivectorBulk& b) const noexcept { return {.wx = 2.0 * (b.xy * wy + b.xz * wz), .wy = 2.0 * (b.yz * wz - b.xy * wx), .wz = 2.0 * (-b.xz * wx - b.yz * wy), .xy = b.xy, .xz = b.xz, .yz = b.yz}; }
    constexpr BivectorWeight Translator::reverseSandwich(const BivectorWeight& b) const noexcept { return {.wx = b.wx, .wy = b.wy, .wz = b.wz}; }
    constexpr PseudoScalar Translator::reverseSandwich(const PseudoScalar& b) const noexcept { return {.i = b.i}; }
    constexpr Point Translator::reverseSandwich(const PointCenter& b) const noexcept { return {.x = 2.0 * wx, .y = 2.0 * wy, .z = 2.0 * wz}; }

    constexpr Motor Point::reverseSandwich(const Motor& b) const noexcept { return {.s = b.s, .wx = (-b.wx + 2.0 * (b.xy * y + b.xz * z)), .wy = (-b.wy + 2.0 * (b.yz * z - b.xy * x)), .wz = (-b.wz + 2.0 * (-b.xz * x - b.yz * y)), .xy = b.xy, .xz = b.xz, .yz = b.yz, .i = -b.i}; }
    constexpr Plane Point::reverseSandwich(const Plane& b) const noexcept { return {.x = b.x, .y = b.y, .z = b.z, .w = (-b.w + 2.0 * (-b.x * x - b.y * y - b.z * z))}; }
    constexpr Bivector Point::reverseSandwich(const Bivector& b) const noexcept { return {.wx = (-b.wx + 2.0 * (b.xy * y + b.xz * z)), .wy = (-b.wy + 2.0 * (b.yz * z - b.xy * x)), .wz = (-b.wz + 2.0 * (-b.xz * x - b.yz * y)), .xy = b.xy, .xz = b.xz, .yz = b.yz}; }
    constexpr ProjectivePoint Point::reverseSandwich(const ProjectivePoint& b) const noexcept { return {.x = (-b.x + 2.0 * b.w * x), .y = (-b.y + 2.0 * b.w * y), .z = (-b.z + 2.0 * b.w * z), .w = b.w}; }
    constexpr Motor Point::reverseSandwich(const Quaternion& b) const noexcept { return {.s = b.s, .wx = 2.0 * (b.xy * y + b.xz * z), .wy = 2.0 * (b.yz * z - b.xy * x), .wz = 2.0 * (-b.xz * x - b.yz * y), .xy = b.xy, .xz = b.xz, .yz = b.yz, .i = 0.0}; }
    constexpr ProjectiveTranslator Point::reverseSandwich(const ProjectiveTranslator& b) const noexcept { return {.s = b.s, .wx = -b.wx, .wy = -b.wy, .wz = -b.wz}; }
    constexpr Translator Point::reverseSandwich(const Translator& b) const noexcept { return {.wx = -b.wx, .wy = -b.wy, .wz = -b.wz}; }
    constexpr Vector Point::reverseSandwich(const Vector& b) const noexcept { return {.x = -b.x, .y = -b.y, .z = -b.z}; }
    constexpr Point Point::reverseSandwich(const Point& b) const noexcept { return {.x = (-b.x + 2.0 * x), .y = (-b.y + 2.0 * y), .z = (-b.z + 2.0 * z)}; }
    constexpr Plane Point::reverseSandwich(const PlaneIdeal& b) const noexcept { return {.x = b.x, .y = b.y, .z = b.z, .w = 2.0 * (-b.x * x - b.y * y - b.z * z)}; }
    constexpr Bivector Point::reverseSandwich(const BivectorBulk& b) const noexcept { return {.wx = 2.0 * (b.xy * y + b.xz * z), .wy = 2.0 * (b.yz * z - b.xy * x), .wz = 2.0 * (-b.xz * x - b.yz * y), .xy = b.xy, .xz = b.xz, .yz = b.yz}; }
    constexpr BivectorWeight Point::reverseSandwich(const BivectorWeight& b) const noexcept { return {.wx = -b.wx, .wy = -b.wy, .wz = -b.wz}; }
    constexpr PseudoScalar Point::reverseSandwich(const PseudoScalar& b) const noexcept { return {.i = -b.i}; }
    constexpr Point Point::reverseSandwich(const PointCenter& b) const noexcept { return {.x = 2.0 * x, .y = 2.0 * y, .z = 2.0 * z}; }

    constexpr Motor PlaneIdeal::reverseSandwich(const Motor& b) const noexcept { return {.s = b.s * (x * x + y * y + z * z), .wx = (b.wx * (y * y + z * z - x * x) + 2.0 * x * (-b.wy * y - b.wz * z)), .wy = (b.wy * (x * x + z * z - y * y) + 2.0 * y * (-b.wx * x - b.wz * z)), .wz = (b.wz * (x * x + y * y - z * z) + 2.0 * z * (-b.wx * x - b.wy * y)), .xy = (b.xy * (z * z - x * x - y * y) + 2.0 * z * (b.yz * x - b.xz * y)), .xz = (b.xz * (y * y - x * x - z * z) + 2.0 * y * (-b.xy * z - b.yz * x)), .yz = (b.yz * (x * x - y * y - z * z) + 2.0 * x * (b.xy * z - b.xz * y)), .i = b.i * (-x * x - y * y - z * z)}; }
    constexpr Plane PlaneIdeal::reverseSandwich(const Plane& b) const noexcept { return {.x = (b.x * (x * x - y * y - z * z) + 2.0 * x * (b.y * y + b.z * z)), .y = (b.y * (y * y - x * x - z * z) + 2.0 * y * (b.x * x + b.z * z)), .z = (b.z * (z * z - x * x - y * y) + 2.0 * z * (b.x * x + b.y * y)), .w = b.w * (-x * x - y * y - z * z)}; }
    constexpr Bivector PlaneIdeal::reverseSandwich(const Bivector& b) const noexcept { return {.wx = (b.wx * (y * y + z * z - x * x) + 2.0 * x * (-b.wy * y - b.wz * z)), .wy = (b.wy * (x * x + z * z - y * y) + 2.0 * y * (-b.wx * x - b.wz * z)), .wz = (b.wz * (x * x + y * y - z * z) + 2.0 * z * (-b.wx * x - b.wy * y)), .xy = (b.xy * (z * z - x * x - y * y) + 2.0 * z * (b.yz * x - b.xz * y)), .xz = (b.xz * (y * y - x * x - z * z) + 2.0 * y * (-b.xy * z - b.yz * x)), .yz = (b.yz * (x * x - y * y - z * z) + 2.0 * x * (b.xy * z - b.xz * y))}; }
    constexpr ProjectivePoint PlaneIdeal::reverseSandwich(const ProjectivePoint& b) const noexcept { return {.x = (b.x * y * y + b.x * z * z - 2.0 * b.y * x * y - 2.0 * b.z * x * z - b.x * x * x), .y = (b.y * (x * x + z * z - y * y) + 2.0 * y * (-b.x * x - b.z * z)), .z = (b.z * x * x + b.z * y * y - 2.0 * b.x * x * z - 2.0 * b.y * y * z - b.z * z * z), .w = b.w * (x * x + y * y + z * z)}; }
    constexpr Quaternion PlaneIdeal::reverseSandwich(const Quaternion& b) const noexcept { return {.s = b.s * (x * x + y * y + z * z), .xy = (b.xy * (z * z - x * x - y * y) + 2.0 * z * (b.yz * x - b.xz * y)), .xz = (b.xz * (y * y - x * x - z * z) + 2.0 * y * (-b.xy * z - b.yz * x)), .yz = (b.yz * (x * x - y * y - z * z) + 2.0 * x * (b.xy * z - b.xz * y))}; }
    constexpr ProjectiveTranslator PlaneIdeal::reverseSandwich(const ProjectiveTranslator& b) const noexcept { return {.s = b.s * (x * x + y * y + z * z), .wx = (b.wx * (y * y + z * z - x * x) + 2.0 * x * (-b.wy * y - b.wz * z)), .wy = (b.wy * (x * x + z * z - y * y) + 2.0 * y * (-b.wx * x - b.wz * z)), .wz = (b.wz * (x * x + y * y - z * z) + 2.0 * z * (-b.wx * x - b.wy * y))}; }
    constexpr ProjectiveTranslator PlaneIdeal::reverseSandwich(const Translator& b) const noexcept { return {.s = (x * x + y * y + z * z), .wx = (b.wx * (y * y + z * z - x * x) + 2.0 * x * (-b.wy * y - b.wz * z)), .wy = (b.wy * (x * x + z * z - y * y) + 2.0 * y * (-b.wx * x - b.wz * z)), .wz = (b.wz * (x * x + y * y - z * z) + 2.0 * z * (-b.wx * x - b.wy * y))}; }
    constexpr Vector PlaneIdeal::reverseSandwich(const Vector& b) const noexcept { return {.x = (b.x * y * y + b.x * z * z - 2.0 * b.y * x * y - 2.0 * b.z * x * z - b.x * x * x), .y = (b.y * (x * x + z * z - y * y) + 2.0 * y * (-b.x * x - b.z * z)), .z = (b.z * x * x + b.z * y * y - 2.0 * b.x * x * z - 2.0 * b.y * y * z - b.z * z * z)}; }
    constexpr ProjectivePoint PlaneIdeal::reverseSandwich(const Point& b) const noexcept { return {.x = (b.x * y * y + b.x * z * z - 2.0 * b.y * x * y - 2.0 * b.z * x * z - b.x * x * x), .y = (b.y * (x * x + z * z - y * y) + 2.0 * y * (-b.x * x - b.z * z)), .z = (b.z * x * x + b.z * y * y - 2.0 * b.x * x * z - 2.0 * b.y * y * z - b.z * z * z), .w = (x * x + y * y + z * z)}; }
    constexpr PlaneIdeal PlaneIdeal::reverseSandwich(const PlaneIdeal& b) const noexcept { return {.x = (b.x * (x * x - y * y - z * z) + 2.0 * x * (b.y * y + b.z * z)), .y = (b.y * (y * y - x * x - z * z) + 2.0 * y * (b.x * x + b.z * z)), .z = (b.z * (z * z - x * x - y * y) + 2.0 * z * (b.x * x + b.y * y))}; }
    constexpr BivectorBulk PlaneIdeal::reverseSandwich(const BivectorBulk& b) const noexcept { return {.xy = (b.xy * (z * z - x * x - y * y) + 2.0 * z * (b.yz * x - b.xz * y)), .xz = (b.xz * (y * y - x * x - z * z) + 2.0 * y * (-b.xy * z - b.yz * x)), .yz = (b.yz * (x * x - y * y - z * z) + 2.0 * x * (b.xy * z - b.xz * y))}; }
    constexpr BivectorWeight PlaneIdeal::reverseSandwich(const BivectorWeight& b) const noexcept { return {.wx = (b.wx * (y * y + z * z - x * x) + 2.0 * x * (-b.wy * y - b.wz * z)), .wy = (b.wy * (x * x + z * z - y * y) + 2.0 * y * (-b.wx * x - b.wz * z)), .wz = (b.wz * (x * x + y * y - z * z) + 2.0 * z * (-b.wx * x - b.wy * y))}; }
    constexpr PseudoScalar PlaneIdeal::reverseSandwich(const PseudoScalar& b) const noexcept { return {.i = b.i * (-x * x - y * y - z * z)}; }
    constexpr ProjectivePoint PlaneIdeal::reverseSandwich(const PointCenter& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = (x * x + y * y + z * z)}; }

    constexpr Motor BivectorBulk::reverseSandwich(const Motor& b) const noexcept { return {.s = b.s * (xy * xy + xz * xz + yz * yz), .wx = (b.wx * (yz * yz - xy * xy - xz * xz) + 2.0 * yz * (b.wz * xy - b.wy * xz)), .wy = (b.wy * (xz * xz - xy * xy - yz * yz) + 2.0 * xz * (-b.wx * yz - b.wz * xy)), .wz = (b.wz * (xy * xy - xz * xz - yz * yz) + 2.0 * xy * (b.wx * yz - b.wy * xz)), .xy = (b.xy * (xy * xy - xz * xz - yz * yz) + 2.0 * xy * (b.xz * xz + b.yz * yz)), .xz = (b.xz * (xz * xz - xy * xy - yz * yz) + 2.0 * xz * (b.xy * xy + b.yz * yz)), .yz = (b.yz * (yz * yz - xy * xy - xz * xz) + 2.0 * yz * (b.xy * xy + b.xz * xz)), .i = b.i * (xy * xy + xz * xz + yz * yz)}; }
    constexpr Plane BivectorBulk::reverseSandwich(const Plane& b) const noexcept { return {.x = (b.x * (yz * yz - xy * xy - xz * xz) + 2.0 * yz * (b.z * xy - b.y * xz)), .y = (b.y * (xz * xz - xy * xy - yz * yz) + 2.0 * xz * (-b.x * yz - b.z * xy)), .z = (b.z * (xy * xy - xz * xz - yz * yz) + 2.0 * xy * (b.x * yz - b.y * xz)), .w = b.w * (xy * xy + xz * xz + yz * yz)}; }
    constexpr Bivector BivectorBulk::reverseSandwich(const Bivector& b) const noexcept { return {.wx = (b.wx * (yz * yz - xy * xy - xz * xz) + 2.0 * yz * (b.wz * xy - b.wy * xz)), .wy = (b.wy * (xz * xz - xy * xy - yz * yz) + 2.0 * xz * (-b.wx * yz - b.wz * xy)), .wz = (b.wz * (xy * xy - xz * xz - yz * yz) + 2.0 * xy * (b.wx * yz - b.wy * xz)), .xy = (b.xy * (xy * xy - xz * xz - yz * yz) + 2.0 * xy * (b.xz * xz + b.yz * yz)), .xz = (b.xz * (xz * xz - xy * xy - yz * yz) + 2.0 * xz * (b.xy * xy + b.yz * yz)), .yz = (b.yz * (yz * yz - xy * xy - xz * xz) + 2.0 * yz * (b.xy * xy + b.xz * xz))}; }
    constexpr ProjectivePoint BivectorBulk::reverseSandwich(const ProjectivePoint& b) const noexcept { return {.x = (b.x * yz * yz - 2.0 * b.y * xz * yz - b.x * xy * xy - b.x * xz * xz + 2.0 * b.z * xy * yz), .y = (b.y * (xz * xz - xy * xy - yz * yz) + 2.0 * xz * (-b.x * yz - b.z * xy)), .z = (b.z * xy * xy - 2.0 * b.y * xy * xz - b.z * xz * xz - b.z * yz * yz + 2.0 * b.x * xy * yz), .w = b.w * (xy * xy + xz * xz + yz * yz)}; }
    constexpr Quaternion BivectorBulk::reverseSandwich(const Quaternion& b) const noexcept { return {.s = b.s * (xy * xy + xz * xz + yz * yz), .xy = (b.xy * (xy * xy - xz * xz - yz * yz) + 2.0 * xy * (b.xz * xz + b.yz * yz)), .xz = (b.xz * (xz * xz - xy * xy - yz * yz) + 2.0 * xz * (b.xy * xy + b.yz * yz)), .yz = (b.yz * (yz * yz - xy * xy - xz * xz) + 2.0 * yz * (b.xy * xy + b.xz * xz))}; }
    constexpr ProjectiveTranslator BivectorBulk::reverseSandwich(const ProjectiveTranslator& b) const noexcept { return {.s = b.s * (xy * xy + xz * xz + yz * yz), .wx = (b.wx * (yz * yz - xy * xy - xz * xz) + 2.0 * yz * (b.wz * xy - b.wy * xz)), .wy = (b.wy * (xz * xz - xy * xy - yz * yz) + 2.0 * xz * (-b.wx * yz - b.wz * xy)), .wz = (b.wz * (xy * xy - xz * xz - yz * yz) + 2.0 * xy * (b.wx * yz - b.wy * xz))}; }
    constexpr ProjectiveTranslator BivectorBulk::reverseSandwich(const Translator& b) const noexcept { return {.s = (xy * xy + xz * xz + yz * yz), .wx = (b.wx * (yz * yz - xy * xy - xz * xz) + 2.0 * yz * (b.wz * xy - b.wy * xz)), .wy = (b.wy * (xz * xz - xy * xy - yz * yz) + 2.0 * xz * (-b.wx * yz - b.wz * xy)), .wz = (b.wz * (xy * xy - xz * xz - yz * yz) + 2.0 * xy * (b.wx * yz - b.wy * xz))}; }
    constexpr Vector BivectorBulk::reverseSandwich(const Vector& b) const noexcept { return {.x = (b.x * yz * yz - 2.0 * b.y * xz * yz - b.x * xy * xy - b.x * xz * xz + 2.0 * b.z * xy * yz), .y = (b.y * (xz * xz - xy * xy - yz * yz) + 2.0 * xz * (-b.x * yz - b.z * xy)), .z = (b.z * xy * xy - 2.0 * b.y * xy * xz - b.z * xz * xz - b.z * yz * yz + 2.0 * b.x * xy * yz)}; }
    constexpr ProjectivePoint BivectorBulk::reverseSandwich(const Point& b) const noexcept { return {.x = (b.x * yz * yz - 2.0 * b.y * xz * yz - b.x * xy * xy - b.x * xz * xz + 2.0 * b.z * xy * yz), .y = (b.y * (xz * xz - xy * xy - yz * yz) + 2.0 * xz * (-b.x * yz - b.z * xy)), .z = (b.z * xy * xy - 2.0 * b.y * xy * xz - b.z * xz * xz - b.z * yz * yz + 2.0 * b.x * xy * yz), .w = (xy * xy + xz * xz + yz * yz)}; }
    constexpr PlaneIdeal BivectorBulk::reverseSandwich(const PlaneIdeal& b) const noexcept { return {.x = (b.x * (yz * yz - xy * xy - xz * xz) + 2.0 * yz * (b.z * xy - b.y * xz)), .y = (b.y * (xz * xz - xy * xy - yz * yz) + 2.0 * xz * (-b.x * yz - b.z * xy)), .z = (b.z * (xy * xy - xz * xz - yz * yz) + 2.0 * xy * (b.x * yz - b.y * xz))}; }
    constexpr BivectorBulk BivectorBulk::reverseSandwich(const BivectorBulk& b) const noexcept { return {.xy = (b.xy * (xy * xy - xz * xz - yz * yz) + 2.0 * xy * (b.xz * xz + b.yz * yz)), .xz = (b.xz * (xz * xz - xy * xy - yz * yz) + 2.0 * xz * (b.xy * xy + b.yz * yz)), .yz = (b.yz * (yz * yz - xy * xy - xz * xz) + 2.0 * yz * (b.xy * xy + b.xz * xz))}; }
    constexpr BivectorWeight BivectorBulk::reverseSandwich(const BivectorWeight& b) const noexcept { return {.wx = (b.wx * (yz * yz - xy * xy - xz * xz) + 2.0 * yz * (b.wz * xy - b.wy * xz)), .wy = (b.wy * (xz * xz - xy * xy - yz * yz) + 2.0 * xz * (-b.wx * yz - b.wz * xy)), .wz = (b.wz * (xy * xy - xz * xz - yz * yz) + 2.0 * xy * (b.wx * yz - b.wy * xz))}; }
    constexpr PseudoScalar BivectorBulk::reverseSandwich(const PseudoScalar& b) const noexcept { return {.i = b.i * (xy * xy + xz * xz + yz * yz)}; }
    constexpr ProjectivePoint BivectorBulk::reverseSandwich(const PointCenter& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = (xy * xy + xz * xz + yz * yz)}; }

    constexpr Motor PointCenter::reverseSandwich(const Motor& b) const noexcept { return {.s = b.s, .wx = -b.wx, .wy = -b.wy, .wz = -b.wz, .xy = b.xy, .xz = b.xz, .yz = b.yz, .i = -b.i}; }
    constexpr Plane PointCenter::reverseSandwich(const Plane& b) const noexcept { return {.x = b.x, .y = b.y, .z = b.z, .w = -b.w}; }
    constexpr Bivector PointCenter::reverseSandwich(const Bivector& b) const noexcept { return {.wx = -b.wx, .wy = -b.wy, .wz = -b.wz, .xy = b.xy, .xz = b.xz, .yz = b.yz}; }
    constexpr ProjectivePoint PointCenter::reverseSandwich(const ProjectivePoint& b) const noexcept { return {.x = -b.x, .y = -b.y, .z = -b.z, .w = b.w}; }
    constexpr Quaternion PointCenter::reverseSandwich(const Quaternion& b) const noexcept { return {.s = b.s, .xy = b.xy, .xz = b.xz, .yz = b.yz}; }
    constexpr ProjectiveTranslator PointCenter::reverseSandwich(const ProjectiveTranslator& b) const noexcept { return {.s = b.s, .wx = -b.wx, .wy = -b.wy, .wz = -b.wz}; }
    constexpr Translator PointCenter::reverseSandwich(const Translator& b) const noexcept { return {.wx = -b.wx, .wy = -b.wy, .wz = -b.wz}; }
    constexpr Vector PointCenter::reverseSandwich(const Vector& b) const noexcept { return {.x = -b.x, .y = -b.y, .z = -b.z}; }
    constexpr Point PointCenter::reverseSandwich(const Point& b) const noexcept { return {.x = -b.x, .y = -b.y, .z = -b.z}; }
    constexpr PlaneIdeal PointCenter::reverseSandwich(const PlaneIdeal& b) const noexcept { return {.x = b.x, .y = b.y, .z = b.z}; }
    constexpr BivectorBulk PointCenter::reverseSandwich(const BivectorBulk& b) const noexcept { return {.xy = b.xy, .xz = b.xz, .yz = b.yz}; }
    constexpr BivectorWeight PointCenter::reverseSandwich(const BivectorWeight& b) const noexcept { return {.wx = -b.wx, .wy = -b.wy, .wz = -b.wz}; }
    constexpr PseudoScalar PointCenter::reverseSandwich(const PseudoScalar& b) const noexcept { return {.i = -b.i}; }
    constexpr PointCenter PointCenter::reverseSandwich(const PointCenter& b) const noexcept { return {}; }

}

// opsCross.h

// generated by com.github.kright.pga3d.codegen.cpp.ops.CrossOpGenerator

namespace pga3d {
    constexpr Multivector Multivector::cross(const Multivector& b) const noexcept { return {.s = 0.0, .w = (b.i * xyz + b.x * wx + b.y * wy + b.z * wz - b.wx * x - b.wy * y - b.wz * z - b.xyz * i), .x = (b.y * xy + b.z * xz - b.xy * y - b.xz * z), .y = (b.xy * x + b.z * yz - b.x * xy - b.yz * z), .z = (b.xz * x + b.yz * y - b.x * xz - b.y * yz), .wx = (b.wy * xy + b.wyz * xyz + b.wz * xz + b.x * w - b.w * x - b.xy * wy - b.xyz * wyz - b.xz * wz), .wy = (b.wz * yz + b.xy * wx + b.xyz * wxz + b.y * w - b.w * y - b.wx * xy - b.wxz * xyz - b.yz * wz), .wz = (b.wxy * xyz + b.xz * wx + b.yz * wy + b.z * w - b.w * z - b.wx * xz - b.wy * yz - b.xyz * wxy), .xy = (b.xz * yz + b.y * x - b.x * y - b.yz * xz), .xz = (b.yz * xy + b.z * x - b.x * z - b.xy * yz), .yz = (b.xy * xz + b.z * y - b.xz * xy - b.y * z), .wxy = (b.wxz * yz + b.xyz * wz + b.xz * wyz + b.z * i - b.i * z - b.wyz * xz - b.wz * xyz - b.yz * wxz), .wxz = (b.i * y + b.wy * xyz + b.wyz * xy + b.yz * wxy - b.wxy * yz - b.xy * wyz - b.xyz * wy - b.y * i), .wyz = (b.wxy * xz + b.x * i + b.xy * wxz + b.xyz * wx - b.i * x - b.wx * xyz - b.wxz * xy - b.xz * wxy), .xyz = 0.0, .i = (b.wxz * y + b.x * wyz + b.xyz * w + b.z * wxy - b.w * xyz - b.wxy * z - b.wyz * x - b.y * wxz)}; }

    constexpr Bivector Motor::cross(const Motor& b) const noexcept { return {.wx = (b.wy * xy + b.wz * xz - b.xy * wy - b.xz * wz), .wy = (b.wz * yz + b.xy * wx - b.wx * xy - b.yz * wz), .wz = (b.xz * wx + b.yz * wy - b.wx * xz - b.wy * yz), .xy = (b.xz * yz - b.yz * xz), .xz = (b.yz * xy - b.xy * yz), .yz = (b.xy * xz - b.xz * xy)}; }
    constexpr Multivector Motor::cross(const Plane& b) const noexcept { return {.s = 0.0, .w = (b.x * wx + b.y * wy + b.z * wz), .x = (b.y * xy + b.z * xz), .y = (b.z * yz - b.x * xy), .z = (-b.x * xz - b.y * yz), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = b.z * i, .wxz = -b.y * i, .wyz = b.x * i, .xyz = 0.0, .i = 0.0}; }
    constexpr Bivector Motor::cross(const Bivector& b) const noexcept { return {.wx = (b.wy * xy + b.wz * xz - b.xy * wy - b.xz * wz), .wy = (b.wz * yz + b.xy * wx - b.wx * xy - b.yz * wz), .wz = (b.xz * wx + b.yz * wy - b.wx * xz - b.wy * yz), .xy = (b.xz * yz - b.yz * xz), .xz = (b.yz * xy - b.xy * yz), .yz = (b.xy * xz - b.xz * xy)}; }
    constexpr Multivector Motor::cross(const ProjectivePoint& b) const noexcept { return {.s = 0.0, .w = -b.w * i, .x = 0.0, .y = 0.0, .z = 0.0, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (b.w * wz + b.x * xz + b.y * yz), .wxz = (b.z * yz - b.w * wy - b.x * xy), .wyz = (b.w * wx - b.y * xy - b.z * xz), .xyz = 0.0, .i = 0.0}; }
    constexpr Bivector Motor::cross(const Quaternion& b) const noexcept { return {.wx = (-b.xy * wy - b.xz * wz), .wy = (b.xy * wx - b.yz * wz), .wz = (b.xz * wx + b.yz * wy), .xy = (b.xz * yz - b.yz * xz), .xz = (b.yz * xy - b.xy * yz), .yz = (b.xy * xz - b.xz * xy)}; }
    constexpr BivectorWeight Motor::cross(const ProjectiveTranslator& b) const noexcept { return {.wx = (b.wy * xy + b.wz * xz), .wy = (b.wz * yz - b.wx * xy), .wz = (-b.wx * xz - b.wy * yz)}; }
    constexpr BivectorWeight Motor::cross(const Translator& b) const noexcept { return {.wx = (b.wy * xy + b.wz * xz), .wy = (b.wz * yz - b.wx * xy), .wz = (-b.wx * xz - b.wy * yz)}; }
    constexpr Vector Motor::cross(const Vector& b) const noexcept { return {.x = (b.y * xy + b.z * xz), .y = (b.z * yz - b.x * xy), .z = (-b.x * xz - b.y * yz)}; }
    constexpr Multivector Motor::cross(const Point& b) const noexcept { return {.s = 0.0, .w = -i, .x = 0.0, .y = 0.0, .z = 0.0, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (wz + b.x * xz + b.y * yz), .wxz = (-wy + b.z * yz - b.x * xy), .wyz = (wx - b.y * xy - b.z * xz), .xyz = 0.0, .i = 0.0}; }
    constexpr Multivector Motor::cross(const PlaneIdeal& b) const noexcept { return {.s = 0.0, .w = (b.x * wx + b.y * wy + b.z * wz), .x = (b.y * xy + b.z * xz), .y = (b.z * yz - b.x * xy), .z = (-b.x * xz - b.y * yz), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = b.z * i, .wxz = -b.y * i, .wyz = b.x * i, .xyz = 0.0, .i = 0.0}; }
    constexpr Bivector Motor::cross(const BivectorBulk& b) const noexcept { return {.wx = (-b.xy * wy - b.xz * wz), .wy = (b.xy * wx - b.yz * wz), .wz = (b.xz * wx + b.yz * wy), .xy = (b.xz * yz - b.yz * xz), .xz = (b.yz * xy - b.xy * yz), .yz = (b.xy * xz - b.xz * xy)}; }
    constexpr BivectorWeight Motor::cross(const BivectorWeight& b) const noexcept { return {.wx = (b.wy * xy + b.wz * xz), .wy = (b.wz * yz - b.wx * xy), .wz = (-b.wx * xz - b.wy * yz)}; }
    constexpr Multivector Motor::cross(const PointCenter& b) const noexcept { return {.s = 0.0, .w = -i, .x = 0.0, .y = 0.0, .z = 0.0, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = wz, .wxz = -wy, .wyz = wx, .xyz = 0.0, .i = 0.0}; }

    constexpr Multivector Plane::cross(const Motor& b) const noexcept { return {.s = 0.0, .w = (-b.wx * x - b.wy * y - b.wz * z), .x = (-b.xy * y - b.xz * z), .y = (b.xy * x - b.yz * z), .z = (b.xz * x + b.yz * y), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = -b.i * z, .wxz = b.i * y, .wyz = -b.i * x, .xyz = 0.0, .i = 0.0}; }
    constexpr Bivector Plane::cross(const Plane& b) const noexcept { return {.wx = (b.x * w - b.w * x), .wy = (b.y * w - b.w * y), .wz = (b.z * w - b.w * z), .xy = (b.y * x - b.x * y), .xz = (b.z * x - b.x * z), .yz = (b.z * y - b.y * z)}; }
    constexpr Plane Plane::cross(const Bivector& b) const noexcept { return {.x = (-b.xy * y - b.xz * z), .y = (b.xy * x - b.yz * z), .z = (b.xz * x + b.yz * y), .w = (-b.wx * x - b.wy * y - b.wz * z)}; }
    constexpr PseudoScalar Plane::cross(const ProjectivePoint& b) const noexcept { return {.i = (b.w * w + b.x * x + b.y * y + b.z * z)}; }
    constexpr PlaneIdeal Plane::cross(const Quaternion& b) const noexcept { return {.x = (-b.xy * y - b.xz * z), .y = (b.xy * x - b.yz * z), .z = (b.xz * x + b.yz * y)}; }
    constexpr Plane Plane::cross(const ProjectiveTranslator& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = (-b.wx * x - b.wy * y - b.wz * z)}; }
    constexpr Plane Plane::cross(const Translator& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = (-b.wx * x - b.wy * y - b.wz * z)}; }
    constexpr PseudoScalar Plane::cross(const Vector& b) const noexcept { return {.i = (b.x * x + b.y * y + b.z * z)}; }
    constexpr PseudoScalar Plane::cross(const Point& b) const noexcept { return {.i = (w + b.x * x + b.y * y + b.z * z)}; }
    constexpr Bivector Plane::cross(const PlaneIdeal& b) const noexcept { return {.wx = b.x * w, .wy = b.y * w, .wz = b.z * w, .xy = (b.y * x - b.x * y), .xz = (b.z * x - b.x * z), .yz = (b.z * y - b.y * z)}; }
    constexpr PlaneIdeal Plane::cross(const BivectorBulk& b) const noexcept { return {.x = (-b.xy * y - b.xz * z), .y = (b.xy * x - b.yz * z), .z = (b.xz * x + b.yz * y)}; }
    constexpr Plane Plane::cross(const BivectorWeight& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = (-b.wx * x - b.wy * y - b.wz * z)}; }
    constexpr Vector Plane::cross(const PseudoScalar& b) const noexcept { return {.x = b.i * x, .y = b.i * y, .z = b.i * z}; }
    constexpr PseudoScalar Plane::cross(const PointCenter& b) const noexcept { return {.i = w}; }

    constexpr Bivector Bivector::cross(const Motor& b) const noexcept { return {.wx = (b.wy * xy + b.wz * xz - b.xy * wy - b.xz * wz), .wy = (b.wz * yz + b.xy * wx - b.wx * xy - b.yz * wz), .wz = (b.xz * wx + b.yz * wy - b.wx * xz - b.wy * yz), .xy = (b.xz * yz - b.yz * xz), .xz = (b.yz * xy - b.xy * yz), .yz = (b.xy * xz - b.xz * xy)}; }
    constexpr Plane Bivector::cross(const Plane& b) const noexcept { return {.x = (b.y * xy + b.z * xz), .y = (b.z * yz - b.x * xy), .z = (-b.x * xz - b.y * yz), .w = (b.x * wx + b.y * wy + b.z * wz)}; }
    constexpr Bivector Bivector::cross(const Bivector& b) const noexcept { return {.wx = (b.wy * xy + b.wz * xz - b.xy * wy - b.xz * wz), .wy = (b.wz * yz + b.xy * wx - b.wx * xy - b.yz * wz), .wz = (b.xz * wx + b.yz * wy - b.wx * xz - b.wy * yz), .xy = (b.xz * yz - b.yz * xz), .xz = (b.yz * xy - b.xy * yz), .yz = (b.xy * xz - b.xz * xy)}; }
    constexpr Vector Bivector::cross(const ProjectivePoint& b) const noexcept { return {.x = (b.y * xy + b.z * xz - b.w * wx), .y = (b.z * yz - b.w * wy - b.x * xy), .z = (-b.w * wz - b.x * xz - b.y * yz)}; }
    constexpr Bivector Bivector::cross(const Quaternion& b) const noexcept { return {.wx = (-b.xy * wy - b.xz * wz), .wy = (b.xy * wx - b.yz * wz), .wz = (b.xz * wx + b.yz * wy), .xy = (b.xz * yz - b.yz * xz), .xz = (b.yz * xy - b.xy * yz), .yz = (b.xy * xz - b.xz * xy)}; }
    constexpr BivectorWeight Bivector::cross(const ProjectiveTranslator& b) const noexcept { return {.wx = (b.wy * xy + b.wz * xz), .wy = (b.wz * yz - b.wx * xy), .wz = (-b.wx * xz - b.wy * yz)}; }
    constexpr BivectorWeight Bivector::cross(const Translator& b) const noexcept { return {.wx = (b.wy * xy + b.wz * xz), .wy = (b.wz * yz - b.wx * xy), .wz = (-b.wx * xz - b.wy * yz)}; }
    constexpr Vector Bivector::cross(const Vector& b) const noexcept { return {.x = (b.y * xy + b.z * xz), .y = (b.z * yz - b.x * xy), .z = (-b.x * xz - b.y * yz)}; }
    constexpr Vector Bivector::cross(const Point& b) const noexcept { return {.x = (-wx + b.y * xy + b.z * xz), .y = (-wy + b.z * yz - b.x * xy), .z = (-wz - b.x * xz - b.y * yz)}; }
    constexpr Plane Bivector::cross(const PlaneIdeal& b) const noexcept { return {.x = (b.y * xy + b.z * xz), .y = (b.z * yz - b.x * xy), .z = (-b.x * xz - b.y * yz), .w = (b.x * wx + b.y * wy + b.z * wz)}; }
    constexpr Bivector Bivector::cross(const BivectorBulk& b) const noexcept { return {.wx = (-b.xy * wy - b.xz * wz), .wy = (b.xy * wx - b.yz * wz), .wz = (b.xz * wx + b.yz * wy), .xy = (b.xz * yz - b.yz * xz), .xz = (b.yz * xy - b.xy * yz), .yz = (b.xy * xz - b.xz * xy)}; }
    constexpr BivectorWeight Bivector::cross(const BivectorWeight& b) const noexcept { return {.wx = (b.wy * xy + b.wz * xz), .wy = (b.wz * yz - b.wx * xy), .wz = (-b.wx * xz - b.wy * yz)}; }
    constexpr Vector Bivector::cross(const PointCenter& b) const noexcept { return {.x = -wx, .y = -wy, .z = -wz}; }

    constexpr Multivector ProjectivePoint::cross(const Motor& b) const noexcept { return {.s = 0.0, .w = b.i * w, .x = 0.0, .y = 0.0, .z = 0.0, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (-b.wz * w - b.xz * x - b.yz * y), .wxz = (b.wy * w + b.xy * x - b.yz * z), .wyz = (b.xy * y + b.xz * z - b.wx * w), .xyz = 0.0, .i = 0.0}; }
    constexpr PseudoScalar ProjectivePoint::cross(const Plane& b) const noexcept { return {.i = (-b.w * w - b.x * x - b.y * y - b.z * z)}; }
    constexpr Vector ProjectivePoint::cross(const Bivector& b) const noexcept { return {.x = (b.wx * w - b.xy * y - b.xz * z), .y = (b.wy * w + b.xy * x - b.yz * z), .z = (b.wz * w + b.xz * x + b.yz * y)}; }
    constexpr BivectorWeight ProjectivePoint::cross(const ProjectivePoint& b) const noexcept { return {.wx = (b.w * x - b.x * w), .wy = (b.w * y - b.y * w), .wz = (b.w * z - b.z * w)}; }
    constexpr Vector ProjectivePoint::cross(const Quaternion& b) const noexcept { return {.x = (-b.xy * y - b.xz * z), .y = (b.xy * x - b.yz * z), .z = (b.xz * x + b.yz * y)}; }
    constexpr Vector ProjectivePoint::cross(const ProjectiveTranslator& b) const noexcept { return {.x = b.wx * w, .y = b.wy * w, .z = b.wz * w}; }
    constexpr Vector ProjectivePoint::cross(const Translator& b) const noexcept { return {.x = b.wx * w, .y = b.wy * w, .z = b.wz * w}; }
    constexpr BivectorWeight ProjectivePoint::cross(const Vector& b) const noexcept { return {.wx = -b.x * w, .wy = -b.y * w, .wz = -b.z * w}; }
    constexpr BivectorWeight ProjectivePoint::cross(const Point& b) const noexcept { return {.wx = (x - b.x * w), .wy = (y - b.y * w), .wz = (z - b.z * w)}; }
    constexpr PseudoScalar ProjectivePoint::cross(const PlaneIdeal& b) const noexcept { return {.i = (-b.x * x - b.y * y - b.z * z)}; }
    constexpr Vector ProjectivePoint::cross(const BivectorBulk& b) const noexcept { return {.x = (-b.xy * y - b.xz * z), .y = (b.xy * x - b.yz * z), .z = (b.xz * x + b.yz * y)}; }
    constexpr Vector ProjectivePoint::cross(const BivectorWeight& b) const noexcept { return {.x = b.wx * w, .y = b.wy * w, .z = b.wz * w}; }
    constexpr Plane ProjectivePoint::cross(const PseudoScalar& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = b.i * w}; }
    constexpr BivectorWeight ProjectivePoint::cross(const PointCenter& b) const noexcept { return {.wx = x, .wy = y, .wz = z}; }

    constexpr Bivector Quaternion::cross(const Motor& b) const noexcept { return {.wx = (b.wy * xy + b.wz * xz), .wy = (b.wz * yz - b.wx * xy), .wz = (-b.wx * xz - b.wy * yz), .xy = (b.xz * yz - b.yz * xz), .xz = (b.yz * xy - b.xy * yz), .yz = (b.xy * xz - b.xz * xy)}; }
    constexpr PlaneIdeal Quaternion::cross(const Plane& b) const noexcept { return {.x = (b.y * xy + b.z * xz), .y = (b.z * yz - b.x * xy), .z = (-b.x * xz - b.y * yz)}; }
    constexpr Bivector Quaternion::cross(const Bivector& b) const noexcept { return {.wx = (b.wy * xy + b.wz * xz), .wy = (b.wz * yz - b.wx * xy), .wz = (-b.wx * xz - b.wy * yz), .xy = (b.xz * yz - b.yz * xz), .xz = (b.yz * xy - b.xy * yz), .yz = (b.xy * xz - b.xz * xy)}; }
    constexpr Vector Quaternion::cross(const ProjectivePoint& b) const noexcept { return {.x = (b.y * xy + b.z * xz), .y = (b.z * yz - b.x * xy), .z = (-b.x * xz - b.y * yz)}; }
    constexpr BivectorBulk Quaternion::cross(const Quaternion& b) const noexcept { return {.xy = (b.xz * yz - b.yz * xz), .xz = (b.yz * xy - b.xy * yz), .yz = (b.xy * xz - b.xz * xy)}; }
    constexpr BivectorWeight Quaternion::cross(const ProjectiveTranslator& b) const noexcept { return {.wx = (b.wy * xy + b.wz * xz), .wy = (b.wz * yz - b.wx * xy), .wz = (-b.wx * xz - b.wy * yz)}; }
    constexpr BivectorWeight Quaternion::cross(const Translator& b) const noexcept { return {.wx = (b.wy * xy + b.wz * xz), .wy = (b.wz * yz - b.wx * xy), .wz = (-b.wx * xz - b.wy * yz)}; }
    constexpr Vector Quaternion::cross(const Vector& b) const noexcept { return {.x = (b.y * xy + b.z * xz), .y = (b.z * yz - b.x * xy), .z = (-b.x * xz - b.y * yz)}; }
    constexpr Vector Quaternion::cross(const Point& b) const noexcept { return {.x = (b.y * xy + b.z * xz), .y = (b.z * yz - b.x * xy), .z = (-b.x * xz - b.y * yz)}; }
    constexpr PlaneIdeal Quaternion::cross(const PlaneIdeal& b) const noexcept { return {.x = (b.y * xy + b.z * xz), .y = (b.z * yz - b.x * xy), .z = (-b.x * xz - b.y * yz)}; }
    constexpr BivectorBulk Quaternion::cross(const BivectorBulk& b) const noexcept { return {.xy = (b.xz * yz - b.yz * xz), .xz = (b.yz * xy - b.xy * yz), .yz = (b.xy * xz - b.xz * xy)}; }
    constexpr BivectorWeight Quaternion::cross(const BivectorWeight& b) const noexcept { return {.wx = (b.wy * xy + b.wz * xz), .wy = (b.wz * yz - b.wx * xy), .wz = (-b.wx * xz - b.wy * yz)}; }

    constexpr BivectorWeight ProjectiveTranslator::cross(const Motor& b) const noexcept { return {.wx = (-b.xy * wy - b.xz * wz), .wy = (b.xy * wx - b.yz * wz), .wz = (b.xz * wx + b.yz * wy)}; }
    constexpr Plane ProjectiveTranslator::cross(const Plane& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = (b.x * wx + b.y * wy + b.z * wz)}; }
    constexpr BivectorWeight ProjectiveTranslator::cross(const Bivector& b) const noexcept { return {.wx = (-b.xy * wy - b.xz * wz), .wy = (b.xy * wx - b.yz * wz), .wz = (b.xz * wx + b.yz * wy)}; }
    constexpr Vector ProjectiveTranslator::cross(const ProjectivePoint& b) const noexcept { return {.x = -b.w * wx, .y = -b.w * wy, .z = -b.w * wz}; }
    constexpr BivectorWeight ProjectiveTranslator::cross(const Quaternion& b) const noexcept { return {.wx = (-b.xy * wy - b.xz * wz), .wy = (b.xy * wx - b.yz * wz), .wz = (b.xz * wx + b.yz * wy)}; }
    constexpr Vector ProjectiveTranslator::cross(const Point& b) const noexcept { return {.x = -wx, .y = -wy, .z = -wz}; }
    constexpr Plane ProjectiveTranslator::cross(const PlaneIdeal& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = (b.x * wx + b.y * wy + b.z * wz)}; }
    constexpr BivectorWeight ProjectiveTranslator::cross(const BivectorBulk& b) const noexcept { return {.wx = (-b.xy * wy - b.xz * wz), .wy = (b.xy * wx - b.yz * wz), .wz = (b.xz * wx + b.yz * wy)}; }
    constexpr Vector ProjectiveTranslator::cross(const PointCenter& b) const noexcept { return {.x = -wx, .y = -wy, .z = -wz}; }

    constexpr BivectorWeight Translator::cross(const Motor& b) const noexcept { return {.wx = (-b.xy * wy - b.xz * wz), .wy = (b.xy * wx - b.yz * wz), .wz = (b.xz * wx + b.yz * wy)}; }
    constexpr Plane Translator::cross(const Plane& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = (b.x * wx + b.y * wy + b.z * wz)}; }
    constexpr BivectorWeight Translator::cross(const Bivector& b) const noexcept { return {.wx = (-b.xy * wy - b.xz * wz), .wy = (b.xy * wx - b.yz * wz), .wz = (b.xz * wx + b.yz * wy)}; }
    constexpr Vector Translator::cross(const ProjectivePoint& b) const noexcept { return {.x = -b.w * wx, .y = -b.w * wy, .z = -b.w * wz}; }
    constexpr BivectorWeight Translator::cross(const Quaternion& b) const noexcept { return {.wx = (-b.xy * wy - b.xz * wz), .wy = (b.xy * wx - b.yz * wz), .wz = (b.xz * wx + b.yz * wy)}; }
    constexpr Vector Translator::cross(const Point& b) const noexcept { return {.x = -wx, .y = -wy, .z = -wz}; }
    constexpr Plane Translator::cross(const PlaneIdeal& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = (b.x * wx + b.y * wy + b.z * wz)}; }
    constexpr BivectorWeight Translator::cross(const BivectorBulk& b) const noexcept { return {.wx = (-b.xy * wy - b.xz * wz), .wy = (b.xy * wx - b.yz * wz), .wz = (b.xz * wx + b.yz * wy)}; }
    constexpr Vector Translator::cross(const PointCenter& b) const noexcept { return {.x = -wx, .y = -wy, .z = -wz}; }

    constexpr Vector Vector::cross(const Motor& b) const noexcept { return {.x = (-b.xy * y - b.xz * z), .y = (b.xy * x - b.yz * z), .z = (b.xz * x + b.yz * y)}; }
    constexpr PseudoScalar Vector::cross(const Plane& b) const noexcept { return {.i = (-b.x * x - b.y * y - b.z * z)}; }
    constexpr Vector Vector::cross(const Bivector& b) const noexcept { return {.x = (-b.xy * y - b.xz * z), .y = (b.xy * x - b.yz * z), .z = (b.xz * x + b.yz * y)}; }
    constexpr BivectorWeight Vector::cross(const ProjectivePoint& b) const noexcept { return {.wx = b.w * x, .wy = b.w * y, .wz = b.w * z}; }
    constexpr Vector Vector::cross(const Quaternion& b) const noexcept { return {.x = (-b.xy * y - b.xz * z), .y = (b.xy * x - b.yz * z), .z = (b.xz * x + b.yz * y)}; }
    constexpr BivectorWeight Vector::cross(const Point& b) const noexcept { return {.wx = x, .wy = y, .wz = z}; }
    constexpr PseudoScalar Vector::cross(const PlaneIdeal& b) const noexcept { return {.i = (-b.x * x - b.y * y - b.z * z)}; }
    constexpr Vector Vector::cross(const BivectorBulk& b) const noexcept { return {.x = (-b.xy * y - b.xz * z), .y = (b.xy * x - b.yz * z), .z = (b.xz * x + b.yz * y)}; }
    constexpr BivectorWeight Vector::cross(const PointCenter& b) const noexcept { return {.wx = x, .wy = y, .wz = z}; }

    constexpr Multivector Point::cross(const Motor& b) const noexcept { return {.s = 0.0, .w = b.i, .x = 0.0, .y = 0.0, .z = 0.0, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = (-b.wz - b.xz * x - b.yz * y), .wxz = (b.wy + b.xy * x - b.yz * z), .wyz = (-b.wx + b.xy * y + b.xz * z), .xyz = 0.0, .i = 0.0}; }
    constexpr PseudoScalar Point::cross(const Plane& b) const noexcept { return {.i = (-b.w - b.x * x - b.y * y - b.z * z)}; }
    constexpr Vector Point::cross(const Bivector& b) const noexcept { return {.x = (b.wx - b.xy * y - b.xz * z), .y = (b.wy + b.xy * x - b.yz * z), .z = (b.wz + b.xz * x + b.yz * y)}; }
    constexpr BivectorWeight Point::cross(const ProjectivePoint& b) const noexcept { return {.wx = (-b.x + b.w * x), .wy = (-b.y + b.w * y), .wz = (-b.z + b.w * z)}; }
    constexpr Vector Point::cross(const Quaternion& b) const noexcept { return {.x = (-b.xy * y - b.xz * z), .y = (b.xy * x - b.yz * z), .z = (b.xz * x + b.yz * y)}; }
    constexpr Vector Point::cross(const ProjectiveTranslator& b) const noexcept { return {.x = b.wx, .y = b.wy, .z = b.wz}; }
    constexpr Vector Point::cross(const Translator& b) const noexcept { return {.x = b.wx, .y = b.wy, .z = b.wz}; }
    constexpr BivectorWeight Point::cross(const Vector& b) const noexcept { return {.wx = -b.x, .wy = -b.y, .wz = -b.z}; }
    constexpr BivectorWeight Point::cross(const Point& b) const noexcept { return {.wx = (x - b.x), .wy = (y - b.y), .wz = (z - b.z)}; }
    constexpr PseudoScalar Point::cross(const PlaneIdeal& b) const noexcept { return {.i = (-b.x * x - b.y * y - b.z * z)}; }
    constexpr Vector Point::cross(const BivectorBulk& b) const noexcept { return {.x = (-b.xy * y - b.xz * z), .y = (b.xy * x - b.yz * z), .z = (b.xz * x + b.yz * y)}; }
    constexpr Vector Point::cross(const BivectorWeight& b) const noexcept { return {.x = b.wx, .y = b.wy, .z = b.wz}; }
    constexpr Plane Point::cross(const PseudoScalar& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = b.i}; }
    constexpr BivectorWeight Point::cross(const PointCenter& b) const noexcept { return {.wx = x, .wy = y, .wz = z}; }

    constexpr Multivector PlaneIdeal::cross(const Motor& b) const noexcept { return {.s = 0.0, .w = (-b.wx * x - b.wy * y - b.wz * z), .x = (-b.xy * y - b.xz * z), .y = (b.xy * x - b.yz * z), .z = (b.xz * x + b.yz * y), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = -b.i * z, .wxz = b.i * y, .wyz = -b.i * x, .xyz = 0.0, .i = 0.0}; }
    constexpr Bivector PlaneIdeal::cross(const Plane& b) const noexcept { return {.wx = -b.w * x, .wy = -b.w * y, .wz = -b.w * z, .xy = (b.y * x - b.x * y), .xz = (b.z * x - b.x * z), .yz = (b.z * y - b.y * z)}; }
    constexpr Plane PlaneIdeal::cross(const Bivector& b) const noexcept { return {.x = (-b.xy * y - b.xz * z), .y = (b.xy * x - b.yz * z), .z = (b.xz * x + b.yz * y), .w = (-b.wx * x - b.wy * y - b.wz * z)}; }
    constexpr PseudoScalar PlaneIdeal::cross(const ProjectivePoint& b) const noexcept { return {.i = (b.x * x + b.y * y + b.z * z)}; }
    constexpr PlaneIdeal PlaneIdeal::cross(const Quaternion& b) const noexcept { return {.x = (-b.xy * y - b.xz * z), .y = (b.xy * x - b.yz * z), .z = (b.xz * x + b.yz * y)}; }
    constexpr Plane PlaneIdeal::cross(const ProjectiveTranslator& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = (-b.wx * x - b.wy * y - b.wz * z)}; }
    constexpr Plane PlaneIdeal::cross(const Translator& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = (-b.wx * x - b.wy * y - b.wz * z)}; }
    constexpr PseudoScalar PlaneIdeal::cross(const Vector& b) const noexcept { return {.i = (b.x * x + b.y * y + b.z * z)}; }
    constexpr PseudoScalar PlaneIdeal::cross(const Point& b) const noexcept { return {.i = (b.x * x + b.y * y + b.z * z)}; }
    constexpr BivectorBulk PlaneIdeal::cross(const PlaneIdeal& b) const noexcept { return {.xy = (b.y * x - b.x * y), .xz = (b.z * x - b.x * z), .yz = (b.z * y - b.y * z)}; }
    constexpr PlaneIdeal PlaneIdeal::cross(const BivectorBulk& b) const noexcept { return {.x = (-b.xy * y - b.xz * z), .y = (b.xy * x - b.yz * z), .z = (b.xz * x + b.yz * y)}; }
    constexpr Plane PlaneIdeal::cross(const BivectorWeight& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = (-b.wx * x - b.wy * y - b.wz * z)}; }
    constexpr Vector PlaneIdeal::cross(const PseudoScalar& b) const noexcept { return {.x = b.i * x, .y = b.i * y, .z = b.i * z}; }

    constexpr Bivector BivectorBulk::cross(const Motor& b) const noexcept { return {.wx = (b.wy * xy + b.wz * xz), .wy = (b.wz * yz - b.wx * xy), .wz = (-b.wx * xz - b.wy * yz), .xy = (b.xz * yz - b.yz * xz), .xz = (b.yz * xy - b.xy * yz), .yz = (b.xy * xz - b.xz * xy)}; }
    constexpr PlaneIdeal BivectorBulk::cross(const Plane& b) const noexcept { return {.x = (b.y * xy + b.z * xz), .y = (b.z * yz - b.x * xy), .z = (-b.x * xz - b.y * yz)}; }
    constexpr Bivector BivectorBulk::cross(const Bivector& b) const noexcept { return {.wx = (b.wy * xy + b.wz * xz), .wy = (b.wz * yz - b.wx * xy), .wz = (-b.wx * xz - b.wy * yz), .xy = (b.xz * yz - b.yz * xz), .xz = (b.yz * xy - b.xy * yz), .yz = (b.xy * xz - b.xz * xy)}; }
    constexpr Vector BivectorBulk::cross(const ProjectivePoint& b) const noexcept { return {.x = (b.y * xy + b.z * xz), .y = (b.z * yz - b.x * xy), .z = (-b.x * xz - b.y * yz)}; }
    constexpr BivectorBulk BivectorBulk::cross(const Quaternion& b) const noexcept { return {.xy = (b.xz * yz - b.yz * xz), .xz = (b.yz * xy - b.xy * yz), .yz = (b.xy * xz - b.xz * xy)}; }
    constexpr BivectorWeight BivectorBulk::cross(const ProjectiveTranslator& b) const noexcept { return {.wx = (b.wy * xy + b.wz * xz), .wy = (b.wz * yz - b.wx * xy), .wz = (-b.wx * xz - b.wy * yz)}; }
    constexpr BivectorWeight BivectorBulk::cross(const Translator& b) const noexcept { return {.wx = (b.wy * xy + b.wz * xz), .wy = (b.wz * yz - b.wx * xy), .wz = (-b.wx * xz - b.wy * yz)}; }
    constexpr Vector BivectorBulk::cross(const Vector& b) const noexcept { return {.x = (b.y * xy + b.z * xz), .y = (b.z * yz - b.x * xy), .z = (-b.x * xz - b.y * yz)}; }
    constexpr Vector BivectorBulk::cross(const Point& b) const noexcept { return {.x = (b.y * xy + b.z * xz), .y = (b.z * yz - b.x * xy), .z = (-b.x * xz - b.y * yz)}; }
    constexpr PlaneIdeal BivectorBulk::cross(const PlaneIdeal& b) const noexcept { return {.x = (b.y * xy + b.z * xz), .y = (b.z * yz - b.x * xy), .z = (-b.x * xz - b.y * yz)}; }
    constexpr BivectorBulk BivectorBulk::cross(const BivectorBulk& b) const noexcept { return {.xy = (b.xz * yz - b.yz * xz), .xz = (b.yz * xy - b.xy * yz), .yz = (b.xy * xz - b.xz * xy)}; }
    constexpr BivectorWeight BivectorBulk::cross(const BivectorWeight& b) const noexcept { return {.wx = (b.wy * xy + b.wz * xz), .wy = (b.wz * yz - b.wx * xy), .wz = (-b.wx * xz - b.wy * yz)}; }

    constexpr BivectorWeight BivectorWeight::cross(const Motor& b) const noexcept { return {.wx = (-b.xy * wy - b.xz * wz), .wy = (b.xy * wx - b.yz * wz), .wz = (b.xz * wx + b.yz * wy)}; }
    constexpr Plane BivectorWeight::cross(const Plane& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = (b.x * wx + b.y * wy + b.z * wz)}; }
    constexpr BivectorWeight BivectorWeight::cross(const Bivector& b) const noexcept { return {.wx = (-b.xy * wy - b.xz * wz), .wy = (b.xy * wx - b.yz * wz), .wz = (b.xz * wx + b.yz * wy)}; }
    constexpr Vector BivectorWeight::cross(const ProjectivePoint& b) const noexcept { return {.x = -b.w * wx, .y = -b.w * wy, .z = -b.w * wz}; }
    constexpr BivectorWeight BivectorWeight::cross(const Quaternion& b) const noexcept { return {.wx = (-b.xy * wy - b.xz * wz), .wy = (b.xy * wx - b.yz * wz), .wz = (b.xz * wx + b.yz * wy)}; }
    constexpr Vector BivectorWeight::cross(const Point& b) const noexcept { return {.x = -wx, .y = -wy, .z = -wz}; }
    constexpr Plane BivectorWeight::cross(const PlaneIdeal& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = (b.x * wx + b.y * wy + b.z * wz)}; }
    constexpr BivectorWeight BivectorWeight::cross(const BivectorBulk& b) const noexcept { return {.wx = (-b.xy * wy - b.xz * wz), .wy = (b.xy * wx - b.yz * wz), .wz = (b.xz * wx + b.yz * wy)}; }
    constexpr Vector BivectorWeight::cross(const PointCenter& b) const noexcept { return {.x = -wx, .y = -wy, .z = -wz}; }

    constexpr Vector PseudoScalar::cross(const Plane& b) const noexcept { return {.x = -b.x * i, .y = -b.y * i, .z = -b.z * i}; }
    constexpr Plane PseudoScalar::cross(const ProjectivePoint& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = -b.w * i}; }
    constexpr Plane PseudoScalar::cross(const Point& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = -i}; }
    constexpr Vector PseudoScalar::cross(const PlaneIdeal& b) const noexcept { return {.x = -b.x * i, .y = -b.y * i, .z = -b.z * i}; }
    constexpr Plane PseudoScalar::cross(const PointCenter& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = -i}; }

    constexpr Multivector PointCenter::cross(const Motor& b) const noexcept { return {.s = 0.0, .w = b.i, .x = 0.0, .y = 0.0, .z = 0.0, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = -b.wz, .wxz = b.wy, .wyz = -b.wx, .xyz = 0.0, .i = 0.0}; }
    constexpr PseudoScalar PointCenter::cross(const Plane& b) const noexcept { return {.i = -b.w}; }
    constexpr Vector PointCenter::cross(const Bivector& b) const noexcept { return {.x = b.wx, .y = b.wy, .z = b.wz}; }
    constexpr BivectorWeight PointCenter::cross(const ProjectivePoint& b) const noexcept { return {.wx = -b.x, .wy = -b.y, .wz = -b.z}; }
    constexpr Vector PointCenter::cross(const ProjectiveTranslator& b) const noexcept { return {.x = b.wx, .y = b.wy, .z = b.wz}; }
    constexpr Vector PointCenter::cross(const Translator& b) const noexcept { return {.x = b.wx, .y = b.wy, .z = b.wz}; }
    constexpr BivectorWeight PointCenter::cross(const Vector& b) const noexcept { return {.wx = -b.x, .wy = -b.y, .wz = -b.z}; }
    constexpr BivectorWeight PointCenter::cross(const Point& b) const noexcept { return {.wx = -b.x, .wy = -b.y, .wz = -b.z}; }
    constexpr Vector PointCenter::cross(const BivectorWeight& b) const noexcept { return {.x = b.wx, .y = b.wy, .z = b.wz}; }
    constexpr Plane PointCenter::cross(const PseudoScalar& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = b.i}; }

}

// pga3d.h

// generated by com.github.kright.pga3d.codegen.cpp.Pga3dCodeGenCpp

// Edge.h

namespace pga3dphysics {
    using pga3d::Point;
    using pga3d::Vector;
    using pga3d::Bivector;

    struct Edge {
        Point a = {};
        Point b = {};

        [[nodiscard]] constexpr Point center() const noexcept {
            return Point::mid(a, b);
        }

        [[nodiscard]] constexpr Vector ab() const noexcept {
            return b - a;
        }

        [[nodiscard]] constexpr Bivector line() const noexcept {
            return a.antiWedge(b);
        }

        [[nodiscard]] constexpr Point interpolatedPoint(const double t) const noexcept {
          return Point::interpolate(a, b, t);
        }

        [[nodiscard]] constexpr Edge reversed() const noexcept {
            return {b, a};
        }

        constexpr void reverse() noexcept {
            *this = reversed();
        }

        [[nodiscard]] double magnitude() const noexcept {
            return ab().norm();
        }

        [[nodiscard]] constexpr double magnitudeSquare() const noexcept {
            return ab().normSquare();
        }

    };
}

// Triangle.h

namespace pga3dphysics {

    using pga3d::Point;
    using pga3d::Vector;
    using pga3d::Plane;

    struct Triangle {
        Point a = {};
        Point b = {};
        Point c = {};

        [[nodiscard]] constexpr Vector ab() const noexcept { return b - a; }
        [[nodiscard]] constexpr Vector ac() const noexcept { return c - a; }
        [[nodiscard]] constexpr Vector bc() const noexcept { return c - b; }

        [[nodiscard]] constexpr Point center() const noexcept {
            return Point::mid(a, b, c);
        }

        [[nodiscard]] constexpr Plane plane() const noexcept {
            return a.antiWedge(b).antiWedge(c);
        }

        [[nodiscard]] double perimeter() const noexcept {
            return ab().norm() + ac().norm() + bc().norm();
        }

        [[nodiscard]] double area() const noexcept {
            return 0.5 * ab().antiWedge(ac()).norm();
        }
    };
}

// Cylinder.h

namespace pga3dphysics {
    using pga3d::Point;
    using pga3d::Vector;
    using pga3d::Bivector;

    struct Cylinder {
        Point a = {};
        Point b = {};
        double r = {0.0};

        [[nodiscard]] constexpr Point center() const noexcept {
            return Point::mid(a, b);
        }

        [[nodiscard]] constexpr Vector ab() const noexcept {
            return b - a;
        }

        [[nodiscard]] constexpr Bivector line() const noexcept {
            return a.antiWedge(b);
        }
    };
}

// Sphere.h

namespace pga3dphysics {
    using pga3d::Point;

    struct Sphere {
        Point center = {};
        double radius = 0.0;
    };
}

// AABB.h

namespace pga3dphysics {
    using pga3d::Point;
    using pga3d::Vector;

    struct AABB {
        Point min = {};
        Point max = {};

        [[nodiscard]] constexpr Vector size() const noexcept {
            return max - min;
        }

        [[nodiscard]] constexpr Vector halfSize() const noexcept {
            return size() * 0.5;
        }

        [[nodiscard]] constexpr double volume() const noexcept {
            const Vector s = size();
            return s.x * s.y * s.z;
        }

        [[nodiscard]] constexpr double surfaceArea() const noexcept {
            const Vector s = size();
            return 2.0 * (s.x * s.y + s.x * s.z + s.y * s.z);
        }

        [[nodiscard]] constexpr Point center() const noexcept {
            return Point::mid(min, max);
        }

        [[nodiscard]] constexpr Point clamp(const Point& point) const noexcept {
            return point.clamp(min, max);
        }

        [[nodiscard]] constexpr double distanceTo(const Point& point) const noexcept {
            const Point clamped = clamp(point);
            return clamped.distanceTo(point);
        }

        [[nodiscard]] constexpr bool contains(const Point& point) const noexcept {
            return point.x >= min.x && point.x <= max.x &&
                   point.y >= min.y && point.y <= max.y &&
                   point.z >= min.z && point.z <= max.z;
        }

        [[nodiscard]] constexpr bool contains(const AABB& aabb) const noexcept {
            return contains(aabb.min) && contains(aabb.max);
        }

        [[nodiscard]] AABB expanded(const Vector& eps) const noexcept {
            return {
                .min = min - eps,
                .max = max + eps
            };
        }

        [[nodiscard]] AABB expanded(const double eps) const noexcept {
            return expanded(Vector{eps, eps, eps});
        }

        constexpr void expand(const Vector& eps) noexcept {
            *this = expanded(eps);
        }

        constexpr void expand(const double eps) noexcept {
            *this = expanded(eps);
        }

        [[nodiscard]] constexpr AABB merged(const AABB& other) const noexcept {
            return {
                .min = min.min(other.min),
                .max = max.max(other.max),
            };
        }

        [[nodiscard]] constexpr AABB merged(const Point& p) const noexcept {
            return {
                .min = min.min(p),
                .max = max.max(p),
            };
        }

        constexpr void merge(const AABB& other) noexcept {
            *this = merged(other);
        }

        constexpr void merge(const Point& p) noexcept {
            *this = merged(p);
        }
    };
}

// Forque.h

namespace pga3dphysics {
    using pga3d::Vector;
    using pga3d::Point;
    using pga3d::Bivector;
    using pga3d::BivectorWeight;

    struct Forque {
        [[nodiscard]] static constexpr Bivector force(const Point& point, const Vector& force) noexcept{
            return point.antiWedge(force);
        }

        [[nodiscard]] static constexpr Bivector torque(const Vector &torque) noexcept {
            return Bivector{.wx = torque.x, .wy = torque.y, .wz = torque.z, .xy = 0.0, .xz = 0.0, .yz = 0.0};
        }

        [[nodiscard]] static constexpr Vector extractLinearForce(const Bivector &forque) noexcept {
            const Bivector fd = forque.dual();
            return {.x = fd.wx, .y = fd.wy, .z = fd.wz};
        }

        [[nodiscard]] static constexpr Point getCenter(const Bivector &forque) noexcept {
            const Vector v = extractLinearForce(forque);
            const double vNormSquare = v.normSquare();

            if (vNormSquare > 1e-100) {
                const Vector w{.x = forque.wx, .y = forque.wy, .z = forque.wz};
                const BivectorWeight result = (v.dual().cross(w.dual())).dual() / vNormSquare;
                return Point{result.wx, result.wy, result.wz};
            } else {
                // pure torque
                return Point{0.0, 0.0, 0.0};
            }
        }

        [[nodiscard]] static constexpr Vector extractTorqueAroundCenter(const Bivector &forque) noexcept {
            const Vector v = extractLinearForce(forque);
            const double vNormSquare = v.normSquare();
            if (vNormSquare > 1e-100) {
                const double inv = 1.0 / std::sqrt(vNormSquare);
                return {.x = forque.wx * v.x * inv, .y = forque.wy * v.y * inv, .z = forque.wz * v.z * inv};
            } else {
                return {.x = forque.wx, .y = forque.wy, .z = forque.wz};
            }
        }

        [[nodiscard]] static Bivector spring(const Point &current, const Point &another, double k, double springLength) noexcept {
            const Vector dir = another - current;
            const double dirDist = dir.norm();
            return force(current, dir * (k * (dirDist - springLength) / (dirDist + 1e-100)));
        }
    };
}

// Velocity.h

namespace pga3dphysics {
    using pga3d::Vector;
    using pga3d::Point;
    using pga3d::Bivector;
    using pga3d::BivectorWeight;
    using pga3d::BivectorBulk;

    class Velocity {
        [[nodiscard]] static constexpr BivectorWeight linear(const Vector& v) noexcept {
            return {.wx = v.x, .wy = v.y, .wz = v.z};
        }

        [[nodiscard]] static constexpr BivectorBulk angular(double xy, double xz, double yz) noexcept {
            return {.xy = xy, .xz = xz, .yz = yz};
        }

        [[nodiscard]] static constexpr Bivector angular(const BivectorBulk& w, const Point& rotationCenter) noexcept {
            return w - linear(pointLinearVelocity(rotationCenter, w));
        }

        [[nodiscard]] static constexpr Vector pointLinearVelocity(const Point& point, const Bivector& velocity) noexcept {
            return point.cross(velocity);
        }

        [[nodiscard]] static constexpr Vector pointLinearVelocity(const Point& point, const BivectorWeight& velocity) noexcept {
            return point.cross(velocity);
        }

        [[nodiscard]] static constexpr Vector pointLinearVelocity(const Point& point, const BivectorBulk& velocity) noexcept {
            return point.cross(velocity);
        }
    };
}

// InertiaLocal.h

namespace pga3dphysics {
    using pga3d::Bivector;

    struct InertiaLocal {
        double mass = 0.0;
        double mryz = 0.0;
        double mrxz = 0.0;
        double mrxy = 0.0;

        [[nodiscard]] constexpr Bivector operator()(const Bivector& velocity) const noexcept {
            return Bivector {
              .wx = velocity.yz * mryz,
              .wy = -velocity.xz * mrxz,
              .wz = velocity.xy * mrxy,
              .xy = velocity.wz * mass,
              .xz = -velocity.wy * mass,
              .yz = velocity.wx * mass,
            };
        }

        [[nodiscard]] constexpr Bivector invert(const Bivector& localInertia) const noexcept {
            const double massInv = 1.0 / mass;

            return Bivector {
              .wx = localInertia.yz * massInv,
              .wy = -localInertia.xz * massInv,
              .wz = localInertia.xy * massInv,
              .xy = localInertia.wz / mrxy,
              .xz = -localInertia.wy / mrxz,
              .yz = localInertia.wx / mryz,
            };
        }

        /** invert(localB.cross(apply(localB)) + localForque) */
        [[nodiscard]] constexpr Bivector getAcceleration(const Bivector& localB, const Bivector& localForque) const noexcept {
            return Bivector {
              .wx = localForque.yz / mass + localB.wy * localB.xy + localB.wz * localB.xz,
              .wy = -localForque.xz / mass + localB.wz * localB.yz - localB.wx * localB.xy,
              .wz = localForque.xy / mass - localB.wx * localB.xz - localB.wy * localB.yz,
              .xy = (localForque.wz + localB.xz * localB.yz * (mrxz - mryz)) / mrxy,
              .xz = (-localForque.wy + localB.xy * localB.yz * (mryz - mrxy)) / mrxz,
              .yz = (localForque.wx + localB.xy * localB.xz * (mrxy - mrxz)) / mryz,
            };
        }

        [[nodiscard]] constexpr double getKineticEnergy(const Bivector& velocity) const noexcept {
            return velocity.antiWedge(operator()(velocity)) * 0.5;
        }
    };
}

// InertiaLocalSphere.h

namespace pga3dphysics {
    using pga3d::Bivector;

    /**
     * Fully symmetrical tensor of inertia (for example, for cube or sphere).
     * It has no precession, and computations are simpler and faster
     *
     * @param mass - mass
     * @param mr2  - square of effective radius multiplied by mass
     */
    struct InertiaLocalSphere {
        double mass = 0.0;
        double mr2 = 0.0;

        [[nodiscard]] constexpr Bivector operator()(const Bivector& velocity) const noexcept {
            return Bivector {
                .wx = velocity.yz * mr2,
                .wy = -velocity.xz * mr2,
                .wz = velocity.xy * mr2,
                .xy = velocity.wz * mass,
                .xz = -velocity.wy * mass,
                .yz = velocity.wx * mass,
              };
        }

        [[nodiscard]] constexpr Bivector invert(const Bivector& localInertia) const noexcept {
            const double massInv = 1.0 / mass;
            const double mr2Inv = 1.0 / mr2;

            return Bivector {
                .wx = localInertia.yz * massInv,
                .wy = -localInertia.xz * massInv,
                .wz = localInertia.xy * massInv,
                .xy = localInertia.wz * mr2Inv,
                .xz = -localInertia.wy * mr2Inv,
                .yz = localInertia.wx * mr2Inv,
            };
        }

        /** invert(localB.cross(apply(localB)) + localForque) */
        [[nodiscard]] constexpr Bivector getAcceleration(const Bivector& localB, const Bivector& localForque) const noexcept {
            const double massInv = 1.0 / mass;
            const double mr2Inv = 1.0 / mr2;

            return {
                .wx = localForque.yz * massInv + localB.wy * localB.xy + localB.wz * localB.xz,
                .wy = -localForque.xz * massInv + localB.wz * localB.yz - localB.wx * localB.xy,
                .wz = localForque.xy * massInv - localB.wx * localB.xz - localB.wy * localB.yz,
                .xy = localForque.wz * mr2Inv,
                .xz = -localForque.wy * mr2Inv,
                .yz = localForque.wx * mr2Inv,
            };
        }

        [[nodiscard]] constexpr double getKineticEnergy(const Bivector& velocity) const noexcept {
            return velocity.antiWedge(operator()(velocity)) * 0.5;
        }
    };
}

// InertiaMovedLocal.h

namespace pga3dphysics {
    using pga3d::Motor;
    using pga3d::Translator;
    using pga3d::Quaternion;
    using pga3d::Bivector;
    using pga3d::Point;

    struct InertiaMovedLocal {
        Motor localToGlobal;
        InertiaLocal localInertia;

        [[nodiscard]] constexpr double mass() const noexcept {
            return localInertia.mass;
        }

        [[nodiscard]] constexpr Point centerOfMassPoint() const noexcept {
            return localToGlobal.sandwich(pga3d::PointCenter{}).toPointUnsafe();
        }

        [[nodiscard]] constexpr Bivector operator ()(const Bivector& globalB) const noexcept {
            const Bivector localB = localToGlobal.reverseSandwich(globalB);
            const Bivector localI = localInertia(localB);
            return localToGlobal.sandwich(localI);
        }

        [[nodiscard]] constexpr Bivector invert(const Bivector& globalI) const noexcept {
            const Bivector localI = localToGlobal.reverseSandwich(globalI);
            const Bivector localB = localInertia.invert(localI);
            return localToGlobal.sandwich(localB);
        }

        [[nodiscard]] constexpr Bivector getLocalAcceleration(const Bivector &globalVelocity,
                                                              const Bivector &globalForque) const noexcept {
            const Bivector localB = localToGlobal.reverseSandwich(globalVelocity);
            const Bivector localF = localToGlobal.reverseSandwich(globalForque);
            return localInertia.getAcceleration(localB, localF);
        }

        [[nodiscard]] constexpr Bivector getAcceleration(const Bivector &globalVelocity,
                                                         const Bivector &globalForque) const noexcept {
            const Bivector localA = getLocalAcceleration(globalVelocity, globalForque);
            return localToGlobal.sandwich(localA);
        }

        [[nodiscard]] constexpr double getKineticEnergy(const Bivector &globalVelocity) const noexcept {
            const Bivector localB = localToGlobal.reverseSandwich(globalVelocity);
            return localInertia.getKineticEnergy(localB);
        }

        [[nodiscard]] constexpr InertiaMovedLocal movedBy(const Motor& m) const noexcept {
            return {
                .localToGlobal = m.geometric(localToGlobal),
                .localInertia = localInertia,
            };
        }

        [[nodiscard]] constexpr InertiaMovedLocal movedBy(const Translator& m) const noexcept {
            return {
                .localToGlobal = m.geometric(localToGlobal),
                .localInertia = localInertia,
            };
        }

        [[nodiscard]] constexpr InertiaMovedLocal movedBy(const Quaternion& m) const noexcept {
            return {
                .localToGlobal = m.geometric(localToGlobal),
                .localInertia = localInertia,
            };
        }
    };
}

// InertiaSummable.h

namespace pga3dphysics {
    using pga3d::Point;
    using pga3d::ProjectivePoint;
    using pga3d::Motor;
    using pga3d::Translator;
    using pga3d::Quaternion;

    struct InertiaSummable {
        double ww = 0.0;
        double wx = 0.0;
        double wy = 0.0;
        double wz = 0.0;
        double xx = 0.0;
        double yy = 0.0;
        double zz = 0.0;
        double xy = 0.0;
        double yz = 0.0;
        double xz = 0.0;

        [[nodiscard]] constexpr double mass() const noexcept {
            return ww;
        }

        [[nodiscard]] constexpr Point centerOfMass() const noexcept {
            const double inv = 1.0 / mass();
            return {.x = wx * inv, .y = wy * inv, .z = wz * inv};
        }

        [[nodiscard]] constexpr ProjectivePoint centerOfMassProjective() const noexcept {
            return {.x = wx , .y = wy , .z = wz, .w = ww};
        }

        [[nodiscard]] constexpr double normSquare() const noexcept {
            return ww * ww + wx * wx + wy * wy + wz * wz + xx * xx + yy * yy + zz * zz + xy * xy + yz * yz + xz * xz;
        }

        [[nodiscard]] constexpr Bivector operator()(const Bivector& b) const noexcept {
            return {
                .wx = +(yy + zz) * b.yz + xy * b.xz - xz * b.xy - wz * b.wy + wy * b.wz,
                .wy = -xy * b.yz - (xx + zz) * b.xz - yz * b.xy - wx * b.wz + wz * b.wx,
                .wz = -xz * b.yz + yz * b.xz + (xx + yy) * b.xy + wx * b.wy - wy * b.wx,
                .xy = ww * b.wz + wx * b.xz + wy * b.yz,
                .xz = -ww * b.wy - wx * b.xy + wz * b.yz,
                .yz = ww * b.wx - wy * b.xy - wz * b.xz,
            };
        }

    private:
        [[nodiscard]] constexpr InertiaSummable movedByImpl(auto mapProjectivePoint) const noexcept {
            const ProjectivePoint cx = mapProjectivePoint(ProjectivePoint{xx, xy , xz, wx});
            const ProjectivePoint cy = mapProjectivePoint(ProjectivePoint{xy, yy, yz, wy});
            const ProjectivePoint cz = mapProjectivePoint(ProjectivePoint{xz, yz, zz, wz});
            const ProjectivePoint cw = mapProjectivePoint(ProjectivePoint{wx, wy, wz, ww});

            const ProjectivePoint rx = mapProjectivePoint(ProjectivePoint{cx.x, cy.x, cz.x, cw.x});
            const ProjectivePoint ry = mapProjectivePoint(ProjectivePoint{cx.y, cy.y, cz.y, cw.y});
            const ProjectivePoint rz = mapProjectivePoint(ProjectivePoint{cx.z, cy.z, cz.z, cw.z});
            const ProjectivePoint rw = mapProjectivePoint(ProjectivePoint{cx.w, cy.w, cz.w, cw.w});

            return {
                .ww = rw.w,
                .wx = rw.x,
                .wy = rw.y,
                .wz = rw.z,
                .xx = rx.x,
                .yy = ry.y,
                .zz = rz.z,
                .xy = rx.y,
                .yz = ry.z,
                .xz = rx.z
            };
        }
    public:

        [[nodiscard]] constexpr InertiaSummable movedBy(const Motor& m) const noexcept {
            return movedByImpl([&](const ProjectivePoint& p) { return m.sandwich(p); });
        }

        [[nodiscard]] constexpr InertiaSummable movedBy(const Translator& m) const noexcept {
            return movedByImpl([&](const ProjectivePoint& p) { return m.sandwich(p); });
        }

        [[nodiscard]] constexpr InertiaSummable movedBy(const Quaternion& m) const noexcept {
            return movedByImpl([&](const ProjectivePoint& p) { return m.sandwich(p); });
        }

        [[nodiscard]] static constexpr InertiaSummable point(const Point& p, double mass) noexcept {
            // inertia of a mass in a point = symmetricProduct(p.toProjectivePoint, p * mass)
            return {
                .ww = mass,
                .wx = p.x * mass,
                .wy = p.y * mass,
                .wz = p.z * mass,
                .xx = p.x * p.x * mass,
                .yy = p.y * p.y * mass,
                .zz = p.z * p.z * mass,
                .xy = p.x * p.y * mass,
                .yz = p.y * p.z * mass,
                .xz = p.x * p.z * mass,
            };
        }

        [[nodiscard]] static constexpr InertiaSummable from(const InertiaLocalSphere& inertia) noexcept {
            return {
                .ww = inertia.mass,
                .wx = 0.0,
                .wy = 0.0,
                .wz = 0.0,
                .xx = inertia.mr2 * 0.5,
                .yy = inertia.mr2 * 0.5,
                .zz = inertia.mr2 * 0.5,
                .xy = 0.0,
                .yz = 0.0,
                .xz = 0.0,
            };
        }

        [[nodiscard]] static constexpr InertiaSummable from(const InertiaLocal& inertia) noexcept {
            const double mrxyz2 = (inertia.mrxy + inertia.mrxz + inertia.mryz) * 0.5;

            const double mrx2 = mrxyz2 - inertia.mryz;
            const double mry2 = mrxyz2 - inertia.mrxz;
            const double mrz2 = mrxyz2 - inertia.mrxy;

            return {
                .ww = inertia.mass,
                .wx = 0.0,
                .wy = 0.0,
                .wz = 0.0,
                .xx = mrx2,
                .yy = mry2,
                .zz = mrz2,
                .xy = 0.0,
                .yz = 0.0,
                .xz = 0.0
            };
        }

        [[nodiscard]] static constexpr InertiaSummable from(const InertiaMovedLocal& inertia) noexcept {
            return from(inertia.localInertia).movedBy(inertia.localToGlobal);
        }
    };

    [[nodiscard]] constexpr InertiaSummable operator+(const InertiaSummable& a, const InertiaSummable& b) noexcept {
        return {
            .ww = a.ww + b.ww,
            .wx = a.wx + b.wx,
            .wy = a.wy + b.wy,
            .wz = a.wz + b.wz,
            .xx = a.xx + b.xx,
            .yy = a.yy + b.yy,
            .zz = a.zz + b.zz,
            .xy = a.xy + b.xy,
            .yz = a.yz + b.yz,
            .xz = a.xz + b.xz
        };
    }

    [[nodiscard]] constexpr InertiaSummable& operator+=(InertiaSummable& a, const InertiaSummable& b) noexcept {
        a = a + b;
        return a;
    }

    [[nodiscard]] constexpr InertiaSummable operator-(const InertiaSummable& a, const InertiaSummable& b) noexcept {
        return {
            .ww = a.ww - b.ww,
            .wx = a.wx - b.wx,
            .wy = a.wy - b.wy,
            .wz = a.wz - b.wz,
            .xx = a.xx - b.xx,
            .yy = a.yy - b.yy,
            .zz = a.zz - b.zz,
            .xy = a.xy - b.xy,
            .yz = a.yz - b.yz,
            .xz = a.xz - b.xz
        };
    }

    [[nodiscard]] constexpr InertiaSummable& operator-=(InertiaSummable& a, const InertiaSummable& b) noexcept {
        a = a - b;
        return a;
    }

    [[nodiscard]] constexpr InertiaSummable operator*(const InertiaSummable& a, double mult) noexcept {
        return {
            .ww = a.ww * mult,
            .wx = a.wx * mult,
            .wy = a.wy * mult,
            .wz = a.wz * mult,
            .xx = a.xx * mult,
            .yy = a.yy * mult,
            .zz = a.zz * mult,
            .xy = a.xy * mult,
            .yz = a.yz * mult,
            .xz = a.xz * mult
        };
    }

    [[nodiscard]] constexpr InertiaSummable operator*(double mult, const InertiaSummable& a) noexcept {
        return a * mult;
    }

    [[nodiscard]] constexpr InertiaSummable& operator*=(InertiaSummable& a, double mult) noexcept {
        a = a * mult;
        return a;
    }
}

// Friction.h

namespace pga3dphysics {
    struct VelocityFriction {
        double linearK = 0.0;
        double quadraticK = 0.0;
        double maxForce = 0.0;

        [[nodiscard]] constexpr bool isZero() const noexcept {
            return maxForce == 0.0;
        }

        [[nodiscard]] constexpr double operator()(double velocity) const noexcept {
            const double sign = velocity > 0.0 ? 1.0 : -1.0;
            const double f = velocity * ( -linearK - velocity * quadraticK * sign);
            return std::clamp(f, -maxForce, maxForce);
        }

        [[nodiscard]] Vector operator()(const Vector& velocity) const noexcept {
            const Vector f = velocity * (-linearK - quadraticK * velocity.norm());
            return f.clamp(
                {-maxForce, -maxForce, -maxForce},
                {maxForce, maxForce, maxForce}
            );
        }

        [[nodiscard]] constexpr static VelocityFriction linear(const double k, const double maxForce) noexcept {
            return {k, 0.0, maxForce};
        }

        [[nodiscard]] constexpr static VelocityFriction quadratic(const double k2, const double maxForce) noexcept {
            return {0.0, k2, maxForce};
        }

        [[nodiscard]] constexpr static VelocityFriction constant(const double maxForce, const double minVelocity) noexcept {
            return {maxForce / minVelocity, 0.0, maxForce};
        }
    };

    struct PositionFriction {
        double linearK = 0.0;
        double maxDelta = 0.0;
        double boundPosition = 0.0;

        [[nodiscard]] constexpr double getMaxForce() const noexcept {
            return maxDelta * linearK;
        }

        constexpr void setMaxForce(const double maxForce, const double newMaxDelta) noexcept {
            linearK = maxForce / newMaxDelta;
            maxDelta = newMaxDelta;
        }

        [[nodiscard]] constexpr bool isZero() const noexcept {
            return linearK == 0.0;
        }

        [[nodiscard]] constexpr double operator()(const double position) const noexcept {
            return std::clamp(boundPosition - position, -maxDelta, maxDelta) * linearK;
        }

        constexpr void correctBoundPosition(const double position) noexcept {
            boundPosition = std::clamp(boundPosition, position - maxDelta, position + maxDelta);
        }

        [[nodiscard]] constexpr static PositionFriction create(const double maxForce, const double maxDetla) noexcept {
            return {
                .linearK = maxForce / maxDetla,
                .maxDelta = maxDetla,
                .boundPosition = 0.0
            };
        }
    };
}

// BodyState.h

namespace pga3dphysics {
    using pga3d::Motor;
    using pga3d::Bivector;

    struct BodyState {
        Motor motor;
        Bivector localB;

        static constexpr BodyState id() noexcept {
            return {
                .motor = Motor::id(),
                .localB = {},
            };
        }

        static constexpr BodyState zero() noexcept {
            return {
                .motor = {},
                .localB = {},
            };
        }

        [[nodiscard]] constexpr BodyState madd(const BodyState& other, double t) const noexcept {
            return {
                .motor = motor.madd(other.motor, t),
                .localB = localB.madd(other.localB, t),
            };
        }

        [[nodiscard]] BodyState renormalized() const noexcept {
            return {
                .motor = motor.renormalized(),
                .localB = localB,
            };
        }
    };

    [[nodiscard]] constexpr BodyState operator+(const BodyState& a, const BodyState& b) noexcept {
        return {
            .motor = a.motor + b.motor,
            .localB = a.localB + b.localB,
        };
    }

    constexpr BodyState& operator+=(BodyState& a, const BodyState& b) noexcept {
        a = a + b;
        return a;
    }

    [[nodiscard]] constexpr BodyState operator-(const BodyState& a, const BodyState& b) noexcept {
        return {
            .motor = a.motor - b.motor,
            .localB = a.localB - b.localB,
        };
    }

    constexpr BodyState& operator-=(BodyState& a, const BodyState& b) noexcept {
        a = a - b;
        return a;
    }

    [[nodiscard]] constexpr BodyState operator*(const BodyState& a, double mult) noexcept {
        return {
            .motor = a.motor * mult,
            .localB = a.localB * mult,
        };
    }

    constexpr BodyState& operator*=(BodyState& a, double mult) noexcept {
        a = a * mult;
        return a;
    }

    [[nodiscard]] constexpr BodyState operator*(double mult, const BodyState& a) noexcept {
        return a * mult;
    }
}

// PhysicsBody.h

namespace pga3dphysics {
    using pga3d::Bivector;
    using pga3d::Point;

    struct PhysicsBody {
        InertiaMovedLocal inertia;
        BodyState state;
        Bivector globalForqueAccumulator = {};

        [[nodiscard]] constexpr Bivector globalForque() const noexcept {
            return globalForqueAccumulator;
        }

        [[nodiscard]] constexpr Bivector localForque() const noexcept {
            return state.motor.reverseSandwich(globalForque());
        }

        constexpr void resetForqueAccum() noexcept {
            globalForqueAccumulator = {};
        }

        constexpr void addGlobalForque(const Bivector& globalForque) noexcept {
            globalForqueAccumulator += globalForque;
        }

        /** Otherwise it's too easy to forget adding paired force */
        constexpr void addGlobalForquePaired(const Bivector &globalForque, PhysicsBody &other) noexcept {
            globalForqueAccumulator += globalForque;
            other.globalForqueAccumulator -= globalForque;
        }

        [[nodiscard]] constexpr BodyState stateDerivative() const noexcept {
            return BodyState{
                .motor = state.motor.geometric(state.localB) * -0.5,
                .localB = inertia.getAcceleration(state.localB, localForque())
            };
        }

        [[nodiscard]] constexpr double kineticEnergy() const noexcept {
            return state.localB.antiWedge(inertia(state.localB)) * 0.5;
        }

        [[nodiscard]] constexpr Bivector impulse() const noexcept {
            return state.motor.sandwich(inertia(state.localB));
        }

        [[nodiscard]] constexpr Point localPosToGlobal(const Point& localPos) const noexcept {
            return state.motor.sandwich(localPos).toPointUnsafe();
        }

        [[nodiscard]] constexpr Point globalCenter() const noexcept {
            return localPosToGlobal(inertia.centerOfMassPoint());
        }

        [[nodiscard]] constexpr Vector getGlobalVelocityForLocalPos(const Point& localPos) const noexcept {
            return state.motor.sandwich(localPos.cross(state.localB));
        }
    };
}

// PhysicsSolverRK4.h

namespace pga3dphysics {
     class PhysicsSolverRK4 {
     private:
          std::vector<BodyState> initialStates;
          std::vector<BodyState> d1;
          std::vector<BodyState> d2;
          std::vector<BodyState> d3;
          std::vector<BodyState> d4;

          void updateSizes(size_t newSize) {
               initialStates.resize(newSize);
               d1.resize(newSize);
               d2.resize(newSize);
               d3.resize(newSize);
               d4.resize(newSize);
          }

          void resetForqueAccumulators(std::span<PhysicsBody>& dynamicBodies) {
               for (PhysicsBody &body: dynamicBodies) {
                    body.resetForqueAccum();
               }
          }

          void computeDerivativeInto(std::vector<BodyState> &result, const std::span<PhysicsBody>& dynamicBodies) {
               const size_t size = dynamicBodies.size();
               for (size_t pos = 0; pos < size; ++pos) {
                    result[pos] = dynamicBodies[pos].stateDerivative();
               }
          }

          void setFinalState(std::span<PhysicsBody>& dynamicBodies, const double dt) {
               const size_t size = dynamicBodies.size();
               for (size_t pos = 0; pos < size; ++pos) {
                    const BodyState dState =
                         d1[pos] * (dt * (1.0 / 6.0))
                        + d2[pos] * (dt * (1.0 / 3.0))
                        + d3[pos] * (dt * (1.0 / 3.0))
                        + d4[pos] * (dt * (1.0 / 6.0));

                    dynamicBodies[pos].state = (initialStates[pos] + dState).renormalized();
               }
          }

          void setNewState(std::span<PhysicsBody>& dynamicBodies, const double dt, const std::vector<BodyState> &derivative) {
               const size_t size = dynamicBodies.size();
               for (size_t pos = 0; pos < size; ++pos) {
                    dynamicBodies[pos].state = initialStates[pos].madd(derivative[pos], dt).renormalized();
               }
          }

          void setInitialState(const std::span<PhysicsBody>& dynamicBodies) {
               const size_t size = dynamicBodies.size();
               for (size_t pos = 0; pos < size; ++pos) {
                    initialStates[pos] = dynamicBodies[pos].state;
               }
          }

     public:
          void doStepRk4(std::span<PhysicsBody> dynamicBodies, const double dt, auto addForquesToBodies) {
               updateSizes(dynamicBodies.size());
               setInitialState(dynamicBodies);

               resetForqueAccumulators(dynamicBodies);
               addForquesToBodies(0.0);
               computeDerivativeInto(d1, dynamicBodies);
               
               setNewState(dynamicBodies, 0.5 * dt, d1);
               resetForqueAccumulators(dynamicBodies);
               addForquesToBodies(0.5);
               computeDerivativeInto(d2, dynamicBodies);

               setNewState(dynamicBodies, 0.5 * dt, d2);
               resetForqueAccumulators(dynamicBodies);
               addForquesToBodies(0.5);
               computeDerivativeInto(d3, dynamicBodies);

               setNewState(dynamicBodies, dt, d3);
               resetForqueAccumulators(dynamicBodies);
               addForquesToBodies(1.0);
               computeDerivativeInto(d4, dynamicBodies);

               setFinalState(dynamicBodies, dt);
          }
     };
}