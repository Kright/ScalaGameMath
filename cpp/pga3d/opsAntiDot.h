// Copyright (c) 2025 Igor Slobodskov
// SPDX-License-Identifier: MIT

#pragma once

#include "types.h"

// generated by com.github.kright.pga3d.codegen.cpp.ops.AntiDotOpGenerator

namespace pga3d {
    constexpr Multivector Multivector::antiDot(const Multivector& b) const noexcept { return {
        .s = (b.i * s + b.s * i),
        .w = (b.i * w + b.w * i),
        .x = (b.i * x + b.wyz * s + b.x * i - b.s * wyz),
        .y = (b.i * y + b.s * wxz + b.y * i - b.wxz * s),
        .z = (b.i * z + b.wxy * s + b.z * i - b.s * wxy),
        .wx = (b.i * wx + b.wx * i - b.w * wyz - b.wyz * w),
        .wy = (b.i * wy + b.w * wxz + b.wxz * w + b.wy * i),
        .wz = (b.i * wz + b.wz * i - b.w * wxy - b.wxy * w),
        .xy = (b.i * xy + b.wxz * x + b.wyz * y + b.x * wxz + b.xy * i + b.y * wyz - b.s * wz - b.wz * s),
        .xz = (b.i * xz + b.s * wy + b.wy * s + b.wyz * z + b.xz * i + b.z * wyz - b.wxy * x - b.x * wxy),
        .yz = (b.i * yz + b.yz * i - b.s * wx - b.wx * s - b.wxy * y - b.wxz * z - b.y * wxy - b.z * wxz),
        .wxy = (b.i * wxy + b.w * wz + b.wxy * i + b.wxz * wx + b.wyz * wy + b.wz * w - b.wx * wxz - b.wy * wyz),
        .wxz = (b.i * wxz + b.wx * wxy + b.wxz * i + b.wyz * wz - b.w * wy - b.wxy * wx - b.wy * w - b.wz * wyz),
        .wyz = (b.i * wyz + b.w * wx + b.wx * w + b.wy * wxy + b.wyz * i + b.wz * wxz - b.wxy * wy - b.wxz * wz),
        .xyz = (b.i * xyz + b.s * w + b.wx * x + b.wy * y + b.wz * z + b.x * wx + b.xy * wxy + b.xyz * i + b.xz * wxz + b.y * wy + b.yz * wyz + b.z * wz - b.w * s - b.wxy * xy - b.wxz * xz - b.wyz * yz),
        .i = (b.i * i + b.wxy * wxy + b.wxz * wxz + b.wyz * wyz - b.w * w - b.wx * wx - b.wy * wy - b.wz * wz)
    }; }

    constexpr Motor Motor::antiDot(const Motor& b) const noexcept { return {
        .s = (b.i * s + b.s * i),
        .wx = (b.i * wx + b.wx * i),
        .wy = (b.i * wy + b.wy * i),
        .wz = (b.i * wz + b.wz * i),
        .xy = (b.i * xy + b.xy * i - b.s * wz - b.wz * s),
        .xz = (b.i * xz + b.s * wy + b.wy * s + b.xz * i),
        .yz = (b.i * yz + b.yz * i - b.s * wx - b.wx * s),
        .i = (b.i * i - b.wx * wx - b.wy * wy - b.wz * wz)
    }; }
    constexpr Multivector Motor::antiDot(const Plane& b) const noexcept { return {
        .s = 0.0,
        .w = b.w * i,
        .x = b.x * i,
        .y = b.y * i,
        .z = b.z * i,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = b.w * wz,
        .wxz = -b.w * wy,
        .wyz = b.w * wx,
        .xyz = (b.x * wx + b.y * wy + b.z * wz - b.w * s),
        .i = 0.0
    }; }
    constexpr Motor Motor::antiDot(const Bivector& b) const noexcept { return {
        .s = 0.0,
        .wx = b.wx * i,
        .wy = b.wy * i,
        .wz = b.wz * i,
        .xy = (b.xy * i - b.wz * s),
        .xz = (b.wy * s + b.xz * i),
        .yz = (b.yz * i - b.wx * s),
        .i = (-b.wx * wx - b.wy * wy - b.wz * wz)
    }; }
    constexpr Multivector Motor::antiDot(const ProjectivePoint& b) const noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = -b.x * s,
        .y = -b.y * s,
        .z = -b.z * s,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (b.y * wx - b.x * wy - b.z * i),
        .wxz = (b.y * i + b.z * wx - b.x * wz),
        .wyz = (b.z * wy - b.x * i - b.y * wz),
        .xyz = (b.w * i + b.x * yz + b.z * xy - b.y * xz),
        .i = 0.0
    }; }
    constexpr Quaternion Motor::antiDot(const Quaternion& b) const noexcept { return {
        .s = b.s * i,
        .xy = (b.xy * i - b.s * wz),
        .xz = (b.s * wy + b.xz * i),
        .yz = (b.yz * i - b.s * wx)
    }; }
    constexpr Motor Motor::antiDot(const ProjectiveTranslator& b) const noexcept { return {
        .s = b.s * i,
        .wx = b.wx * i,
        .wy = b.wy * i,
        .wz = b.wz * i,
        .xy = (-b.s * wz - b.wz * s),
        .xz = (b.s * wy + b.wy * s),
        .yz = (-b.s * wx - b.wx * s),
        .i = (-b.wx * wx - b.wy * wy - b.wz * wz)
    }; }
    constexpr Motor Motor::antiDot(const Translator& b) const noexcept { return {
        .s = i,
        .wx = b.wx * i,
        .wy = b.wy * i,
        .wz = b.wz * i,
        .xy = (-wz - b.wz * s),
        .xz = (wy + b.wy * s),
        .yz = (-wx - b.wx * s),
        .i = (-b.wx * wx - b.wy * wy - b.wz * wz)
    }; }
    constexpr Multivector Motor::antiDot(const Vector& b) const noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = -b.x * s,
        .y = -b.y * s,
        .z = -b.z * s,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (b.y * wx - b.x * wy - b.z * i),
        .wxz = (b.y * i + b.z * wx - b.x * wz),
        .wyz = (b.z * wy - b.x * i - b.y * wz),
        .xyz = (b.x * yz + b.z * xy - b.y * xz),
        .i = 0.0
    }; }
    constexpr Multivector Motor::antiDot(const Point& b) const noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = -b.x * s,
        .y = -b.y * s,
        .z = -b.z * s,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (b.y * wx - b.x * wy - b.z * i),
        .wxz = (b.y * i + b.z * wx - b.x * wz),
        .wyz = (b.z * wy - b.x * i - b.y * wz),
        .xyz = (i + b.x * yz + b.z * xy - b.y * xz),
        .i = 0.0
    }; }
    constexpr Multivector Motor::antiDot(const PlaneIdeal& b) const noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = b.x * i,
        .y = b.y * i,
        .z = b.z * i,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = 0.0,
        .wxz = 0.0,
        .wyz = 0.0,
        .xyz = (b.x * wx + b.y * wy + b.z * wz),
        .i = 0.0
    }; }
    constexpr BivectorBulk Motor::antiDot(const BivectorBulk& b) const noexcept { return {
        .xy = b.xy * i,
        .xz = b.xz * i,
        .yz = b.yz * i
    }; }
    constexpr Motor Motor::antiDot(const BivectorWeight& b) const noexcept { return {
        .s = 0.0,
        .wx = b.wx * i,
        .wy = b.wy * i,
        .wz = b.wz * i,
        .xy = -b.wz * s,
        .xz = b.wy * s,
        .yz = -b.wx * s,
        .i = (-b.wx * wx - b.wy * wy - b.wz * wz)
    }; }
    constexpr Motor Motor::antiDot(const PseudoScalar& b) const noexcept { return {
        .s = b.i * s,
        .wx = b.i * wx,
        .wy = b.i * wy,
        .wz = b.i * wz,
        .xy = b.i * xy,
        .xz = b.i * xz,
        .yz = b.i * yz,
        .i = b.i * i
    }; }
    constexpr ProjectivePoint Motor::antiDot(const PointCenter& b) const noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = i
    }; }

    constexpr Multivector Plane::antiDot(const Motor& b) const noexcept { return {
        .s = 0.0,
        .w = b.i * w,
        .x = b.i * x,
        .y = b.i * y,
        .z = b.i * z,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = b.wz * w,
        .wxz = -b.wy * w,
        .wyz = b.wx * w,
        .xyz = (b.s * w + b.wx * x + b.wy * y + b.wz * z),
        .i = 0.0
    }; }
    constexpr PseudoScalar Plane::antiDot(const Plane& b) const noexcept { return {
        .i = -b.w * w
    }; }
    constexpr ProjectivePoint Plane::antiDot(const Bivector& b) const noexcept { return {
        .x = -b.wx * w,
        .y = -b.wy * w,
        .z = -b.wz * w,
        .w = (b.wx * x + b.wy * y + b.wz * z)
    }; }
    constexpr Bivector Plane::antiDot(const ProjectivePoint& b) const noexcept { return {
        .wx = b.x * w,
        .wy = b.y * w,
        .wz = b.z * w,
        .xy = (b.y * x - b.x * y),
        .xz = (b.z * x - b.x * z),
        .yz = (b.z * y - b.y * z)
    }; }
    constexpr ProjectivePoint Plane::antiDot(const Quaternion& b) const noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = b.s * w
    }; }
    constexpr ProjectivePoint Plane::antiDot(const ProjectiveTranslator& b) const noexcept { return {
        .x = -b.wx * w,
        .y = -b.wy * w,
        .z = -b.wz * w,
        .w = (b.s * w + b.wx * x + b.wy * y + b.wz * z)
    }; }
    constexpr ProjectivePoint Plane::antiDot(const Translator& b) const noexcept { return {
        .x = -b.wx * w,
        .y = -b.wy * w,
        .z = -b.wz * w,
        .w = (w + b.wx * x + b.wy * y + b.wz * z)
    }; }
    constexpr Bivector Plane::antiDot(const Vector& b) const noexcept { return {
        .wx = b.x * w,
        .wy = b.y * w,
        .wz = b.z * w,
        .xy = (b.y * x - b.x * y),
        .xz = (b.z * x - b.x * z),
        .yz = (b.z * y - b.y * z)
    }; }
    constexpr Bivector Plane::antiDot(const Point& b) const noexcept { return {
        .wx = b.x * w,
        .wy = b.y * w,
        .wz = b.z * w,
        .xy = (b.y * x - b.x * y),
        .xz = (b.z * x - b.x * z),
        .yz = (b.z * y - b.y * z)
    }; }
    constexpr ProjectivePoint Plane::antiDot(const BivectorWeight& b) const noexcept { return {
        .x = -b.wx * w,
        .y = -b.wy * w,
        .z = -b.wz * w,
        .w = (b.wx * x + b.wy * y + b.wz * z)
    }; }
    constexpr Plane Plane::antiDot(const PseudoScalar& b) const noexcept { return {
        .x = b.i * x,
        .y = b.i * y,
        .z = b.i * z,
        .w = b.i * w
    }; }

    constexpr Motor Bivector::antiDot(const Motor& b) const noexcept { return {
        .s = 0.0,
        .wx = b.i * wx,
        .wy = b.i * wy,
        .wz = b.i * wz,
        .xy = (b.i * xy - b.s * wz),
        .xz = (b.i * xz + b.s * wy),
        .yz = (b.i * yz - b.s * wx),
        .i = (-b.wx * wx - b.wy * wy - b.wz * wz)
    }; }
    constexpr ProjectivePoint Bivector::antiDot(const Plane& b) const noexcept { return {
        .x = -b.w * wx,
        .y = -b.w * wy,
        .z = -b.w * wz,
        .w = (b.x * wx + b.y * wy + b.z * wz)
    }; }
    constexpr PseudoScalar Bivector::antiDot(const Bivector& b) const noexcept { return {
        .i = (-b.wx * wx - b.wy * wy - b.wz * wz)
    }; }
    constexpr ProjectivePoint Bivector::antiDot(const ProjectivePoint& b) const noexcept { return {
        .x = (b.y * wz - b.z * wy),
        .y = (b.z * wx - b.x * wz),
        .z = (b.x * wy - b.y * wx),
        .w = (b.x * yz + b.z * xy - b.y * xz)
    }; }
    constexpr BivectorBulk Bivector::antiDot(const Quaternion& b) const noexcept { return {
        .xy = -b.s * wz,
        .xz = b.s * wy,
        .yz = -b.s * wx
    }; }
    constexpr Motor Bivector::antiDot(const ProjectiveTranslator& b) const noexcept { return {
        .s = 0.0,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = -b.s * wz,
        .xz = b.s * wy,
        .yz = -b.s * wx,
        .i = (-b.wx * wx - b.wy * wy - b.wz * wz)
    }; }
    constexpr Motor Bivector::antiDot(const Translator& b) const noexcept { return {
        .s = 0.0,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = -wz,
        .xz = wy,
        .yz = -wx,
        .i = (-b.wx * wx - b.wy * wy - b.wz * wz)
    }; }
    constexpr ProjectivePoint Bivector::antiDot(const Vector& b) const noexcept { return {
        .x = (b.y * wz - b.z * wy),
        .y = (b.z * wx - b.x * wz),
        .z = (b.x * wy - b.y * wx),
        .w = (b.x * yz + b.z * xy - b.y * xz)
    }; }
    constexpr ProjectivePoint Bivector::antiDot(const Point& b) const noexcept { return {
        .x = (b.y * wz - b.z * wy),
        .y = (b.z * wx - b.x * wz),
        .z = (b.x * wy - b.y * wx),
        .w = (b.x * yz + b.z * xy - b.y * xz)
    }; }
    constexpr ProjectivePoint Bivector::antiDot(const PlaneIdeal& b) const noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = (b.x * wx + b.y * wy + b.z * wz)
    }; }
    constexpr PseudoScalar Bivector::antiDot(const BivectorWeight& b) const noexcept { return {
        .i = (-b.wx * wx - b.wy * wy - b.wz * wz)
    }; }
    constexpr Bivector Bivector::antiDot(const PseudoScalar& b) const noexcept { return {
        .wx = b.i * wx,
        .wy = b.i * wy,
        .wz = b.i * wz,
        .xy = b.i * xy,
        .xz = b.i * xz,
        .yz = b.i * yz
    }; }

    constexpr Multivector ProjectivePoint::antiDot(const Motor& b) const noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = b.s * x,
        .y = b.s * y,
        .z = b.s * z,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (b.wy * x - b.i * z - b.wx * y),
        .wxz = (b.i * y + b.wz * x - b.wx * z),
        .wyz = (b.wz * y - b.i * x - b.wy * z),
        .xyz = (b.i * w + b.xz * y - b.xy * z - b.yz * x),
        .i = 0.0
    }; }
    constexpr Bivector ProjectivePoint::antiDot(const Plane& b) const noexcept { return {
        .wx = b.w * x,
        .wy = b.w * y,
        .wz = b.w * z,
        .xy = (b.x * y - b.y * x),
        .xz = (b.x * z - b.z * x),
        .yz = (b.y * z - b.z * y)
    }; }
    constexpr ProjectivePoint ProjectivePoint::antiDot(const Bivector& b) const noexcept { return {
        .x = (b.wy * z - b.wz * y),
        .y = (b.wz * x - b.wx * z),
        .z = (b.wx * y - b.wy * x),
        .w = (b.xz * y - b.xy * z - b.yz * x)
    }; }
    constexpr PseudoScalar ProjectivePoint::antiDot(const ProjectivePoint& b) const noexcept { return {
        .i = (b.x * x + b.y * y + b.z * z)
    }; }
    constexpr Multivector ProjectivePoint::antiDot(const Quaternion& b) const noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = b.s * x,
        .y = b.s * y,
        .z = b.s * z,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = 0.0,
        .wxz = 0.0,
        .wyz = 0.0,
        .xyz = (b.xz * y - b.xy * z - b.yz * x),
        .i = 0.0
    }; }
    constexpr Multivector ProjectivePoint::antiDot(const ProjectiveTranslator& b) const noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = b.s * x,
        .y = b.s * y,
        .z = b.s * z,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (b.wy * x - b.wx * y),
        .wxz = (b.wz * x - b.wx * z),
        .wyz = (b.wz * y - b.wy * z),
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector ProjectivePoint::antiDot(const Translator& b) const noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = x,
        .y = y,
        .z = z,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (b.wy * x - b.wx * y),
        .wxz = (b.wz * x - b.wx * z),
        .wyz = (b.wz * y - b.wy * z),
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr PseudoScalar ProjectivePoint::antiDot(const Vector& b) const noexcept { return {
        .i = (b.x * x + b.y * y + b.z * z)
    }; }
    constexpr PseudoScalar ProjectivePoint::antiDot(const Point& b) const noexcept { return {
        .i = (b.x * x + b.y * y + b.z * z)
    }; }
    constexpr BivectorBulk ProjectivePoint::antiDot(const PlaneIdeal& b) const noexcept { return {
        .xy = (b.x * y - b.y * x),
        .xz = (b.x * z - b.z * x),
        .yz = (b.y * z - b.z * y)
    }; }
    constexpr ProjectivePoint ProjectivePoint::antiDot(const BivectorBulk& b) const noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = (b.xz * y - b.xy * z - b.yz * x)
    }; }
    constexpr Vector ProjectivePoint::antiDot(const BivectorWeight& b) const noexcept { return {
        .x = (b.wy * z - b.wz * y),
        .y = (b.wz * x - b.wx * z),
        .z = (b.wx * y - b.wy * x)
    }; }
    constexpr ProjectivePoint ProjectivePoint::antiDot(const PseudoScalar& b) const noexcept { return {
        .x = b.i * x,
        .y = b.i * y,
        .z = b.i * z,
        .w = b.i * w
    }; }

    constexpr Quaternion Quaternion::antiDot(const Motor& b) const noexcept { return {
        .s = b.i * s,
        .xy = (b.i * xy - b.wz * s),
        .xz = (b.i * xz + b.wy * s),
        .yz = (b.i * yz - b.wx * s)
    }; }
    constexpr ProjectivePoint Quaternion::antiDot(const Plane& b) const noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = -b.w * s
    }; }
    constexpr BivectorBulk Quaternion::antiDot(const Bivector& b) const noexcept { return {
        .xy = -b.wz * s,
        .xz = b.wy * s,
        .yz = -b.wx * s
    }; }
    constexpr Multivector Quaternion::antiDot(const ProjectivePoint& b) const noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = -b.x * s,
        .y = -b.y * s,
        .z = -b.z * s,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = 0.0,
        .wxz = 0.0,
        .wyz = 0.0,
        .xyz = (b.x * yz + b.z * xy - b.y * xz),
        .i = 0.0
    }; }
    constexpr BivectorBulk Quaternion::antiDot(const ProjectiveTranslator& b) const noexcept { return {
        .xy = -b.wz * s,
        .xz = b.wy * s,
        .yz = -b.wx * s
    }; }
    constexpr BivectorBulk Quaternion::antiDot(const Translator& b) const noexcept { return {
        .xy = -b.wz * s,
        .xz = b.wy * s,
        .yz = -b.wx * s
    }; }
    constexpr Multivector Quaternion::antiDot(const Vector& b) const noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = -b.x * s,
        .y = -b.y * s,
        .z = -b.z * s,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = 0.0,
        .wxz = 0.0,
        .wyz = 0.0,
        .xyz = (b.x * yz + b.z * xy - b.y * xz),
        .i = 0.0
    }; }
    constexpr Multivector Quaternion::antiDot(const Point& b) const noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = -b.x * s,
        .y = -b.y * s,
        .z = -b.z * s,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = 0.0,
        .wxz = 0.0,
        .wyz = 0.0,
        .xyz = (b.x * yz + b.z * xy - b.y * xz),
        .i = 0.0
    }; }
    constexpr BivectorBulk Quaternion::antiDot(const BivectorWeight& b) const noexcept { return {
        .xy = -b.wz * s,
        .xz = b.wy * s,
        .yz = -b.wx * s
    }; }
    constexpr Quaternion Quaternion::antiDot(const PseudoScalar& b) const noexcept { return {
        .s = b.i * s,
        .xy = b.i * xy,
        .xz = b.i * xz,
        .yz = b.i * yz
    }; }

    constexpr Motor ProjectiveTranslator::antiDot(const Motor& b) const noexcept { return {
        .s = b.i * s,
        .wx = b.i * wx,
        .wy = b.i * wy,
        .wz = b.i * wz,
        .xy = (-b.s * wz - b.wz * s),
        .xz = (b.s * wy + b.wy * s),
        .yz = (-b.s * wx - b.wx * s),
        .i = (-b.wx * wx - b.wy * wy - b.wz * wz)
    }; }
    constexpr ProjectivePoint ProjectiveTranslator::antiDot(const Plane& b) const noexcept { return {
        .x = -b.w * wx,
        .y = -b.w * wy,
        .z = -b.w * wz,
        .w = (b.x * wx + b.y * wy + b.z * wz - b.w * s)
    }; }
    constexpr Motor ProjectiveTranslator::antiDot(const Bivector& b) const noexcept { return {
        .s = 0.0,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = -b.wz * s,
        .xz = b.wy * s,
        .yz = -b.wx * s,
        .i = (-b.wx * wx - b.wy * wy - b.wz * wz)
    }; }
    constexpr Multivector ProjectiveTranslator::antiDot(const ProjectivePoint& b) const noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = -b.x * s,
        .y = -b.y * s,
        .z = -b.z * s,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (b.y * wx - b.x * wy),
        .wxz = (b.z * wx - b.x * wz),
        .wyz = (b.z * wy - b.y * wz),
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr BivectorBulk ProjectiveTranslator::antiDot(const Quaternion& b) const noexcept { return {
        .xy = -b.s * wz,
        .xz = b.s * wy,
        .yz = -b.s * wx
    }; }
    constexpr Motor ProjectiveTranslator::antiDot(const ProjectiveTranslator& b) const noexcept { return {
        .s = 0.0,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = (-b.s * wz - b.wz * s),
        .xz = (b.s * wy + b.wy * s),
        .yz = (-b.s * wx - b.wx * s),
        .i = (-b.wx * wx - b.wy * wy - b.wz * wz)
    }; }
    constexpr Motor ProjectiveTranslator::antiDot(const Translator& b) const noexcept { return {
        .s = 0.0,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = (-wz - b.wz * s),
        .xz = (wy + b.wy * s),
        .yz = (-wx - b.wx * s),
        .i = (-b.wx * wx - b.wy * wy - b.wz * wz)
    }; }
    constexpr Multivector ProjectiveTranslator::antiDot(const Vector& b) const noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = -b.x * s,
        .y = -b.y * s,
        .z = -b.z * s,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (b.y * wx - b.x * wy),
        .wxz = (b.z * wx - b.x * wz),
        .wyz = (b.z * wy - b.y * wz),
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector ProjectiveTranslator::antiDot(const Point& b) const noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = -b.x * s,
        .y = -b.y * s,
        .z = -b.z * s,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (b.y * wx - b.x * wy),
        .wxz = (b.z * wx - b.x * wz),
        .wyz = (b.z * wy - b.y * wz),
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr ProjectivePoint ProjectiveTranslator::antiDot(const PlaneIdeal& b) const noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = (b.x * wx + b.y * wy + b.z * wz)
    }; }
    constexpr Motor ProjectiveTranslator::antiDot(const BivectorWeight& b) const noexcept { return {
        .s = 0.0,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = -b.wz * s,
        .xz = b.wy * s,
        .yz = -b.wx * s,
        .i = (-b.wx * wx - b.wy * wy - b.wz * wz)
    }; }
    constexpr ProjectiveTranslator ProjectiveTranslator::antiDot(const PseudoScalar& b) const noexcept { return {
        .s = b.i * s,
        .wx = b.i * wx,
        .wy = b.i * wy,
        .wz = b.i * wz
    }; }

    constexpr Motor Translator::antiDot(const Motor& b) const noexcept { return {
        .s = b.i,
        .wx = b.i * wx,
        .wy = b.i * wy,
        .wz = b.i * wz,
        .xy = (-b.wz - b.s * wz),
        .xz = (b.wy + b.s * wy),
        .yz = (-b.wx - b.s * wx),
        .i = (-b.wx * wx - b.wy * wy - b.wz * wz)
    }; }
    constexpr ProjectivePoint Translator::antiDot(const Plane& b) const noexcept { return {
        .x = -b.w * wx,
        .y = -b.w * wy,
        .z = -b.w * wz,
        .w = (-b.w + b.x * wx + b.y * wy + b.z * wz)
    }; }
    constexpr Motor Translator::antiDot(const Bivector& b) const noexcept { return {
        .s = 0.0,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = -b.wz,
        .xz = b.wy,
        .yz = -b.wx,
        .i = (-b.wx * wx - b.wy * wy - b.wz * wz)
    }; }
    constexpr Multivector Translator::antiDot(const ProjectivePoint& b) const noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = -b.x,
        .y = -b.y,
        .z = -b.z,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (b.y * wx - b.x * wy),
        .wxz = (b.z * wx - b.x * wz),
        .wyz = (b.z * wy - b.y * wz),
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr BivectorBulk Translator::antiDot(const Quaternion& b) const noexcept { return {
        .xy = -b.s * wz,
        .xz = b.s * wy,
        .yz = -b.s * wx
    }; }
    constexpr Motor Translator::antiDot(const ProjectiveTranslator& b) const noexcept { return {
        .s = 0.0,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = (-b.wz - b.s * wz),
        .xz = (b.wy + b.s * wy),
        .yz = (-b.wx - b.s * wx),
        .i = (-b.wx * wx - b.wy * wy - b.wz * wz)
    }; }
    constexpr Motor Translator::antiDot(const Translator& b) const noexcept { return {
        .s = 0.0,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = (-b.wz - wz),
        .xz = (b.wy + wy),
        .yz = (-b.wx - wx),
        .i = (-b.wx * wx - b.wy * wy - b.wz * wz)
    }; }
    constexpr Multivector Translator::antiDot(const Vector& b) const noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = -b.x,
        .y = -b.y,
        .z = -b.z,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (b.y * wx - b.x * wy),
        .wxz = (b.z * wx - b.x * wz),
        .wyz = (b.z * wy - b.y * wz),
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector Translator::antiDot(const Point& b) const noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = -b.x,
        .y = -b.y,
        .z = -b.z,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (b.y * wx - b.x * wy),
        .wxz = (b.z * wx - b.x * wz),
        .wyz = (b.z * wy - b.y * wz),
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr ProjectivePoint Translator::antiDot(const PlaneIdeal& b) const noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = (b.x * wx + b.y * wy + b.z * wz)
    }; }
    constexpr Motor Translator::antiDot(const BivectorWeight& b) const noexcept { return {
        .s = 0.0,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = -b.wz,
        .xz = b.wy,
        .yz = -b.wx,
        .i = (-b.wx * wx - b.wy * wy - b.wz * wz)
    }; }
    constexpr ProjectiveTranslator Translator::antiDot(const PseudoScalar& b) const noexcept { return {
        .s = b.i,
        .wx = b.i * wx,
        .wy = b.i * wy,
        .wz = b.i * wz
    }; }

    constexpr Multivector Vector::antiDot(const Motor& b) const noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = b.s * x,
        .y = b.s * y,
        .z = b.s * z,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (b.wy * x - b.i * z - b.wx * y),
        .wxz = (b.i * y + b.wz * x - b.wx * z),
        .wyz = (b.wz * y - b.i * x - b.wy * z),
        .xyz = (b.xz * y - b.xy * z - b.yz * x),
        .i = 0.0
    }; }
    constexpr Bivector Vector::antiDot(const Plane& b) const noexcept { return {
        .wx = b.w * x,
        .wy = b.w * y,
        .wz = b.w * z,
        .xy = (b.x * y - b.y * x),
        .xz = (b.x * z - b.z * x),
        .yz = (b.y * z - b.z * y)
    }; }
    constexpr ProjectivePoint Vector::antiDot(const Bivector& b) const noexcept { return {
        .x = (b.wy * z - b.wz * y),
        .y = (b.wz * x - b.wx * z),
        .z = (b.wx * y - b.wy * x),
        .w = (b.xz * y - b.xy * z - b.yz * x)
    }; }
    constexpr PseudoScalar Vector::antiDot(const ProjectivePoint& b) const noexcept { return {
        .i = (b.x * x + b.y * y + b.z * z)
    }; }
    constexpr Multivector Vector::antiDot(const Quaternion& b) const noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = b.s * x,
        .y = b.s * y,
        .z = b.s * z,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = 0.0,
        .wxz = 0.0,
        .wyz = 0.0,
        .xyz = (b.xz * y - b.xy * z - b.yz * x),
        .i = 0.0
    }; }
    constexpr Multivector Vector::antiDot(const ProjectiveTranslator& b) const noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = b.s * x,
        .y = b.s * y,
        .z = b.s * z,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (b.wy * x - b.wx * y),
        .wxz = (b.wz * x - b.wx * z),
        .wyz = (b.wz * y - b.wy * z),
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector Vector::antiDot(const Translator& b) const noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = x,
        .y = y,
        .z = z,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (b.wy * x - b.wx * y),
        .wxz = (b.wz * x - b.wx * z),
        .wyz = (b.wz * y - b.wy * z),
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr PseudoScalar Vector::antiDot(const Vector& b) const noexcept { return {
        .i = (b.x * x + b.y * y + b.z * z)
    }; }
    constexpr PseudoScalar Vector::antiDot(const Point& b) const noexcept { return {
        .i = (b.x * x + b.y * y + b.z * z)
    }; }
    constexpr BivectorBulk Vector::antiDot(const PlaneIdeal& b) const noexcept { return {
        .xy = (b.x * y - b.y * x),
        .xz = (b.x * z - b.z * x),
        .yz = (b.y * z - b.z * y)
    }; }
    constexpr ProjectivePoint Vector::antiDot(const BivectorBulk& b) const noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = (b.xz * y - b.xy * z - b.yz * x)
    }; }
    constexpr Vector Vector::antiDot(const BivectorWeight& b) const noexcept { return {
        .x = (b.wy * z - b.wz * y),
        .y = (b.wz * x - b.wx * z),
        .z = (b.wx * y - b.wy * x)
    }; }
    constexpr Vector Vector::antiDot(const PseudoScalar& b) const noexcept { return {
        .x = b.i * x,
        .y = b.i * y,
        .z = b.i * z
    }; }

    constexpr Multivector Point::antiDot(const Motor& b) const noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = b.s * x,
        .y = b.s * y,
        .z = b.s * z,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (b.wy * x - b.i * z - b.wx * y),
        .wxz = (b.i * y + b.wz * x - b.wx * z),
        .wyz = (b.wz * y - b.i * x - b.wy * z),
        .xyz = (b.i + b.xz * y - b.xy * z - b.yz * x),
        .i = 0.0
    }; }
    constexpr Bivector Point::antiDot(const Plane& b) const noexcept { return {
        .wx = b.w * x,
        .wy = b.w * y,
        .wz = b.w * z,
        .xy = (b.x * y - b.y * x),
        .xz = (b.x * z - b.z * x),
        .yz = (b.y * z - b.z * y)
    }; }
    constexpr ProjectivePoint Point::antiDot(const Bivector& b) const noexcept { return {
        .x = (b.wy * z - b.wz * y),
        .y = (b.wz * x - b.wx * z),
        .z = (b.wx * y - b.wy * x),
        .w = (b.xz * y - b.xy * z - b.yz * x)
    }; }
    constexpr PseudoScalar Point::antiDot(const ProjectivePoint& b) const noexcept { return {
        .i = (b.x * x + b.y * y + b.z * z)
    }; }
    constexpr Multivector Point::antiDot(const Quaternion& b) const noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = b.s * x,
        .y = b.s * y,
        .z = b.s * z,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = 0.0,
        .wxz = 0.0,
        .wyz = 0.0,
        .xyz = (b.xz * y - b.xy * z - b.yz * x),
        .i = 0.0
    }; }
    constexpr Multivector Point::antiDot(const ProjectiveTranslator& b) const noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = b.s * x,
        .y = b.s * y,
        .z = b.s * z,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (b.wy * x - b.wx * y),
        .wxz = (b.wz * x - b.wx * z),
        .wyz = (b.wz * y - b.wy * z),
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector Point::antiDot(const Translator& b) const noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = x,
        .y = y,
        .z = z,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (b.wy * x - b.wx * y),
        .wxz = (b.wz * x - b.wx * z),
        .wyz = (b.wz * y - b.wy * z),
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr PseudoScalar Point::antiDot(const Vector& b) const noexcept { return {
        .i = (b.x * x + b.y * y + b.z * z)
    }; }
    constexpr PseudoScalar Point::antiDot(const Point& b) const noexcept { return {
        .i = (b.x * x + b.y * y + b.z * z)
    }; }
    constexpr BivectorBulk Point::antiDot(const PlaneIdeal& b) const noexcept { return {
        .xy = (b.x * y - b.y * x),
        .xz = (b.x * z - b.z * x),
        .yz = (b.y * z - b.z * y)
    }; }
    constexpr ProjectivePoint Point::antiDot(const BivectorBulk& b) const noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = (b.xz * y - b.xy * z - b.yz * x)
    }; }
    constexpr Vector Point::antiDot(const BivectorWeight& b) const noexcept { return {
        .x = (b.wy * z - b.wz * y),
        .y = (b.wz * x - b.wx * z),
        .z = (b.wx * y - b.wy * x)
    }; }
    constexpr ProjectivePoint Point::antiDot(const PseudoScalar& b) const noexcept { return {
        .x = b.i * x,
        .y = b.i * y,
        .z = b.i * z,
        .w = b.i
    }; }

    constexpr Multivector PlaneIdeal::antiDot(const Motor& b) const noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = b.i * x,
        .y = b.i * y,
        .z = b.i * z,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = 0.0,
        .wxz = 0.0,
        .wyz = 0.0,
        .xyz = (b.wx * x + b.wy * y + b.wz * z),
        .i = 0.0
    }; }
    constexpr ProjectivePoint PlaneIdeal::antiDot(const Bivector& b) const noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = (b.wx * x + b.wy * y + b.wz * z)
    }; }
    constexpr BivectorBulk PlaneIdeal::antiDot(const ProjectivePoint& b) const noexcept { return {
        .xy = (b.y * x - b.x * y),
        .xz = (b.z * x - b.x * z),
        .yz = (b.z * y - b.y * z)
    }; }
    constexpr ProjectivePoint PlaneIdeal::antiDot(const ProjectiveTranslator& b) const noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = (b.wx * x + b.wy * y + b.wz * z)
    }; }
    constexpr ProjectivePoint PlaneIdeal::antiDot(const Translator& b) const noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = (b.wx * x + b.wy * y + b.wz * z)
    }; }
    constexpr BivectorBulk PlaneIdeal::antiDot(const Vector& b) const noexcept { return {
        .xy = (b.y * x - b.x * y),
        .xz = (b.z * x - b.x * z),
        .yz = (b.z * y - b.y * z)
    }; }
    constexpr BivectorBulk PlaneIdeal::antiDot(const Point& b) const noexcept { return {
        .xy = (b.y * x - b.x * y),
        .xz = (b.z * x - b.x * z),
        .yz = (b.z * y - b.y * z)
    }; }
    constexpr ProjectivePoint PlaneIdeal::antiDot(const BivectorWeight& b) const noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = (b.wx * x + b.wy * y + b.wz * z)
    }; }
    constexpr PlaneIdeal PlaneIdeal::antiDot(const PseudoScalar& b) const noexcept { return {
        .x = b.i * x,
        .y = b.i * y,
        .z = b.i * z
    }; }

    constexpr BivectorBulk BivectorBulk::antiDot(const Motor& b) const noexcept { return {
        .xy = b.i * xy,
        .xz = b.i * xz,
        .yz = b.i * yz
    }; }
    constexpr ProjectivePoint BivectorBulk::antiDot(const ProjectivePoint& b) const noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = (b.x * yz + b.z * xy - b.y * xz)
    }; }
    constexpr ProjectivePoint BivectorBulk::antiDot(const Vector& b) const noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = (b.x * yz + b.z * xy - b.y * xz)
    }; }
    constexpr ProjectivePoint BivectorBulk::antiDot(const Point& b) const noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = (b.x * yz + b.z * xy - b.y * xz)
    }; }
    constexpr BivectorBulk BivectorBulk::antiDot(const PseudoScalar& b) const noexcept { return {
        .xy = b.i * xy,
        .xz = b.i * xz,
        .yz = b.i * yz
    }; }

    constexpr Motor BivectorWeight::antiDot(const Motor& b) const noexcept { return {
        .s = 0.0,
        .wx = b.i * wx,
        .wy = b.i * wy,
        .wz = b.i * wz,
        .xy = -b.s * wz,
        .xz = b.s * wy,
        .yz = -b.s * wx,
        .i = (-b.wx * wx - b.wy * wy - b.wz * wz)
    }; }
    constexpr ProjectivePoint BivectorWeight::antiDot(const Plane& b) const noexcept { return {
        .x = -b.w * wx,
        .y = -b.w * wy,
        .z = -b.w * wz,
        .w = (b.x * wx + b.y * wy + b.z * wz)
    }; }
    constexpr PseudoScalar BivectorWeight::antiDot(const Bivector& b) const noexcept { return {
        .i = (-b.wx * wx - b.wy * wy - b.wz * wz)
    }; }
    constexpr Vector BivectorWeight::antiDot(const ProjectivePoint& b) const noexcept { return {
        .x = (b.y * wz - b.z * wy),
        .y = (b.z * wx - b.x * wz),
        .z = (b.x * wy - b.y * wx)
    }; }
    constexpr BivectorBulk BivectorWeight::antiDot(const Quaternion& b) const noexcept { return {
        .xy = -b.s * wz,
        .xz = b.s * wy,
        .yz = -b.s * wx
    }; }
    constexpr Motor BivectorWeight::antiDot(const ProjectiveTranslator& b) const noexcept { return {
        .s = 0.0,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = -b.s * wz,
        .xz = b.s * wy,
        .yz = -b.s * wx,
        .i = (-b.wx * wx - b.wy * wy - b.wz * wz)
    }; }
    constexpr Motor BivectorWeight::antiDot(const Translator& b) const noexcept { return {
        .s = 0.0,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = -wz,
        .xz = wy,
        .yz = -wx,
        .i = (-b.wx * wx - b.wy * wy - b.wz * wz)
    }; }
    constexpr Vector BivectorWeight::antiDot(const Vector& b) const noexcept { return {
        .x = (b.y * wz - b.z * wy),
        .y = (b.z * wx - b.x * wz),
        .z = (b.x * wy - b.y * wx)
    }; }
    constexpr Vector BivectorWeight::antiDot(const Point& b) const noexcept { return {
        .x = (b.y * wz - b.z * wy),
        .y = (b.z * wx - b.x * wz),
        .z = (b.x * wy - b.y * wx)
    }; }
    constexpr ProjectivePoint BivectorWeight::antiDot(const PlaneIdeal& b) const noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = (b.x * wx + b.y * wy + b.z * wz)
    }; }
    constexpr PseudoScalar BivectorWeight::antiDot(const BivectorWeight& b) const noexcept { return {
        .i = (-b.wx * wx - b.wy * wy - b.wz * wz)
    }; }
    constexpr BivectorWeight BivectorWeight::antiDot(const PseudoScalar& b) const noexcept { return {
        .wx = b.i * wx,
        .wy = b.i * wy,
        .wz = b.i * wz
    }; }

    constexpr Motor PseudoScalar::antiDot(const Motor& b) const noexcept { return {
        .s = b.s * i,
        .wx = b.wx * i,
        .wy = b.wy * i,
        .wz = b.wz * i,
        .xy = b.xy * i,
        .xz = b.xz * i,
        .yz = b.yz * i,
        .i = b.i * i
    }; }
    constexpr Plane PseudoScalar::antiDot(const Plane& b) const noexcept { return {
        .x = b.x * i,
        .y = b.y * i,
        .z = b.z * i,
        .w = b.w * i
    }; }
    constexpr Bivector PseudoScalar::antiDot(const Bivector& b) const noexcept { return {
        .wx = b.wx * i,
        .wy = b.wy * i,
        .wz = b.wz * i,
        .xy = b.xy * i,
        .xz = b.xz * i,
        .yz = b.yz * i
    }; }
    constexpr ProjectivePoint PseudoScalar::antiDot(const ProjectivePoint& b) const noexcept { return {
        .x = b.x * i,
        .y = b.y * i,
        .z = b.z * i,
        .w = b.w * i
    }; }
    constexpr Quaternion PseudoScalar::antiDot(const Quaternion& b) const noexcept { return {
        .s = b.s * i,
        .xy = b.xy * i,
        .xz = b.xz * i,
        .yz = b.yz * i
    }; }
    constexpr ProjectiveTranslator PseudoScalar::antiDot(const ProjectiveTranslator& b) const noexcept { return {
        .s = b.s * i,
        .wx = b.wx * i,
        .wy = b.wy * i,
        .wz = b.wz * i
    }; }
    constexpr ProjectiveTranslator PseudoScalar::antiDot(const Translator& b) const noexcept { return {
        .s = i,
        .wx = b.wx * i,
        .wy = b.wy * i,
        .wz = b.wz * i
    }; }
    constexpr Vector PseudoScalar::antiDot(const Vector& b) const noexcept { return {
        .x = b.x * i,
        .y = b.y * i,
        .z = b.z * i
    }; }
    constexpr ProjectivePoint PseudoScalar::antiDot(const Point& b) const noexcept { return {
        .x = b.x * i,
        .y = b.y * i,
        .z = b.z * i,
        .w = i
    }; }
    constexpr PlaneIdeal PseudoScalar::antiDot(const PlaneIdeal& b) const noexcept { return {
        .x = b.x * i,
        .y = b.y * i,
        .z = b.z * i
    }; }
    constexpr BivectorBulk PseudoScalar::antiDot(const BivectorBulk& b) const noexcept { return {
        .xy = b.xy * i,
        .xz = b.xz * i,
        .yz = b.yz * i
    }; }
    constexpr BivectorWeight PseudoScalar::antiDot(const BivectorWeight& b) const noexcept { return {
        .wx = b.wx * i,
        .wy = b.wy * i,
        .wz = b.wz * i
    }; }
    constexpr PseudoScalar PseudoScalar::antiDot(const PseudoScalar& b) const noexcept { return {
        .i = b.i * i
    }; }
    constexpr ProjectivePoint PseudoScalar::antiDot(const PointCenter& b) const noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = i
    }; }

    constexpr ProjectivePoint PointCenter::antiDot(const Motor& b) const noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = b.i
    }; }
    constexpr ProjectivePoint PointCenter::antiDot(const PseudoScalar& b) const noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = b.i
    }; }

}