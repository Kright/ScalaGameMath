// Copyright (c) 2025 Igor Slobodskov
// SPDX-License-Identifier: MIT

#pragma once

#include <cmath>
#include "types.h"
#include "opsArithmetic.h"
#include "opsNorm.h"

// generated by com.github.kright.pga3d.codegen.cpp.ops.BivectorOpsGenerator

namespace pga3d {

    inline std::pair<Bivector, BivectorWeight> Bivector::split() const noexcept {
        const double div = bulkNormSquare();
        if (div < 1e-100) {
            return {
                Bivector{ .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = xy, .xz = xz, .yz = yz },
                BivectorWeight{ .wx = wx, .wy = wy, .wz = wz }
            };
        }

        const double pseudoScalar = (wy * xz - wx * yz - wz * xy) / div;
        const BivectorWeight shiftAlongLine{
            .wx = -pseudoScalar * yz,
            .wy = pseudoScalar * xz,
            .wz = -pseudoScalar * xy
        };

        const Bivector line = (*this) - shiftAlongLine;
        return {line, shiftAlongLine};
    }

    inline Motor Bivector::exp() const noexcept {
        const double len = bulkNorm();
        const double cos = std::cos(len);

        const double sinDivLen = (len > 1e-5) ?
            (std::sin(len) / len) :
            (1.0 - (len * len) / 6.0);

        const double sinMinusCosDivLen2 = (len > 1e-5) ?
            (sinDivLen - cos) / (len * len) :
            (1.0 / 3.0) * (1.0 + 0.8 * len * len);

        return Motor {
          .s = cos,
          .wx = (sinDivLen * wx + sinMinusCosDivLen2 * yz * (wy * xz - wx * yz - wz * xy)),
          .wy = (sinDivLen * wy + sinMinusCosDivLen2 * xz * (wx * yz + wz * xy - wy * xz)),
          .wz = (sinDivLen * wz + sinMinusCosDivLen2 * xy * (wy * xz - wx * yz - wz * xy)),
          .xy = sinDivLen * xy,
          .xz = sinDivLen * xz,
          .yz = sinDivLen * yz,
          .i = sinDivLen * (wx * yz + wz * xy - wy * xz),
        };
    }
}