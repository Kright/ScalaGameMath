#pragma once

#include "types.h"

// generated by com.github.kright.pga3d.codegen.cpp.binops.AntiWedgeOpGenerator

namespace pga3d {
    constexpr Multivector Multivector::antiWedge(const Multivector& b) const noexcept { return {.s = (b.i * s + b.s * i + b.w * xyz + b.wx * yz + b.wxy * z + b.wyz * x + b.wz * xy + b.xy * wz + b.y * wxz + b.yz * wx - b.wxz * y - b.wy * xz - b.x * wyz - b.xyz * w - b.xz * wy - b.z * wxy), .w = (b.i * w + b.w * i + b.wxz * wy + b.wy * wxz - b.wx * wyz - b.wxy * wz - b.wyz * wx - b.wz * wxy), .x = (b.i * x + b.wxz * xy + b.x * i + b.xy * wxz - b.wx * xyz - b.wxy * xz - b.xyz * wx - b.xz * wxy), .y = (b.i * y + b.wyz * xy + b.xy * wyz + b.y * i - b.wxy * yz - b.wy * xyz - b.xyz * wy - b.yz * wxy), .z = (b.i * z + b.wyz * xz + b.xz * wyz + b.z * i - b.wxz * yz - b.wz * xyz - b.xyz * wz - b.yz * wxz), .wx = (b.i * wx + b.wx * i + b.wxz * wxy - b.wxy * wxz), .wy = (b.i * wy + b.wy * i + b.wyz * wxy - b.wxy * wyz), .wz = (b.i * wz + b.wyz * wxz + b.wz * i - b.wxz * wyz), .xy = (b.i * xy + b.xy * i + b.xyz * wxy - b.wxy * xyz), .xz = (b.i * xz + b.xyz * wxz + b.xz * i - b.wxz * xyz), .yz = (b.i * yz + b.xyz * wyz + b.yz * i - b.wyz * xyz), .wxy = (b.i * wxy + b.wxy * i), .wxz = (b.i * wxz + b.wxz * i), .wyz = (b.i * wyz + b.wyz * i), .xyz = (b.i * xyz + b.xyz * i), .i = b.i * i}; }

    constexpr Motor Motor::antiWedge(const Motor& b) const noexcept { return {.s = (b.i * s + b.s * i + b.wx * yz + b.wz * xy + b.xy * wz + b.yz * wx - b.wy * xz - b.xz * wy), .wx = (b.i * wx + b.wx * i), .wy = (b.i * wy + b.wy * i), .wz = (b.i * wz + b.wz * i), .xy = (b.i * xy + b.xy * i), .xz = (b.i * xz + b.xz * i), .yz = (b.i * yz + b.yz * i), .i = b.i * i}; }
    constexpr Plane Motor::antiWedge(const Plane& b) const noexcept { return {.x = b.x * i, .y = b.y * i, .z = b.z * i, .w = b.w * i}; }
    constexpr Motor Motor::antiWedge(const Bivector& b) const noexcept { return {.s = (b.wx * yz + b.wz * xy + b.xy * wz + b.yz * wx - b.wy * xz - b.xz * wy), .wx = b.wx * i, .wy = b.wy * i, .wz = b.wz * i, .xy = b.xy * i, .xz = b.xz * i, .yz = b.yz * i, .i = 0.0}; }
    constexpr Multivector Motor::antiWedge(const ProjectivePoint& b) const noexcept { return {.s = 0.0, .w = (b.x * wx + b.y * wy + b.z * wz), .x = (b.y * xy + b.z * xz - b.w * wx), .y = (b.z * yz - b.w * wy - b.x * xy), .z = (-b.w * wz - b.x * xz - b.y * yz), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = -b.z * i, .wxz = b.y * i, .wyz = -b.x * i, .xyz = b.w * i, .i = 0.0}; }
    constexpr Quaternion Motor::antiWedge(const Quaternion& b) const noexcept { return {.s = (b.s * i + b.xy * wz + b.yz * wx - b.xz * wy), .xy = b.xy * i, .xz = b.xz * i, .yz = b.yz * i}; }
    constexpr Motor Motor::antiWedge(const Translator& b) const noexcept { return {.s = (i + b.wx * yz + b.wz * xy - b.wy * xz), .wx = b.wx * i, .wy = b.wy * i, .wz = b.wz * i, .xy = 0.0, .xz = 0.0, .yz = 0.0, .i = 0.0}; }
    constexpr Multivector Motor::antiWedge(const Vector& b) const noexcept { return {.s = 0.0, .w = (b.x * wx + b.y * wy + b.z * wz), .x = (b.y * xy + b.z * xz), .y = (b.z * yz - b.x * xy), .z = (-b.x * xz - b.y * yz), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = -b.z * i, .wxz = b.y * i, .wyz = -b.x * i, .xyz = 0.0, .i = 0.0}; }
    constexpr Multivector Motor::antiWedge(const Point& b) const noexcept { return {.s = 0.0, .w = (b.x * wx + b.y * wy + b.z * wz), .x = (-wx + b.y * xy + b.z * xz), .y = (-wy + b.z * yz - b.x * xy), .z = (-wz - b.x * xz - b.y * yz), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = -b.z * i, .wxz = b.y * i, .wyz = -b.x * i, .xyz = i, .i = 0.0}; }
    constexpr PlaneIdeal Motor::antiWedge(const PlaneIdeal& b) const noexcept { return {.x = b.x * i, .y = b.y * i, .z = b.z * i}; }
    constexpr Quaternion Motor::antiWedge(const BivectorBulk& b) const noexcept { return {.s = (b.xy * wz + b.yz * wx - b.xz * wy), .xy = b.xy * i, .xz = b.xz * i, .yz = b.yz * i}; }
    constexpr Motor Motor::antiWedge(const BivectorWeight& b) const noexcept { return {.s = (b.wx * yz + b.wz * xy - b.wy * xz), .wx = b.wx * i, .wy = b.wy * i, .wz = b.wz * i, .xy = 0.0, .xz = 0.0, .yz = 0.0, .i = 0.0}; }
    constexpr Motor Motor::antiWedge(const PseudoScalar& b) const noexcept { return {.s = b.i * s, .wx = b.i * wx, .wy = b.i * wy, .wz = b.i * wz, .xy = b.i * xy, .xz = b.i * xz, .yz = b.i * yz, .i = b.i * i}; }
    constexpr Multivector Motor::antiWedge(const PointCenter& b) const noexcept { return {.s = 0.0, .w = 0.0, .x = -wx, .y = -wy, .z = -wz, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = 0.0, .wxz = 0.0, .wyz = 0.0, .xyz = i, .i = 0.0}; }

    constexpr Plane Plane::antiWedge(const Motor& b) const noexcept { return {.x = b.i * x, .y = b.i * y, .z = b.i * z, .w = b.i * w}; }
    constexpr double Plane::antiWedge(const ProjectivePoint& b) const noexcept { return (-b.w * w - b.x * x - b.y * y - b.z * z); }
    constexpr double Plane::antiWedge(const Vector& b) const noexcept { return (-b.x * x - b.y * y - b.z * z); }
    constexpr double Plane::antiWedge(const Point& b) const noexcept { return (-w - b.x * x - b.y * y - b.z * z); }
    constexpr Plane Plane::antiWedge(const PseudoScalar& b) const noexcept { return {.x = b.i * x, .y = b.i * y, .z = b.i * z, .w = b.i * w}; }
    constexpr double Plane::antiWedge(const PointCenter& b) const noexcept { return -w; }

    constexpr Motor Bivector::antiWedge(const Motor& b) const noexcept { return {.s = (b.wx * yz + b.wz * xy + b.xy * wz + b.yz * wx - b.wy * xz - b.xz * wy), .wx = b.i * wx, .wy = b.i * wy, .wz = b.i * wz, .xy = b.i * xy, .xz = b.i * xz, .yz = b.i * yz, .i = 0.0}; }
    constexpr double Bivector::antiWedge(const Bivector& b) const noexcept { return (b.wx * yz + b.wz * xy + b.xy * wz + b.yz * wx - b.wy * xz - b.xz * wy); }
    constexpr Plane Bivector::antiWedge(const ProjectivePoint& b) const noexcept { return {.x = (b.y * xy + b.z * xz - b.w * wx), .y = (b.z * yz - b.w * wy - b.x * xy), .z = (-b.w * wz - b.x * xz - b.y * yz), .w = (b.x * wx + b.y * wy + b.z * wz)}; }
    constexpr double Bivector::antiWedge(const Quaternion& b) const noexcept { return (b.xy * wz + b.yz * wx - b.xz * wy); }
    constexpr double Bivector::antiWedge(const Translator& b) const noexcept { return (b.wx * yz + b.wz * xy - b.wy * xz); }
    constexpr Plane Bivector::antiWedge(const Vector& b) const noexcept { return {.x = (b.y * xy + b.z * xz), .y = (b.z * yz - b.x * xy), .z = (-b.x * xz - b.y * yz), .w = (b.x * wx + b.y * wy + b.z * wz)}; }
    constexpr Plane Bivector::antiWedge(const Point& b) const noexcept { return {.x = (-wx + b.y * xy + b.z * xz), .y = (-wy + b.z * yz - b.x * xy), .z = (-wz - b.x * xz - b.y * yz), .w = (b.x * wx + b.y * wy + b.z * wz)}; }
    constexpr double Bivector::antiWedge(const BivectorBulk& b) const noexcept { return (b.xy * wz + b.yz * wx - b.xz * wy); }
    constexpr double Bivector::antiWedge(const BivectorWeight& b) const noexcept { return (b.wx * yz + b.wz * xy - b.wy * xz); }
    constexpr Bivector Bivector::antiWedge(const PseudoScalar& b) const noexcept { return {.wx = b.i * wx, .wy = b.i * wy, .wz = b.i * wz, .xy = b.i * xy, .xz = b.i * xz, .yz = b.i * yz}; }
    constexpr PlaneIdeal Bivector::antiWedge(const PointCenter& b) const noexcept { return {.x = -wx, .y = -wy, .z = -wz}; }

    constexpr Multivector ProjectivePoint::antiWedge(const Motor& b) const noexcept { return {.s = 0.0, .w = (b.wx * x + b.wy * y + b.wz * z), .x = (b.xy * y + b.xz * z - b.wx * w), .y = (b.yz * z - b.wy * w - b.xy * x), .z = (-b.wz * w - b.xz * x - b.yz * y), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = -b.i * z, .wxz = b.i * y, .wyz = -b.i * x, .xyz = b.i * w, .i = 0.0}; }
    constexpr double ProjectivePoint::antiWedge(const Plane& b) const noexcept { return (b.w * w + b.x * x + b.y * y + b.z * z); }
    constexpr Plane ProjectivePoint::antiWedge(const Bivector& b) const noexcept { return {.x = (b.xy * y + b.xz * z - b.wx * w), .y = (b.yz * z - b.wy * w - b.xy * x), .z = (-b.wz * w - b.xz * x - b.yz * y), .w = (b.wx * x + b.wy * y + b.wz * z)}; }
    constexpr Bivector ProjectivePoint::antiWedge(const ProjectivePoint& b) const noexcept { return {.wx = (b.z * y - b.y * z), .wy = (b.x * z - b.z * x), .wz = (b.y * x - b.x * y), .xy = (b.z * w - b.w * z), .xz = (b.w * y - b.y * w), .yz = (b.x * w - b.w * x)}; }
    constexpr PlaneIdeal ProjectivePoint::antiWedge(const Quaternion& b) const noexcept { return {.x = (b.xy * y + b.xz * z), .y = (b.yz * z - b.xy * x), .z = (-b.xz * x - b.yz * y)}; }
    constexpr Plane ProjectivePoint::antiWedge(const Translator& b) const noexcept { return {.x = -b.wx * w, .y = -b.wy * w, .z = -b.wz * w, .w = (b.wx * x + b.wy * y + b.wz * z)}; }
    constexpr Bivector ProjectivePoint::antiWedge(const Vector& b) const noexcept { return {.wx = (b.z * y - b.y * z), .wy = (b.x * z - b.z * x), .wz = (b.y * x - b.x * y), .xy = b.z * w, .xz = -b.y * w, .yz = b.x * w}; }
    constexpr Bivector ProjectivePoint::antiWedge(const Point& b) const noexcept { return {.wx = (b.z * y - b.y * z), .wy = (b.x * z - b.z * x), .wz = (b.y * x - b.x * y), .xy = (-z + b.z * w), .xz = (y - b.y * w), .yz = (-x + b.x * w)}; }
    constexpr double ProjectivePoint::antiWedge(const PlaneIdeal& b) const noexcept { return (b.x * x + b.y * y + b.z * z); }
    constexpr PlaneIdeal ProjectivePoint::antiWedge(const BivectorBulk& b) const noexcept { return {.x = (b.xy * y + b.xz * z), .y = (b.yz * z - b.xy * x), .z = (-b.xz * x - b.yz * y)}; }
    constexpr Plane ProjectivePoint::antiWedge(const BivectorWeight& b) const noexcept { return {.x = -b.wx * w, .y = -b.wy * w, .z = -b.wz * w, .w = (b.wx * x + b.wy * y + b.wz * z)}; }
    constexpr ProjectivePoint ProjectivePoint::antiWedge(const PseudoScalar& b) const noexcept { return {.x = b.i * x, .y = b.i * y, .z = b.i * z, .w = b.i * w}; }
    constexpr BivectorBulk ProjectivePoint::antiWedge(const PointCenter& b) const noexcept { return {.xy = -z, .xz = y, .yz = -x}; }

    constexpr Quaternion Quaternion::antiWedge(const Motor& b) const noexcept { return {.s = (b.i * s + b.wx * yz + b.wz * xy - b.wy * xz), .xy = b.i * xy, .xz = b.i * xz, .yz = b.i * yz}; }
    constexpr double Quaternion::antiWedge(const Bivector& b) const noexcept { return (b.wx * yz + b.wz * xy - b.wy * xz); }
    constexpr PlaneIdeal Quaternion::antiWedge(const ProjectivePoint& b) const noexcept { return {.x = (b.y * xy + b.z * xz), .y = (b.z * yz - b.x * xy), .z = (-b.x * xz - b.y * yz)}; }
    constexpr double Quaternion::antiWedge(const Translator& b) const noexcept { return (b.wx * yz + b.wz * xy - b.wy * xz); }
    constexpr PlaneIdeal Quaternion::antiWedge(const Vector& b) const noexcept { return {.x = (b.y * xy + b.z * xz), .y = (b.z * yz - b.x * xy), .z = (-b.x * xz - b.y * yz)}; }
    constexpr PlaneIdeal Quaternion::antiWedge(const Point& b) const noexcept { return {.x = (b.y * xy + b.z * xz), .y = (b.z * yz - b.x * xy), .z = (-b.x * xz - b.y * yz)}; }
    constexpr double Quaternion::antiWedge(const BivectorWeight& b) const noexcept { return (b.wx * yz + b.wz * xy - b.wy * xz); }
    constexpr Quaternion Quaternion::antiWedge(const PseudoScalar& b) const noexcept { return {.s = b.i * s, .xy = b.i * xy, .xz = b.i * xz, .yz = b.i * yz}; }

    constexpr Motor Translator::antiWedge(const Motor& b) const noexcept { return {.s = (b.i + b.xy * wz + b.yz * wx - b.xz * wy), .wx = b.i * wx, .wy = b.i * wy, .wz = b.i * wz, .xy = 0.0, .xz = 0.0, .yz = 0.0, .i = 0.0}; }
    constexpr double Translator::antiWedge(const Bivector& b) const noexcept { return (b.xy * wz + b.yz * wx - b.xz * wy); }
    constexpr Plane Translator::antiWedge(const ProjectivePoint& b) const noexcept { return {.x = -b.w * wx, .y = -b.w * wy, .z = -b.w * wz, .w = (b.x * wx + b.y * wy + b.z * wz)}; }
    constexpr double Translator::antiWedge(const Quaternion& b) const noexcept { return (b.xy * wz + b.yz * wx - b.xz * wy); }
    constexpr Plane Translator::antiWedge(const Vector& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = (b.x * wx + b.y * wy + b.z * wz)}; }
    constexpr Plane Translator::antiWedge(const Point& b) const noexcept { return {.x = -wx, .y = -wy, .z = -wz, .w = (b.x * wx + b.y * wy + b.z * wz)}; }
    constexpr double Translator::antiWedge(const BivectorBulk& b) const noexcept { return (b.xy * wz + b.yz * wx - b.xz * wy); }
    constexpr Motor Translator::antiWedge(const PseudoScalar& b) const noexcept { return {.s = b.i, .wx = b.i * wx, .wy = b.i * wy, .wz = b.i * wz, .xy = 0.0, .xz = 0.0, .yz = 0.0, .i = 0.0}; }
    constexpr PlaneIdeal Translator::antiWedge(const PointCenter& b) const noexcept { return {.x = -wx, .y = -wy, .z = -wz}; }

    constexpr Multivector Vector::antiWedge(const Motor& b) const noexcept { return {.s = 0.0, .w = (b.wx * x + b.wy * y + b.wz * z), .x = (b.xy * y + b.xz * z), .y = (b.yz * z - b.xy * x), .z = (-b.xz * x - b.yz * y), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = -b.i * z, .wxz = b.i * y, .wyz = -b.i * x, .xyz = 0.0, .i = 0.0}; }
    constexpr double Vector::antiWedge(const Plane& b) const noexcept { return (b.x * x + b.y * y + b.z * z); }
    constexpr Plane Vector::antiWedge(const Bivector& b) const noexcept { return {.x = (b.xy * y + b.xz * z), .y = (b.yz * z - b.xy * x), .z = (-b.xz * x - b.yz * y), .w = (b.wx * x + b.wy * y + b.wz * z)}; }
    constexpr Bivector Vector::antiWedge(const ProjectivePoint& b) const noexcept { return {.wx = (b.z * y - b.y * z), .wy = (b.x * z - b.z * x), .wz = (b.y * x - b.x * y), .xy = -b.w * z, .xz = b.w * y, .yz = -b.w * x}; }
    constexpr PlaneIdeal Vector::antiWedge(const Quaternion& b) const noexcept { return {.x = (b.xy * y + b.xz * z), .y = (b.yz * z - b.xy * x), .z = (-b.xz * x - b.yz * y)}; }
    constexpr Plane Vector::antiWedge(const Translator& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = (b.wx * x + b.wy * y + b.wz * z)}; }
    constexpr BivectorWeight Vector::antiWedge(const Vector& b) const noexcept { return {.wx = (b.z * y - b.y * z), .wy = (b.x * z - b.z * x), .wz = (b.y * x - b.x * y)}; }
    constexpr Bivector Vector::antiWedge(const Point& b) const noexcept { return {.wx = (b.z * y - b.y * z), .wy = (b.x * z - b.z * x), .wz = (b.y * x - b.x * y), .xy = -z, .xz = y, .yz = -x}; }
    constexpr double Vector::antiWedge(const PlaneIdeal& b) const noexcept { return (b.x * x + b.y * y + b.z * z); }
    constexpr PlaneIdeal Vector::antiWedge(const BivectorBulk& b) const noexcept { return {.x = (b.xy * y + b.xz * z), .y = (b.yz * z - b.xy * x), .z = (-b.xz * x - b.yz * y)}; }
    constexpr Plane Vector::antiWedge(const BivectorWeight& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = (b.wx * x + b.wy * y + b.wz * z)}; }
    constexpr Vector Vector::antiWedge(const PseudoScalar& b) const noexcept { return {.x = b.i * x, .y = b.i * y, .z = b.i * z}; }
    constexpr BivectorBulk Vector::antiWedge(const PointCenter& b) const noexcept { return {.xy = -z, .xz = y, .yz = -x}; }

    constexpr Multivector Point::antiWedge(const Motor& b) const noexcept { return {.s = 0.0, .w = (b.wx * x + b.wy * y + b.wz * z), .x = (-b.wx + b.xy * y + b.xz * z), .y = (-b.wy + b.yz * z - b.xy * x), .z = (-b.wz - b.xz * x - b.yz * y), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = -b.i * z, .wxz = b.i * y, .wyz = -b.i * x, .xyz = b.i, .i = 0.0}; }
    constexpr double Point::antiWedge(const Plane& b) const noexcept { return (b.w + b.x * x + b.y * y + b.z * z); }
    constexpr Plane Point::antiWedge(const Bivector& b) const noexcept { return {.x = (-b.wx + b.xy * y + b.xz * z), .y = (-b.wy + b.yz * z - b.xy * x), .z = (-b.wz - b.xz * x - b.yz * y), .w = (b.wx * x + b.wy * y + b.wz * z)}; }
    constexpr Bivector Point::antiWedge(const ProjectivePoint& b) const noexcept { return {.wx = (b.z * y - b.y * z), .wy = (b.x * z - b.z * x), .wz = (b.y * x - b.x * y), .xy = (b.z - b.w * z), .xz = (-b.y + b.w * y), .yz = (b.x - b.w * x)}; }
    constexpr PlaneIdeal Point::antiWedge(const Quaternion& b) const noexcept { return {.x = (b.xy * y + b.xz * z), .y = (b.yz * z - b.xy * x), .z = (-b.xz * x - b.yz * y)}; }
    constexpr Plane Point::antiWedge(const Translator& b) const noexcept { return {.x = -b.wx, .y = -b.wy, .z = -b.wz, .w = (b.wx * x + b.wy * y + b.wz * z)}; }
    constexpr Bivector Point::antiWedge(const Vector& b) const noexcept { return {.wx = (b.z * y - b.y * z), .wy = (b.x * z - b.z * x), .wz = (b.y * x - b.x * y), .xy = b.z, .xz = -b.y, .yz = b.x}; }
    constexpr Bivector Point::antiWedge(const Point& b) const noexcept { return {.wx = (b.z * y - b.y * z), .wy = (b.x * z - b.z * x), .wz = (b.y * x - b.x * y), .xy = (b.z - z), .xz = (y - b.y), .yz = (b.x - x)}; }
    constexpr double Point::antiWedge(const PlaneIdeal& b) const noexcept { return (b.x * x + b.y * y + b.z * z); }
    constexpr PlaneIdeal Point::antiWedge(const BivectorBulk& b) const noexcept { return {.x = (b.xy * y + b.xz * z), .y = (b.yz * z - b.xy * x), .z = (-b.xz * x - b.yz * y)}; }
    constexpr Plane Point::antiWedge(const BivectorWeight& b) const noexcept { return {.x = -b.wx, .y = -b.wy, .z = -b.wz, .w = (b.wx * x + b.wy * y + b.wz * z)}; }
    constexpr ProjectivePoint Point::antiWedge(const PseudoScalar& b) const noexcept { return {.x = b.i * x, .y = b.i * y, .z = b.i * z, .w = b.i}; }
    constexpr BivectorBulk Point::antiWedge(const PointCenter& b) const noexcept { return {.xy = -z, .xz = y, .yz = -x}; }

    constexpr PlaneIdeal PlaneIdeal::antiWedge(const Motor& b) const noexcept { return {.x = b.i * x, .y = b.i * y, .z = b.i * z}; }
    constexpr double PlaneIdeal::antiWedge(const ProjectivePoint& b) const noexcept { return (-b.x * x - b.y * y - b.z * z); }
    constexpr double PlaneIdeal::antiWedge(const Vector& b) const noexcept { return (-b.x * x - b.y * y - b.z * z); }
    constexpr double PlaneIdeal::antiWedge(const Point& b) const noexcept { return (-b.x * x - b.y * y - b.z * z); }
    constexpr PlaneIdeal PlaneIdeal::antiWedge(const PseudoScalar& b) const noexcept { return {.x = b.i * x, .y = b.i * y, .z = b.i * z}; }

    constexpr Quaternion BivectorBulk::antiWedge(const Motor& b) const noexcept { return {.s = (b.wx * yz + b.wz * xy - b.wy * xz), .xy = b.i * xy, .xz = b.i * xz, .yz = b.i * yz}; }
    constexpr double BivectorBulk::antiWedge(const Bivector& b) const noexcept { return (b.wx * yz + b.wz * xy - b.wy * xz); }
    constexpr PlaneIdeal BivectorBulk::antiWedge(const ProjectivePoint& b) const noexcept { return {.x = (b.y * xy + b.z * xz), .y = (b.z * yz - b.x * xy), .z = (-b.x * xz - b.y * yz)}; }
    constexpr double BivectorBulk::antiWedge(const Translator& b) const noexcept { return (b.wx * yz + b.wz * xy - b.wy * xz); }
    constexpr PlaneIdeal BivectorBulk::antiWedge(const Vector& b) const noexcept { return {.x = (b.y * xy + b.z * xz), .y = (b.z * yz - b.x * xy), .z = (-b.x * xz - b.y * yz)}; }
    constexpr PlaneIdeal BivectorBulk::antiWedge(const Point& b) const noexcept { return {.x = (b.y * xy + b.z * xz), .y = (b.z * yz - b.x * xy), .z = (-b.x * xz - b.y * yz)}; }
    constexpr double BivectorBulk::antiWedge(const BivectorWeight& b) const noexcept { return (b.wx * yz + b.wz * xy - b.wy * xz); }
    constexpr BivectorBulk BivectorBulk::antiWedge(const PseudoScalar& b) const noexcept { return {.xy = b.i * xy, .xz = b.i * xz, .yz = b.i * yz}; }

    constexpr Motor BivectorWeight::antiWedge(const Motor& b) const noexcept { return {.s = (b.xy * wz + b.yz * wx - b.xz * wy), .wx = b.i * wx, .wy = b.i * wy, .wz = b.i * wz, .xy = 0.0, .xz = 0.0, .yz = 0.0, .i = 0.0}; }
    constexpr double BivectorWeight::antiWedge(const Bivector& b) const noexcept { return (b.xy * wz + b.yz * wx - b.xz * wy); }
    constexpr Plane BivectorWeight::antiWedge(const ProjectivePoint& b) const noexcept { return {.x = -b.w * wx, .y = -b.w * wy, .z = -b.w * wz, .w = (b.x * wx + b.y * wy + b.z * wz)}; }
    constexpr double BivectorWeight::antiWedge(const Quaternion& b) const noexcept { return (b.xy * wz + b.yz * wx - b.xz * wy); }
    constexpr Plane BivectorWeight::antiWedge(const Vector& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = (b.x * wx + b.y * wy + b.z * wz)}; }
    constexpr Plane BivectorWeight::antiWedge(const Point& b) const noexcept { return {.x = -wx, .y = -wy, .z = -wz, .w = (b.x * wx + b.y * wy + b.z * wz)}; }
    constexpr double BivectorWeight::antiWedge(const BivectorBulk& b) const noexcept { return (b.xy * wz + b.yz * wx - b.xz * wy); }
    constexpr BivectorWeight BivectorWeight::antiWedge(const PseudoScalar& b) const noexcept { return {.wx = b.i * wx, .wy = b.i * wy, .wz = b.i * wz}; }
    constexpr PlaneIdeal BivectorWeight::antiWedge(const PointCenter& b) const noexcept { return {.x = -wx, .y = -wy, .z = -wz}; }

    constexpr Motor PseudoScalar::antiWedge(const Motor& b) const noexcept { return {.s = b.s * i, .wx = b.wx * i, .wy = b.wy * i, .wz = b.wz * i, .xy = b.xy * i, .xz = b.xz * i, .yz = b.yz * i, .i = b.i * i}; }
    constexpr Plane PseudoScalar::antiWedge(const Plane& b) const noexcept { return {.x = b.x * i, .y = b.y * i, .z = b.z * i, .w = b.w * i}; }
    constexpr Bivector PseudoScalar::antiWedge(const Bivector& b) const noexcept { return {.wx = b.wx * i, .wy = b.wy * i, .wz = b.wz * i, .xy = b.xy * i, .xz = b.xz * i, .yz = b.yz * i}; }
    constexpr ProjectivePoint PseudoScalar::antiWedge(const ProjectivePoint& b) const noexcept { return {.x = b.x * i, .y = b.y * i, .z = b.z * i, .w = b.w * i}; }
    constexpr Quaternion PseudoScalar::antiWedge(const Quaternion& b) const noexcept { return {.s = b.s * i, .xy = b.xy * i, .xz = b.xz * i, .yz = b.yz * i}; }
    constexpr Motor PseudoScalar::antiWedge(const Translator& b) const noexcept { return {.s = i, .wx = b.wx * i, .wy = b.wy * i, .wz = b.wz * i, .xy = 0.0, .xz = 0.0, .yz = 0.0, .i = 0.0}; }
    constexpr Vector PseudoScalar::antiWedge(const Vector& b) const noexcept { return {.x = b.x * i, .y = b.y * i, .z = b.z * i}; }
    constexpr ProjectivePoint PseudoScalar::antiWedge(const Point& b) const noexcept { return {.x = b.x * i, .y = b.y * i, .z = b.z * i, .w = i}; }
    constexpr PlaneIdeal PseudoScalar::antiWedge(const PlaneIdeal& b) const noexcept { return {.x = b.x * i, .y = b.y * i, .z = b.z * i}; }
    constexpr BivectorBulk PseudoScalar::antiWedge(const BivectorBulk& b) const noexcept { return {.xy = b.xy * i, .xz = b.xz * i, .yz = b.yz * i}; }
    constexpr BivectorWeight PseudoScalar::antiWedge(const BivectorWeight& b) const noexcept { return {.wx = b.wx * i, .wy = b.wy * i, .wz = b.wz * i}; }
    constexpr PseudoScalar PseudoScalar::antiWedge(const PseudoScalar& b) const noexcept { return {.i = b.i * i}; }
    constexpr ProjectivePoint PseudoScalar::antiWedge(const PointCenter& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = i}; }

    constexpr Multivector PointCenter::antiWedge(const Motor& b) const noexcept { return {.s = 0.0, .w = 0.0, .x = -b.wx, .y = -b.wy, .z = -b.wz, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = 0.0, .wxz = 0.0, .wyz = 0.0, .xyz = b.i, .i = 0.0}; }
    constexpr double PointCenter::antiWedge(const Plane& b) const noexcept { return b.w; }
    constexpr PlaneIdeal PointCenter::antiWedge(const Bivector& b) const noexcept { return {.x = -b.wx, .y = -b.wy, .z = -b.wz}; }
    constexpr BivectorBulk PointCenter::antiWedge(const ProjectivePoint& b) const noexcept { return {.xy = b.z, .xz = -b.y, .yz = b.x}; }
    constexpr PlaneIdeal PointCenter::antiWedge(const Translator& b) const noexcept { return {.x = -b.wx, .y = -b.wy, .z = -b.wz}; }
    constexpr BivectorBulk PointCenter::antiWedge(const Vector& b) const noexcept { return {.xy = b.z, .xz = -b.y, .yz = b.x}; }
    constexpr BivectorBulk PointCenter::antiWedge(const Point& b) const noexcept { return {.xy = b.z, .xz = -b.y, .yz = b.x}; }
    constexpr PlaneIdeal PointCenter::antiWedge(const BivectorWeight& b) const noexcept { return {.x = -b.wx, .y = -b.wy, .z = -b.wz}; }
    constexpr ProjectivePoint PointCenter::antiWedge(const PseudoScalar& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = b.i}; }

}