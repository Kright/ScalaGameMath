#pragma once

#include <cmath>
#include "types.h"
#include "opsArithmetic.h"

// generated by com.github.kright.pga3d.codegen.cpp.binops.MotorOpsGenerator

namespace pga3d {

    [[nodiscard]] constexpr Motor Motor::addVector(const Vector& v) noexcept { return {.s = 1.0, .wx = v.x, .wy = v.y, .wz = v.z}; }

    [[nodiscard]] inline Bivector Motor::log() const noexcept {
        const double scalar = s;
        if (s < 0.0) return (-(*this)).log();

        const double lenXYZ = std::sqrt(xy * xy + xz * xz + yz * yz);
        const double angle = std::atan2(lenXYZ, scalar);

        // 1 / sin^2
        const double a = 1.0 / (1.0 - scalar * scalar);

        // angle / sin(angle)
        const double b = (std::abs(angle) > 1e-5)
            ? (angle * std::sqrt(a))
            : (1.0 + angle * angle / 6.0);

        const double c = (std::abs(angle) > 1e-5)
            ? (a * i * (1.0 - scalar * b))
            : ((1.0 + angle * angle / 2.0) * i / 3.0);

        return Bivector {
            .wx = (b * wx + c * yz),
            .wy = (b * wy - c * xz),
            .wz = (b * wz + c * xy),
            .xy = b * xy,
            .xz = b * xz,
            .yz = b * yz,
        };
    }

    [[nodiscard]] inline Motor Motor::pow(double p) const noexcept {
       return (log() * p).exp();
    }

    [[nodiscard]] constexpr std::pair<Quaternion, Translator> Motor::toQuaternionAndTranslator() const noexcept {
        const Quaternion q = toQuaternionUnsafe();
        const Motor t = q.reverse().geometric(*this);
        return { q, t.toTranslatorUnsafe() };
    }

    [[nodiscard]] constexpr std::pair<Translator, Quaternion> Motor::toTranslatorAndQuaternion() const noexcept {
        const Quaternion q = toQuaternionUnsafe();
        const Motor t = geometric(q.reverse());
        return { t.toTranslatorUnsafe(), q };
    }

    /**
     * see [[https://arxiv.org/abs/2206.07496]], page 14
     * and [[https://https://bivector.net/PGAdyn.pdf.net/PGAdyn.pdf]], page 42
     */
    [[nodiscard]] inline Motor Motor::renormalized() const noexcept {
        const double a2 = 1.0 / (s * s + xy * xy + xz * xz + yz * yz);
        const double a = std::sqrt(a2);
        const double b = (s * i - wx * yz + wy * xz - wz * xy) * a * a2;
        return Motor {
            .s = a * s,
            .wx = a * wx + b * yz,
            .wy = a * wy - b * xz,
            .wz = a * wz + b * xy,
            .xy = a * xy,
            .xz = a * xz,
            .yz = a * yz,
            .i = a * i - b * s,
        };
    }

    [[nodiscard]] constexpr Vector Motor::axisX() const noexcept { return toQuaternionUnsafe().axisX(); }
    [[nodiscard]] constexpr Vector Motor::axisY() const noexcept { return toQuaternionUnsafe().axisY(); }
    [[nodiscard]] constexpr Vector Motor::axisZ() const noexcept { return toQuaternionUnsafe().axisZ(); }
}