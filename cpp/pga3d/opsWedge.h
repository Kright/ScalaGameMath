// Copyright (c) 2025 Igor Slobodskov
// SPDX-License-Identifier: MIT

#pragma once

#include "types.h"

// generated by com.github.kright.pga3d.codegen.cpp.ops.WedgeOpGenerator

namespace pga3d {
    constexpr Multivector Multivector::wedge(const Multivector& b) const noexcept { return {
        .s = b.s * s,
        .w = (b.s * w + b.w * s),
        .x = (b.s * x + b.x * s),
        .y = (b.s * y + b.y * s),
        .z = (b.s * z + b.z * s),
        .wx = (b.s * wx + b.wx * s + b.x * w - b.w * x),
        .wy = (b.s * wy + b.wy * s + b.y * w - b.w * y),
        .wz = (b.s * wz + b.wz * s + b.z * w - b.w * z),
        .xy = (b.s * xy + b.xy * s + b.y * x - b.x * y),
        .xz = (b.s * xz + b.xz * s + b.z * x - b.x * z),
        .yz = (b.s * yz + b.yz * s + b.z * y - b.y * z),
        .wxy = (b.s * wxy + b.w * xy + b.wx * y + b.wxy * s + b.xy * w + b.y * wx - b.wy * x - b.x * wy),
        .wxz = (b.s * wxz + b.w * xz + b.wx * z + b.wxz * s + b.xz * w + b.z * wx - b.wz * x - b.x * wz),
        .wyz = (b.s * wyz + b.w * yz + b.wy * z + b.wyz * s + b.yz * w + b.z * wy - b.wz * y - b.y * wz),
        .xyz = (b.s * xyz + b.x * yz + b.xy * z + b.xyz * s + b.yz * x + b.z * xy - b.xz * y - b.y * xz),
        .i = (b.i * s + b.s * i + b.wx * yz + b.wxz * y + b.wz * xy + b.x * wyz + b.xy * wz + b.xyz * w + b.yz * wx + b.z * wxy - b.w * xyz - b.wxy * z - b.wy * xz - b.wyz * x - b.xz * wy - b.y * wxz)
    }; }
    constexpr Multivector Multivector::meet(const Multivector& b) const noexcept { return wedge(b); }


    constexpr Motor Motor::wedge(const Motor& b) const noexcept { return {
        .s = b.s * s,
        .wx = (b.s * wx + b.wx * s),
        .wy = (b.s * wy + b.wy * s),
        .wz = (b.s * wz + b.wz * s),
        .xy = (b.s * xy + b.xy * s),
        .xz = (b.s * xz + b.xz * s),
        .yz = (b.s * yz + b.yz * s),
        .i = (b.i * s + b.s * i + b.wx * yz + b.wz * xy + b.xy * wz + b.yz * wx - b.wy * xz - b.xz * wy)
    }; }
    constexpr Motor Motor::meet(const Motor& b) const noexcept { return wedge(b); }

    constexpr Multivector Motor::wedge(const Plane& b) const noexcept { return {
        .s = 0.0,
        .w = b.w * s,
        .x = b.x * s,
        .y = b.y * s,
        .z = b.z * s,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (b.w * xy + b.y * wx - b.x * wy),
        .wxz = (b.w * xz + b.z * wx - b.x * wz),
        .wyz = (b.w * yz + b.z * wy - b.y * wz),
        .xyz = (b.x * yz + b.z * xy - b.y * xz),
        .i = 0.0
    }; }
    constexpr Multivector Motor::meet(const Plane& b) const noexcept { return wedge(b); }

    constexpr Motor Motor::wedge(const Bivector& b) const noexcept { return {
        .s = 0.0,
        .wx = b.wx * s,
        .wy = b.wy * s,
        .wz = b.wz * s,
        .xy = b.xy * s,
        .xz = b.xz * s,
        .yz = b.yz * s,
        .i = (b.wx * yz + b.wz * xy + b.xy * wz + b.yz * wx - b.wy * xz - b.xz * wy)
    }; }
    constexpr Motor Motor::meet(const Bivector& b) const noexcept { return wedge(b); }

    constexpr ProjectivePoint Motor::wedge(const ProjectivePoint& b) const noexcept { return {
        .x = b.x * s,
        .y = b.y * s,
        .z = b.z * s,
        .w = b.w * s
    }; }
    constexpr ProjectivePoint Motor::meet(const ProjectivePoint& b) const noexcept { return wedge(b); }

    constexpr Motor Motor::wedge(const Quaternion& b) const noexcept { return {
        .s = b.s * s,
        .wx = b.s * wx,
        .wy = b.s * wy,
        .wz = b.s * wz,
        .xy = (b.s * xy + b.xy * s),
        .xz = (b.s * xz + b.xz * s),
        .yz = (b.s * yz + b.yz * s),
        .i = (b.s * i + b.xy * wz + b.yz * wx - b.xz * wy)
    }; }
    constexpr Motor Motor::meet(const Quaternion& b) const noexcept { return wedge(b); }

    constexpr Motor Motor::wedge(const ProjectiveTranslator& b) const noexcept { return {
        .s = b.s * s,
        .wx = (b.s * wx + b.wx * s),
        .wy = (b.s * wy + b.wy * s),
        .wz = (b.s * wz + b.wz * s),
        .xy = b.s * xy,
        .xz = b.s * xz,
        .yz = b.s * yz,
        .i = (b.s * i + b.wx * yz + b.wz * xy - b.wy * xz)
    }; }
    constexpr Motor Motor::meet(const ProjectiveTranslator& b) const noexcept { return wedge(b); }

    constexpr Motor Motor::wedge(const Translator& b) const noexcept { return {
        .s = s,
        .wx = (wx + b.wx * s),
        .wy = (wy + b.wy * s),
        .wz = (wz + b.wz * s),
        .xy = xy,
        .xz = xz,
        .yz = yz,
        .i = (i + b.wx * yz + b.wz * xy - b.wy * xz)
    }; }
    constexpr Motor Motor::meet(const Translator& b) const noexcept { return wedge(b); }

    constexpr Vector Motor::wedge(const Vector& b) const noexcept { return {
        .x = b.x * s,
        .y = b.y * s,
        .z = b.z * s
    }; }
    constexpr Vector Motor::meet(const Vector& b) const noexcept { return wedge(b); }

    constexpr ProjectivePoint Motor::wedge(const Point& b) const noexcept { return {
        .x = b.x * s,
        .y = b.y * s,
        .z = b.z * s,
        .w = s
    }; }
    constexpr ProjectivePoint Motor::meet(const Point& b) const noexcept { return wedge(b); }

    constexpr Multivector Motor::wedge(const PlaneIdeal& b) const noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = b.x * s,
        .y = b.y * s,
        .z = b.z * s,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (b.y * wx - b.x * wy),
        .wxz = (b.z * wx - b.x * wz),
        .wyz = (b.z * wy - b.y * wz),
        .xyz = (b.x * yz + b.z * xy - b.y * xz),
        .i = 0.0
    }; }
    constexpr Multivector Motor::meet(const PlaneIdeal& b) const noexcept { return wedge(b); }

    constexpr Motor Motor::wedge(const BivectorBulk& b) const noexcept { return {
        .s = 0.0,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = b.xy * s,
        .xz = b.xz * s,
        .yz = b.yz * s,
        .i = (b.xy * wz + b.yz * wx - b.xz * wy)
    }; }
    constexpr Motor Motor::meet(const BivectorBulk& b) const noexcept { return wedge(b); }

    constexpr Motor Motor::wedge(const BivectorWeight& b) const noexcept { return {
        .s = 0.0,
        .wx = b.wx * s,
        .wy = b.wy * s,
        .wz = b.wz * s,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .i = (b.wx * yz + b.wz * xy - b.wy * xz)
    }; }
    constexpr Motor Motor::meet(const BivectorWeight& b) const noexcept { return wedge(b); }

    constexpr PseudoScalar Motor::wedge(const PseudoScalar& b) const noexcept { return {
        .i = b.i * s
    }; }
    constexpr PseudoScalar Motor::meet(const PseudoScalar& b) const noexcept { return wedge(b); }

    constexpr ProjectivePoint Motor::wedge(const PointCenter& b) const noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = s
    }; }
    constexpr ProjectivePoint Motor::meet(const PointCenter& b) const noexcept { return wedge(b); }


    constexpr Multivector Plane::wedge(const Motor& b) const noexcept { return {
        .s = 0.0,
        .w = b.s * w,
        .x = b.s * x,
        .y = b.s * y,
        .z = b.s * z,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (b.wx * y + b.xy * w - b.wy * x),
        .wxz = (b.wx * z + b.xz * w - b.wz * x),
        .wyz = (b.wy * z + b.yz * w - b.wz * y),
        .xyz = (b.xy * z + b.yz * x - b.xz * y),
        .i = 0.0
    }; }
    constexpr Multivector Plane::meet(const Motor& b) const noexcept { return wedge(b); }

    constexpr Bivector Plane::wedge(const Plane& b) const noexcept { return {
        .wx = (b.x * w - b.w * x),
        .wy = (b.y * w - b.w * y),
        .wz = (b.z * w - b.w * z),
        .xy = (b.y * x - b.x * y),
        .xz = (b.z * x - b.x * z),
        .yz = (b.z * y - b.y * z)
    }; }
    constexpr Bivector Plane::meet(const Plane& b) const noexcept { return wedge(b); }

    constexpr ProjectivePoint Plane::wedge(const Bivector& b) const noexcept { return {
        .x = (b.wz * y - b.wy * z - b.yz * w),
        .y = (b.wx * z + b.xz * w - b.wz * x),
        .z = (b.wy * x - b.wx * y - b.xy * w),
        .w = (b.xy * z + b.yz * x - b.xz * y)
    }; }
    constexpr ProjectivePoint Plane::meet(const Bivector& b) const noexcept { return wedge(b); }

    constexpr PseudoScalar Plane::wedge(const ProjectivePoint& b) const noexcept { return {
        .i = (b.w * w + b.x * x + b.y * y + b.z * z)
    }; }
    constexpr PseudoScalar Plane::meet(const ProjectivePoint& b) const noexcept { return wedge(b); }

    constexpr Multivector Plane::wedge(const Quaternion& b) const noexcept { return {
        .s = 0.0,
        .w = b.s * w,
        .x = b.s * x,
        .y = b.s * y,
        .z = b.s * z,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = b.xy * w,
        .wxz = b.xz * w,
        .wyz = b.yz * w,
        .xyz = (b.xy * z + b.yz * x - b.xz * y),
        .i = 0.0
    }; }
    constexpr Multivector Plane::meet(const Quaternion& b) const noexcept { return wedge(b); }

    constexpr Multivector Plane::wedge(const ProjectiveTranslator& b) const noexcept { return {
        .s = 0.0,
        .w = b.s * w,
        .x = b.s * x,
        .y = b.s * y,
        .z = b.s * z,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (b.wx * y - b.wy * x),
        .wxz = (b.wx * z - b.wz * x),
        .wyz = (b.wy * z - b.wz * y),
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector Plane::meet(const ProjectiveTranslator& b) const noexcept { return wedge(b); }

    constexpr Multivector Plane::wedge(const Translator& b) const noexcept { return {
        .s = 0.0,
        .w = w,
        .x = x,
        .y = y,
        .z = z,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (b.wx * y - b.wy * x),
        .wxz = (b.wx * z - b.wz * x),
        .wyz = (b.wy * z - b.wz * y),
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector Plane::meet(const Translator& b) const noexcept { return wedge(b); }

    constexpr PseudoScalar Plane::wedge(const Vector& b) const noexcept { return {
        .i = (b.x * x + b.y * y + b.z * z)
    }; }
    constexpr PseudoScalar Plane::meet(const Vector& b) const noexcept { return wedge(b); }

    constexpr PseudoScalar Plane::wedge(const Point& b) const noexcept { return {
        .i = (w + b.x * x + b.y * y + b.z * z)
    }; }
    constexpr PseudoScalar Plane::meet(const Point& b) const noexcept { return wedge(b); }

    constexpr Bivector Plane::wedge(const PlaneIdeal& b) const noexcept { return {
        .wx = b.x * w,
        .wy = b.y * w,
        .wz = b.z * w,
        .xy = (b.y * x - b.x * y),
        .xz = (b.z * x - b.x * z),
        .yz = (b.z * y - b.y * z)
    }; }
    constexpr Bivector Plane::meet(const PlaneIdeal& b) const noexcept { return wedge(b); }

    constexpr ProjectivePoint Plane::wedge(const BivectorBulk& b) const noexcept { return {
        .x = -b.yz * w,
        .y = b.xz * w,
        .z = -b.xy * w,
        .w = (b.xy * z + b.yz * x - b.xz * y)
    }; }
    constexpr ProjectivePoint Plane::meet(const BivectorBulk& b) const noexcept { return wedge(b); }

    constexpr Vector Plane::wedge(const BivectorWeight& b) const noexcept { return {
        .x = (b.wz * y - b.wy * z),
        .y = (b.wx * z - b.wz * x),
        .z = (b.wy * x - b.wx * y)
    }; }
    constexpr Vector Plane::meet(const BivectorWeight& b) const noexcept { return wedge(b); }

    constexpr PseudoScalar Plane::wedge(const PointCenter& b) const noexcept { return {
        .i = w
    }; }
    constexpr PseudoScalar Plane::meet(const PointCenter& b) const noexcept { return wedge(b); }


    constexpr Motor Bivector::wedge(const Motor& b) const noexcept { return {
        .s = 0.0,
        .wx = b.s * wx,
        .wy = b.s * wy,
        .wz = b.s * wz,
        .xy = b.s * xy,
        .xz = b.s * xz,
        .yz = b.s * yz,
        .i = (b.wx * yz + b.wz * xy + b.xy * wz + b.yz * wx - b.wy * xz - b.xz * wy)
    }; }
    constexpr Motor Bivector::meet(const Motor& b) const noexcept { return wedge(b); }

    constexpr ProjectivePoint Bivector::wedge(const Plane& b) const noexcept { return {
        .x = (b.y * wz - b.w * yz - b.z * wy),
        .y = (b.w * xz + b.z * wx - b.x * wz),
        .z = (b.x * wy - b.w * xy - b.y * wx),
        .w = (b.x * yz + b.z * xy - b.y * xz)
    }; }
    constexpr ProjectivePoint Bivector::meet(const Plane& b) const noexcept { return wedge(b); }

    constexpr PseudoScalar Bivector::wedge(const Bivector& b) const noexcept { return {
        .i = (b.wx * yz + b.wz * xy + b.xy * wz + b.yz * wx - b.wy * xz - b.xz * wy)
    }; }
    constexpr PseudoScalar Bivector::meet(const Bivector& b) const noexcept { return wedge(b); }

    constexpr Motor Bivector::wedge(const Quaternion& b) const noexcept { return {
        .s = 0.0,
        .wx = b.s * wx,
        .wy = b.s * wy,
        .wz = b.s * wz,
        .xy = b.s * xy,
        .xz = b.s * xz,
        .yz = b.s * yz,
        .i = (b.xy * wz + b.yz * wx - b.xz * wy)
    }; }
    constexpr Motor Bivector::meet(const Quaternion& b) const noexcept { return wedge(b); }

    constexpr Motor Bivector::wedge(const ProjectiveTranslator& b) const noexcept { return {
        .s = 0.0,
        .wx = b.s * wx,
        .wy = b.s * wy,
        .wz = b.s * wz,
        .xy = b.s * xy,
        .xz = b.s * xz,
        .yz = b.s * yz,
        .i = (b.wx * yz + b.wz * xy - b.wy * xz)
    }; }
    constexpr Motor Bivector::meet(const ProjectiveTranslator& b) const noexcept { return wedge(b); }

    constexpr Motor Bivector::wedge(const Translator& b) const noexcept { return {
        .s = 0.0,
        .wx = wx,
        .wy = wy,
        .wz = wz,
        .xy = xy,
        .xz = xz,
        .yz = yz,
        .i = (b.wx * yz + b.wz * xy - b.wy * xz)
    }; }
    constexpr Motor Bivector::meet(const Translator& b) const noexcept { return wedge(b); }

    constexpr ProjectivePoint Bivector::wedge(const PlaneIdeal& b) const noexcept { return {
        .x = (b.y * wz - b.z * wy),
        .y = (b.z * wx - b.x * wz),
        .z = (b.x * wy - b.y * wx),
        .w = (b.x * yz + b.z * xy - b.y * xz)
    }; }
    constexpr ProjectivePoint Bivector::meet(const PlaneIdeal& b) const noexcept { return wedge(b); }

    constexpr PseudoScalar Bivector::wedge(const BivectorBulk& b) const noexcept { return {
        .i = (b.xy * wz + b.yz * wx - b.xz * wy)
    }; }
    constexpr PseudoScalar Bivector::meet(const BivectorBulk& b) const noexcept { return wedge(b); }

    constexpr PseudoScalar Bivector::wedge(const BivectorWeight& b) const noexcept { return {
        .i = (b.wx * yz + b.wz * xy - b.wy * xz)
    }; }
    constexpr PseudoScalar Bivector::meet(const BivectorWeight& b) const noexcept { return wedge(b); }


    constexpr ProjectivePoint ProjectivePoint::wedge(const Motor& b) const noexcept { return {
        .x = b.s * x,
        .y = b.s * y,
        .z = b.s * z,
        .w = b.s * w
    }; }
    constexpr ProjectivePoint ProjectivePoint::meet(const Motor& b) const noexcept { return wedge(b); }

    constexpr PseudoScalar ProjectivePoint::wedge(const Plane& b) const noexcept { return {
        .i = (-b.w * w - b.x * x - b.y * y - b.z * z)
    }; }
    constexpr PseudoScalar ProjectivePoint::meet(const Plane& b) const noexcept { return wedge(b); }

    constexpr ProjectivePoint ProjectivePoint::wedge(const Quaternion& b) const noexcept { return {
        .x = b.s * x,
        .y = b.s * y,
        .z = b.s * z,
        .w = b.s * w
    }; }
    constexpr ProjectivePoint ProjectivePoint::meet(const Quaternion& b) const noexcept { return wedge(b); }

    constexpr ProjectivePoint ProjectivePoint::wedge(const ProjectiveTranslator& b) const noexcept { return {
        .x = b.s * x,
        .y = b.s * y,
        .z = b.s * z,
        .w = b.s * w
    }; }
    constexpr ProjectivePoint ProjectivePoint::meet(const ProjectiveTranslator& b) const noexcept { return wedge(b); }

    constexpr ProjectivePoint ProjectivePoint::wedge(const Translator& b) const noexcept { return {
        .x = x,
        .y = y,
        .z = z,
        .w = w
    }; }
    constexpr ProjectivePoint ProjectivePoint::meet(const Translator& b) const noexcept { return wedge(b); }

    constexpr PseudoScalar ProjectivePoint::wedge(const PlaneIdeal& b) const noexcept { return {
        .i = (-b.x * x - b.y * y - b.z * z)
    }; }
    constexpr PseudoScalar ProjectivePoint::meet(const PlaneIdeal& b) const noexcept { return wedge(b); }


    constexpr Motor Quaternion::wedge(const Motor& b) const noexcept { return {
        .s = b.s * s,
        .wx = b.wx * s,
        .wy = b.wy * s,
        .wz = b.wz * s,
        .xy = (b.s * xy + b.xy * s),
        .xz = (b.s * xz + b.xz * s),
        .yz = (b.s * yz + b.yz * s),
        .i = (b.i * s + b.wx * yz + b.wz * xy - b.wy * xz)
    }; }
    constexpr Motor Quaternion::meet(const Motor& b) const noexcept { return wedge(b); }

    constexpr Multivector Quaternion::wedge(const Plane& b) const noexcept { return {
        .s = 0.0,
        .w = b.w * s,
        .x = b.x * s,
        .y = b.y * s,
        .z = b.z * s,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = b.w * xy,
        .wxz = b.w * xz,
        .wyz = b.w * yz,
        .xyz = (b.x * yz + b.z * xy - b.y * xz),
        .i = 0.0
    }; }
    constexpr Multivector Quaternion::meet(const Plane& b) const noexcept { return wedge(b); }

    constexpr Motor Quaternion::wedge(const Bivector& b) const noexcept { return {
        .s = 0.0,
        .wx = b.wx * s,
        .wy = b.wy * s,
        .wz = b.wz * s,
        .xy = b.xy * s,
        .xz = b.xz * s,
        .yz = b.yz * s,
        .i = (b.wx * yz + b.wz * xy - b.wy * xz)
    }; }
    constexpr Motor Quaternion::meet(const Bivector& b) const noexcept { return wedge(b); }

    constexpr ProjectivePoint Quaternion::wedge(const ProjectivePoint& b) const noexcept { return {
        .x = b.x * s,
        .y = b.y * s,
        .z = b.z * s,
        .w = b.w * s
    }; }
    constexpr ProjectivePoint Quaternion::meet(const ProjectivePoint& b) const noexcept { return wedge(b); }

    constexpr Quaternion Quaternion::wedge(const Quaternion& b) const noexcept { return {
        .s = b.s * s,
        .xy = (b.s * xy + b.xy * s),
        .xz = (b.s * xz + b.xz * s),
        .yz = (b.s * yz + b.yz * s)
    }; }
    constexpr Quaternion Quaternion::meet(const Quaternion& b) const noexcept { return wedge(b); }

    constexpr Motor Quaternion::wedge(const ProjectiveTranslator& b) const noexcept { return {
        .s = b.s * s,
        .wx = b.wx * s,
        .wy = b.wy * s,
        .wz = b.wz * s,
        .xy = b.s * xy,
        .xz = b.s * xz,
        .yz = b.s * yz,
        .i = (b.wx * yz + b.wz * xy - b.wy * xz)
    }; }
    constexpr Motor Quaternion::meet(const ProjectiveTranslator& b) const noexcept { return wedge(b); }

    constexpr Motor Quaternion::wedge(const Translator& b) const noexcept { return {
        .s = s,
        .wx = b.wx * s,
        .wy = b.wy * s,
        .wz = b.wz * s,
        .xy = xy,
        .xz = xz,
        .yz = yz,
        .i = (b.wx * yz + b.wz * xy - b.wy * xz)
    }; }
    constexpr Motor Quaternion::meet(const Translator& b) const noexcept { return wedge(b); }

    constexpr Vector Quaternion::wedge(const Vector& b) const noexcept { return {
        .x = b.x * s,
        .y = b.y * s,
        .z = b.z * s
    }; }
    constexpr Vector Quaternion::meet(const Vector& b) const noexcept { return wedge(b); }

    constexpr ProjectivePoint Quaternion::wedge(const Point& b) const noexcept { return {
        .x = b.x * s,
        .y = b.y * s,
        .z = b.z * s,
        .w = s
    }; }
    constexpr ProjectivePoint Quaternion::meet(const Point& b) const noexcept { return wedge(b); }

    constexpr Multivector Quaternion::wedge(const PlaneIdeal& b) const noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = b.x * s,
        .y = b.y * s,
        .z = b.z * s,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = 0.0,
        .wxz = 0.0,
        .wyz = 0.0,
        .xyz = (b.x * yz + b.z * xy - b.y * xz),
        .i = 0.0
    }; }
    constexpr Multivector Quaternion::meet(const PlaneIdeal& b) const noexcept { return wedge(b); }

    constexpr BivectorBulk Quaternion::wedge(const BivectorBulk& b) const noexcept { return {
        .xy = b.xy * s,
        .xz = b.xz * s,
        .yz = b.yz * s
    }; }
    constexpr BivectorBulk Quaternion::meet(const BivectorBulk& b) const noexcept { return wedge(b); }

    constexpr Motor Quaternion::wedge(const BivectorWeight& b) const noexcept { return {
        .s = 0.0,
        .wx = b.wx * s,
        .wy = b.wy * s,
        .wz = b.wz * s,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .i = (b.wx * yz + b.wz * xy - b.wy * xz)
    }; }
    constexpr Motor Quaternion::meet(const BivectorWeight& b) const noexcept { return wedge(b); }

    constexpr PseudoScalar Quaternion::wedge(const PseudoScalar& b) const noexcept { return {
        .i = b.i * s
    }; }
    constexpr PseudoScalar Quaternion::meet(const PseudoScalar& b) const noexcept { return wedge(b); }

    constexpr ProjectivePoint Quaternion::wedge(const PointCenter& b) const noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = s
    }; }
    constexpr ProjectivePoint Quaternion::meet(const PointCenter& b) const noexcept { return wedge(b); }


    constexpr Motor ProjectiveTranslator::wedge(const Motor& b) const noexcept { return {
        .s = b.s * s,
        .wx = (b.s * wx + b.wx * s),
        .wy = (b.s * wy + b.wy * s),
        .wz = (b.s * wz + b.wz * s),
        .xy = b.xy * s,
        .xz = b.xz * s,
        .yz = b.yz * s,
        .i = (b.i * s + b.xy * wz + b.yz * wx - b.xz * wy)
    }; }
    constexpr Motor ProjectiveTranslator::meet(const Motor& b) const noexcept { return wedge(b); }

    constexpr Multivector ProjectiveTranslator::wedge(const Plane& b) const noexcept { return {
        .s = 0.0,
        .w = b.w * s,
        .x = b.x * s,
        .y = b.y * s,
        .z = b.z * s,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (b.y * wx - b.x * wy),
        .wxz = (b.z * wx - b.x * wz),
        .wyz = (b.z * wy - b.y * wz),
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector ProjectiveTranslator::meet(const Plane& b) const noexcept { return wedge(b); }

    constexpr Motor ProjectiveTranslator::wedge(const Bivector& b) const noexcept { return {
        .s = 0.0,
        .wx = b.wx * s,
        .wy = b.wy * s,
        .wz = b.wz * s,
        .xy = b.xy * s,
        .xz = b.xz * s,
        .yz = b.yz * s,
        .i = (b.xy * wz + b.yz * wx - b.xz * wy)
    }; }
    constexpr Motor ProjectiveTranslator::meet(const Bivector& b) const noexcept { return wedge(b); }

    constexpr ProjectivePoint ProjectiveTranslator::wedge(const ProjectivePoint& b) const noexcept { return {
        .x = b.x * s,
        .y = b.y * s,
        .z = b.z * s,
        .w = b.w * s
    }; }
    constexpr ProjectivePoint ProjectiveTranslator::meet(const ProjectivePoint& b) const noexcept { return wedge(b); }

    constexpr Motor ProjectiveTranslator::wedge(const Quaternion& b) const noexcept { return {
        .s = b.s * s,
        .wx = b.s * wx,
        .wy = b.s * wy,
        .wz = b.s * wz,
        .xy = b.xy * s,
        .xz = b.xz * s,
        .yz = b.yz * s,
        .i = (b.xy * wz + b.yz * wx - b.xz * wy)
    }; }
    constexpr Motor ProjectiveTranslator::meet(const Quaternion& b) const noexcept { return wedge(b); }

    constexpr ProjectiveTranslator ProjectiveTranslator::wedge(const ProjectiveTranslator& b) const noexcept { return {
        .s = b.s * s,
        .wx = (b.s * wx + b.wx * s),
        .wy = (b.s * wy + b.wy * s),
        .wz = (b.s * wz + b.wz * s)
    }; }
    constexpr ProjectiveTranslator ProjectiveTranslator::meet(const ProjectiveTranslator& b) const noexcept { return wedge(b); }

    constexpr ProjectiveTranslator ProjectiveTranslator::wedge(const Translator& b) const noexcept { return {
        .s = s,
        .wx = (wx + b.wx * s),
        .wy = (wy + b.wy * s),
        .wz = (wz + b.wz * s)
    }; }
    constexpr ProjectiveTranslator ProjectiveTranslator::meet(const Translator& b) const noexcept { return wedge(b); }

    constexpr Vector ProjectiveTranslator::wedge(const Vector& b) const noexcept { return {
        .x = b.x * s,
        .y = b.y * s,
        .z = b.z * s
    }; }
    constexpr Vector ProjectiveTranslator::meet(const Vector& b) const noexcept { return wedge(b); }

    constexpr ProjectivePoint ProjectiveTranslator::wedge(const Point& b) const noexcept { return {
        .x = b.x * s,
        .y = b.y * s,
        .z = b.z * s,
        .w = s
    }; }
    constexpr ProjectivePoint ProjectiveTranslator::meet(const Point& b) const noexcept { return wedge(b); }

    constexpr Multivector ProjectiveTranslator::wedge(const PlaneIdeal& b) const noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = b.x * s,
        .y = b.y * s,
        .z = b.z * s,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (b.y * wx - b.x * wy),
        .wxz = (b.z * wx - b.x * wz),
        .wyz = (b.z * wy - b.y * wz),
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector ProjectiveTranslator::meet(const PlaneIdeal& b) const noexcept { return wedge(b); }

    constexpr Motor ProjectiveTranslator::wedge(const BivectorBulk& b) const noexcept { return {
        .s = 0.0,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = b.xy * s,
        .xz = b.xz * s,
        .yz = b.yz * s,
        .i = (b.xy * wz + b.yz * wx - b.xz * wy)
    }; }
    constexpr Motor ProjectiveTranslator::meet(const BivectorBulk& b) const noexcept { return wedge(b); }

    constexpr BivectorWeight ProjectiveTranslator::wedge(const BivectorWeight& b) const noexcept { return {
        .wx = b.wx * s,
        .wy = b.wy * s,
        .wz = b.wz * s
    }; }
    constexpr BivectorWeight ProjectiveTranslator::meet(const BivectorWeight& b) const noexcept { return wedge(b); }

    constexpr PseudoScalar ProjectiveTranslator::wedge(const PseudoScalar& b) const noexcept { return {
        .i = b.i * s
    }; }
    constexpr PseudoScalar ProjectiveTranslator::meet(const PseudoScalar& b) const noexcept { return wedge(b); }

    constexpr ProjectivePoint ProjectiveTranslator::wedge(const PointCenter& b) const noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = s
    }; }
    constexpr ProjectivePoint ProjectiveTranslator::meet(const PointCenter& b) const noexcept { return wedge(b); }


    constexpr Motor Translator::wedge(const Motor& b) const noexcept { return {
        .s = b.s,
        .wx = (b.wx + b.s * wx),
        .wy = (b.wy + b.s * wy),
        .wz = (b.wz + b.s * wz),
        .xy = b.xy,
        .xz = b.xz,
        .yz = b.yz,
        .i = (b.i + b.xy * wz + b.yz * wx - b.xz * wy)
    }; }
    constexpr Motor Translator::meet(const Motor& b) const noexcept { return wedge(b); }

    constexpr Multivector Translator::wedge(const Plane& b) const noexcept { return {
        .s = 0.0,
        .w = b.w,
        .x = b.x,
        .y = b.y,
        .z = b.z,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (b.y * wx - b.x * wy),
        .wxz = (b.z * wx - b.x * wz),
        .wyz = (b.z * wy - b.y * wz),
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector Translator::meet(const Plane& b) const noexcept { return wedge(b); }

    constexpr Motor Translator::wedge(const Bivector& b) const noexcept { return {
        .s = 0.0,
        .wx = b.wx,
        .wy = b.wy,
        .wz = b.wz,
        .xy = b.xy,
        .xz = b.xz,
        .yz = b.yz,
        .i = (b.xy * wz + b.yz * wx - b.xz * wy)
    }; }
    constexpr Motor Translator::meet(const Bivector& b) const noexcept { return wedge(b); }

    constexpr ProjectivePoint Translator::wedge(const ProjectivePoint& b) const noexcept { return {
        .x = b.x,
        .y = b.y,
        .z = b.z,
        .w = b.w
    }; }
    constexpr ProjectivePoint Translator::meet(const ProjectivePoint& b) const noexcept { return wedge(b); }

    constexpr Motor Translator::wedge(const Quaternion& b) const noexcept { return {
        .s = b.s,
        .wx = b.s * wx,
        .wy = b.s * wy,
        .wz = b.s * wz,
        .xy = b.xy,
        .xz = b.xz,
        .yz = b.yz,
        .i = (b.xy * wz + b.yz * wx - b.xz * wy)
    }; }
    constexpr Motor Translator::meet(const Quaternion& b) const noexcept { return wedge(b); }

    constexpr ProjectiveTranslator Translator::wedge(const ProjectiveTranslator& b) const noexcept { return {
        .s = b.s,
        .wx = (b.wx + b.s * wx),
        .wy = (b.wy + b.s * wy),
        .wz = (b.wz + b.s * wz)
    }; }
    constexpr ProjectiveTranslator Translator::meet(const ProjectiveTranslator& b) const noexcept { return wedge(b); }

    constexpr Translator Translator::wedge(const Translator& b) const noexcept { return {
        .wx = (b.wx + wx),
        .wy = (b.wy + wy),
        .wz = (b.wz + wz)
    }; }
    constexpr Translator Translator::meet(const Translator& b) const noexcept { return wedge(b); }

    constexpr Vector Translator::wedge(const Vector& b) const noexcept { return {
        .x = b.x,
        .y = b.y,
        .z = b.z
    }; }
    constexpr Vector Translator::meet(const Vector& b) const noexcept { return wedge(b); }

    constexpr Point Translator::wedge(const Point& b) const noexcept { return {
        .x = b.x,
        .y = b.y,
        .z = b.z
    }; }
    constexpr Point Translator::meet(const Point& b) const noexcept { return wedge(b); }

    constexpr Multivector Translator::wedge(const PlaneIdeal& b) const noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = b.x,
        .y = b.y,
        .z = b.z,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (b.y * wx - b.x * wy),
        .wxz = (b.z * wx - b.x * wz),
        .wyz = (b.z * wy - b.y * wz),
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector Translator::meet(const PlaneIdeal& b) const noexcept { return wedge(b); }

    constexpr Motor Translator::wedge(const BivectorBulk& b) const noexcept { return {
        .s = 0.0,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = b.xy,
        .xz = b.xz,
        .yz = b.yz,
        .i = (b.xy * wz + b.yz * wx - b.xz * wy)
    }; }
    constexpr Motor Translator::meet(const BivectorBulk& b) const noexcept { return wedge(b); }

    constexpr BivectorWeight Translator::wedge(const BivectorWeight& b) const noexcept { return {
        .wx = b.wx,
        .wy = b.wy,
        .wz = b.wz
    }; }
    constexpr BivectorWeight Translator::meet(const BivectorWeight& b) const noexcept { return wedge(b); }

    constexpr PseudoScalar Translator::wedge(const PseudoScalar& b) const noexcept { return {
        .i = b.i
    }; }
    constexpr PseudoScalar Translator::meet(const PseudoScalar& b) const noexcept { return wedge(b); }

    constexpr PointCenter Translator::wedge(const PointCenter& b) const noexcept { return {}; }
    constexpr PointCenter Translator::meet(const PointCenter& b) const noexcept { return wedge(b); }


    constexpr Vector Vector::wedge(const Motor& b) const noexcept { return {
        .x = b.s * x,
        .y = b.s * y,
        .z = b.s * z
    }; }
    constexpr Vector Vector::meet(const Motor& b) const noexcept { return wedge(b); }

    constexpr PseudoScalar Vector::wedge(const Plane& b) const noexcept { return {
        .i = (-b.x * x - b.y * y - b.z * z)
    }; }
    constexpr PseudoScalar Vector::meet(const Plane& b) const noexcept { return wedge(b); }

    constexpr Vector Vector::wedge(const Quaternion& b) const noexcept { return {
        .x = b.s * x,
        .y = b.s * y,
        .z = b.s * z
    }; }
    constexpr Vector Vector::meet(const Quaternion& b) const noexcept { return wedge(b); }

    constexpr Vector Vector::wedge(const ProjectiveTranslator& b) const noexcept { return {
        .x = b.s * x,
        .y = b.s * y,
        .z = b.s * z
    }; }
    constexpr Vector Vector::meet(const ProjectiveTranslator& b) const noexcept { return wedge(b); }

    constexpr Vector Vector::wedge(const Translator& b) const noexcept { return {
        .x = x,
        .y = y,
        .z = z
    }; }
    constexpr Vector Vector::meet(const Translator& b) const noexcept { return wedge(b); }

    constexpr PseudoScalar Vector::wedge(const PlaneIdeal& b) const noexcept { return {
        .i = (-b.x * x - b.y * y - b.z * z)
    }; }
    constexpr PseudoScalar Vector::meet(const PlaneIdeal& b) const noexcept { return wedge(b); }


    constexpr ProjectivePoint Point::wedge(const Motor& b) const noexcept { return {
        .x = b.s * x,
        .y = b.s * y,
        .z = b.s * z,
        .w = b.s
    }; }
    constexpr ProjectivePoint Point::meet(const Motor& b) const noexcept { return wedge(b); }

    constexpr PseudoScalar Point::wedge(const Plane& b) const noexcept { return {
        .i = (-b.w - b.x * x - b.y * y - b.z * z)
    }; }
    constexpr PseudoScalar Point::meet(const Plane& b) const noexcept { return wedge(b); }

    constexpr ProjectivePoint Point::wedge(const Quaternion& b) const noexcept { return {
        .x = b.s * x,
        .y = b.s * y,
        .z = b.s * z,
        .w = b.s
    }; }
    constexpr ProjectivePoint Point::meet(const Quaternion& b) const noexcept { return wedge(b); }

    constexpr ProjectivePoint Point::wedge(const ProjectiveTranslator& b) const noexcept { return {
        .x = b.s * x,
        .y = b.s * y,
        .z = b.s * z,
        .w = b.s
    }; }
    constexpr ProjectivePoint Point::meet(const ProjectiveTranslator& b) const noexcept { return wedge(b); }

    constexpr Point Point::wedge(const Translator& b) const noexcept { return {
        .x = x,
        .y = y,
        .z = z
    }; }
    constexpr Point Point::meet(const Translator& b) const noexcept { return wedge(b); }

    constexpr PseudoScalar Point::wedge(const PlaneIdeal& b) const noexcept { return {
        .i = (-b.x * x - b.y * y - b.z * z)
    }; }
    constexpr PseudoScalar Point::meet(const PlaneIdeal& b) const noexcept { return wedge(b); }


    constexpr Multivector PlaneIdeal::wedge(const Motor& b) const noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = b.s * x,
        .y = b.s * y,
        .z = b.s * z,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (b.wx * y - b.wy * x),
        .wxz = (b.wx * z - b.wz * x),
        .wyz = (b.wy * z - b.wz * y),
        .xyz = (b.xy * z + b.yz * x - b.xz * y),
        .i = 0.0
    }; }
    constexpr Multivector PlaneIdeal::meet(const Motor& b) const noexcept { return wedge(b); }

    constexpr Bivector PlaneIdeal::wedge(const Plane& b) const noexcept { return {
        .wx = -b.w * x,
        .wy = -b.w * y,
        .wz = -b.w * z,
        .xy = (b.y * x - b.x * y),
        .xz = (b.z * x - b.x * z),
        .yz = (b.z * y - b.y * z)
    }; }
    constexpr Bivector PlaneIdeal::meet(const Plane& b) const noexcept { return wedge(b); }

    constexpr ProjectivePoint PlaneIdeal::wedge(const Bivector& b) const noexcept { return {
        .x = (b.wz * y - b.wy * z),
        .y = (b.wx * z - b.wz * x),
        .z = (b.wy * x - b.wx * y),
        .w = (b.xy * z + b.yz * x - b.xz * y)
    }; }
    constexpr ProjectivePoint PlaneIdeal::meet(const Bivector& b) const noexcept { return wedge(b); }

    constexpr PseudoScalar PlaneIdeal::wedge(const ProjectivePoint& b) const noexcept { return {
        .i = (b.x * x + b.y * y + b.z * z)
    }; }
    constexpr PseudoScalar PlaneIdeal::meet(const ProjectivePoint& b) const noexcept { return wedge(b); }

    constexpr Multivector PlaneIdeal::wedge(const Quaternion& b) const noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = b.s * x,
        .y = b.s * y,
        .z = b.s * z,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = 0.0,
        .wxz = 0.0,
        .wyz = 0.0,
        .xyz = (b.xy * z + b.yz * x - b.xz * y),
        .i = 0.0
    }; }
    constexpr Multivector PlaneIdeal::meet(const Quaternion& b) const noexcept { return wedge(b); }

    constexpr Multivector PlaneIdeal::wedge(const ProjectiveTranslator& b) const noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = b.s * x,
        .y = b.s * y,
        .z = b.s * z,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (b.wx * y - b.wy * x),
        .wxz = (b.wx * z - b.wz * x),
        .wyz = (b.wy * z - b.wz * y),
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector PlaneIdeal::meet(const ProjectiveTranslator& b) const noexcept { return wedge(b); }

    constexpr Multivector PlaneIdeal::wedge(const Translator& b) const noexcept { return {
        .s = 0.0,
        .w = 0.0,
        .x = x,
        .y = y,
        .z = z,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .wxy = (b.wx * y - b.wy * x),
        .wxz = (b.wx * z - b.wz * x),
        .wyz = (b.wy * z - b.wz * y),
        .xyz = 0.0,
        .i = 0.0
    }; }
    constexpr Multivector PlaneIdeal::meet(const Translator& b) const noexcept { return wedge(b); }

    constexpr PseudoScalar PlaneIdeal::wedge(const Vector& b) const noexcept { return {
        .i = (b.x * x + b.y * y + b.z * z)
    }; }
    constexpr PseudoScalar PlaneIdeal::meet(const Vector& b) const noexcept { return wedge(b); }

    constexpr PseudoScalar PlaneIdeal::wedge(const Point& b) const noexcept { return {
        .i = (b.x * x + b.y * y + b.z * z)
    }; }
    constexpr PseudoScalar PlaneIdeal::meet(const Point& b) const noexcept { return wedge(b); }

    constexpr BivectorBulk PlaneIdeal::wedge(const PlaneIdeal& b) const noexcept { return {
        .xy = (b.y * x - b.x * y),
        .xz = (b.z * x - b.x * z),
        .yz = (b.z * y - b.y * z)
    }; }
    constexpr BivectorBulk PlaneIdeal::meet(const PlaneIdeal& b) const noexcept { return wedge(b); }

    constexpr ProjectivePoint PlaneIdeal::wedge(const BivectorBulk& b) const noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = (b.xy * z + b.yz * x - b.xz * y)
    }; }
    constexpr ProjectivePoint PlaneIdeal::meet(const BivectorBulk& b) const noexcept { return wedge(b); }

    constexpr Vector PlaneIdeal::wedge(const BivectorWeight& b) const noexcept { return {
        .x = (b.wz * y - b.wy * z),
        .y = (b.wx * z - b.wz * x),
        .z = (b.wy * x - b.wx * y)
    }; }
    constexpr Vector PlaneIdeal::meet(const BivectorWeight& b) const noexcept { return wedge(b); }


    constexpr Motor BivectorBulk::wedge(const Motor& b) const noexcept { return {
        .s = 0.0,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = b.s * xy,
        .xz = b.s * xz,
        .yz = b.s * yz,
        .i = (b.wx * yz + b.wz * xy - b.wy * xz)
    }; }
    constexpr Motor BivectorBulk::meet(const Motor& b) const noexcept { return wedge(b); }

    constexpr ProjectivePoint BivectorBulk::wedge(const Plane& b) const noexcept { return {
        .x = -b.w * yz,
        .y = b.w * xz,
        .z = -b.w * xy,
        .w = (b.x * yz + b.z * xy - b.y * xz)
    }; }
    constexpr ProjectivePoint BivectorBulk::meet(const Plane& b) const noexcept { return wedge(b); }

    constexpr PseudoScalar BivectorBulk::wedge(const Bivector& b) const noexcept { return {
        .i = (b.wx * yz + b.wz * xy - b.wy * xz)
    }; }
    constexpr PseudoScalar BivectorBulk::meet(const Bivector& b) const noexcept { return wedge(b); }

    constexpr BivectorBulk BivectorBulk::wedge(const Quaternion& b) const noexcept { return {
        .xy = b.s * xy,
        .xz = b.s * xz,
        .yz = b.s * yz
    }; }
    constexpr BivectorBulk BivectorBulk::meet(const Quaternion& b) const noexcept { return wedge(b); }

    constexpr Motor BivectorBulk::wedge(const ProjectiveTranslator& b) const noexcept { return {
        .s = 0.0,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = b.s * xy,
        .xz = b.s * xz,
        .yz = b.s * yz,
        .i = (b.wx * yz + b.wz * xy - b.wy * xz)
    }; }
    constexpr Motor BivectorBulk::meet(const ProjectiveTranslator& b) const noexcept { return wedge(b); }

    constexpr Motor BivectorBulk::wedge(const Translator& b) const noexcept { return {
        .s = 0.0,
        .wx = 0.0,
        .wy = 0.0,
        .wz = 0.0,
        .xy = xy,
        .xz = xz,
        .yz = yz,
        .i = (b.wx * yz + b.wz * xy - b.wy * xz)
    }; }
    constexpr Motor BivectorBulk::meet(const Translator& b) const noexcept { return wedge(b); }

    constexpr ProjectivePoint BivectorBulk::wedge(const PlaneIdeal& b) const noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = (b.x * yz + b.z * xy - b.y * xz)
    }; }
    constexpr ProjectivePoint BivectorBulk::meet(const PlaneIdeal& b) const noexcept { return wedge(b); }

    constexpr PseudoScalar BivectorBulk::wedge(const BivectorWeight& b) const noexcept { return {
        .i = (b.wx * yz + b.wz * xy - b.wy * xz)
    }; }
    constexpr PseudoScalar BivectorBulk::meet(const BivectorWeight& b) const noexcept { return wedge(b); }


    constexpr Motor BivectorWeight::wedge(const Motor& b) const noexcept { return {
        .s = 0.0,
        .wx = b.s * wx,
        .wy = b.s * wy,
        .wz = b.s * wz,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .i = (b.xy * wz + b.yz * wx - b.xz * wy)
    }; }
    constexpr Motor BivectorWeight::meet(const Motor& b) const noexcept { return wedge(b); }

    constexpr Vector BivectorWeight::wedge(const Plane& b) const noexcept { return {
        .x = (b.y * wz - b.z * wy),
        .y = (b.z * wx - b.x * wz),
        .z = (b.x * wy - b.y * wx)
    }; }
    constexpr Vector BivectorWeight::meet(const Plane& b) const noexcept { return wedge(b); }

    constexpr PseudoScalar BivectorWeight::wedge(const Bivector& b) const noexcept { return {
        .i = (b.xy * wz + b.yz * wx - b.xz * wy)
    }; }
    constexpr PseudoScalar BivectorWeight::meet(const Bivector& b) const noexcept { return wedge(b); }

    constexpr Motor BivectorWeight::wedge(const Quaternion& b) const noexcept { return {
        .s = 0.0,
        .wx = b.s * wx,
        .wy = b.s * wy,
        .wz = b.s * wz,
        .xy = 0.0,
        .xz = 0.0,
        .yz = 0.0,
        .i = (b.xy * wz + b.yz * wx - b.xz * wy)
    }; }
    constexpr Motor BivectorWeight::meet(const Quaternion& b) const noexcept { return wedge(b); }

    constexpr BivectorWeight BivectorWeight::wedge(const ProjectiveTranslator& b) const noexcept { return {
        .wx = b.s * wx,
        .wy = b.s * wy,
        .wz = b.s * wz
    }; }
    constexpr BivectorWeight BivectorWeight::meet(const ProjectiveTranslator& b) const noexcept { return wedge(b); }

    constexpr BivectorWeight BivectorWeight::wedge(const Translator& b) const noexcept { return {
        .wx = wx,
        .wy = wy,
        .wz = wz
    }; }
    constexpr BivectorWeight BivectorWeight::meet(const Translator& b) const noexcept { return wedge(b); }

    constexpr Vector BivectorWeight::wedge(const PlaneIdeal& b) const noexcept { return {
        .x = (b.y * wz - b.z * wy),
        .y = (b.z * wx - b.x * wz),
        .z = (b.x * wy - b.y * wx)
    }; }
    constexpr Vector BivectorWeight::meet(const PlaneIdeal& b) const noexcept { return wedge(b); }

    constexpr PseudoScalar BivectorWeight::wedge(const BivectorBulk& b) const noexcept { return {
        .i = (b.xy * wz + b.yz * wx - b.xz * wy)
    }; }
    constexpr PseudoScalar BivectorWeight::meet(const BivectorBulk& b) const noexcept { return wedge(b); }


    constexpr PseudoScalar PseudoScalar::wedge(const Motor& b) const noexcept { return {
        .i = b.s * i
    }; }
    constexpr PseudoScalar PseudoScalar::meet(const Motor& b) const noexcept { return wedge(b); }

    constexpr PseudoScalar PseudoScalar::wedge(const Quaternion& b) const noexcept { return {
        .i = b.s * i
    }; }
    constexpr PseudoScalar PseudoScalar::meet(const Quaternion& b) const noexcept { return wedge(b); }

    constexpr PseudoScalar PseudoScalar::wedge(const ProjectiveTranslator& b) const noexcept { return {
        .i = b.s * i
    }; }
    constexpr PseudoScalar PseudoScalar::meet(const ProjectiveTranslator& b) const noexcept { return wedge(b); }

    constexpr PseudoScalar PseudoScalar::wedge(const Translator& b) const noexcept { return {
        .i = i
    }; }
    constexpr PseudoScalar PseudoScalar::meet(const Translator& b) const noexcept { return wedge(b); }


    constexpr ProjectivePoint PointCenter::wedge(const Motor& b) const noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = b.s
    }; }
    constexpr ProjectivePoint PointCenter::meet(const Motor& b) const noexcept { return wedge(b); }

    constexpr PseudoScalar PointCenter::wedge(const Plane& b) const noexcept { return {
        .i = -b.w
    }; }
    constexpr PseudoScalar PointCenter::meet(const Plane& b) const noexcept { return wedge(b); }

    constexpr ProjectivePoint PointCenter::wedge(const Quaternion& b) const noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = b.s
    }; }
    constexpr ProjectivePoint PointCenter::meet(const Quaternion& b) const noexcept { return wedge(b); }

    constexpr ProjectivePoint PointCenter::wedge(const ProjectiveTranslator& b) const noexcept { return {
        .x = 0.0,
        .y = 0.0,
        .z = 0.0,
        .w = b.s
    }; }
    constexpr ProjectivePoint PointCenter::meet(const ProjectiveTranslator& b) const noexcept { return wedge(b); }

    constexpr PointCenter PointCenter::wedge(const Translator& b) const noexcept { return {}; }
    constexpr PointCenter PointCenter::meet(const Translator& b) const noexcept { return wedge(b); }


}