// Copyright (c) 2025 Igor Slobodskov
// SPDX-License-Identifier: MIT

#pragma once

#include "types.h"

// generated by com.github.kright.pga3d.codegen.cpp.ops.DotOpGenerator

namespace pga3d {
    constexpr Multivector Multivector::dot(const Multivector& b) const noexcept { return {.s = (b.s * s + b.x * x + b.y * y + b.z * z - b.xy * xy - b.xyz * xyz - b.xz * xz - b.yz * yz), .w = (b.i * xyz + b.s * w + b.w * s + b.x * wx + b.y * wy + b.z * wz - b.wx * x - b.wxy * xy - b.wxz * xz - b.wy * y - b.wyz * yz - b.wz * z - b.xy * wxy - b.xyz * i - b.xz * wxz - b.yz * wyz), .x = (b.s * x + b.x * s + b.y * xy + b.z * xz - b.xy * y - b.xyz * yz - b.xz * z - b.yz * xyz), .y = (b.s * y + b.xy * x + b.xyz * xz + b.xz * xyz + b.y * s + b.z * yz - b.x * xy - b.yz * z), .z = (b.s * z + b.xz * x + b.yz * y + b.z * s - b.x * xz - b.xy * xyz - b.xyz * xy - b.y * yz), .wx = (b.s * wx + b.wx * s + b.wxy * y + b.wxz * z + b.y * wxy + b.z * wxz - b.i * yz - b.yz * i), .wy = (b.i * xz + b.s * wy + b.wy * s + b.wyz * z + b.xz * i + b.z * wyz - b.wxy * x - b.x * wxy), .wz = (b.s * wz + b.wz * s - b.i * xy - b.wxz * x - b.wyz * y - b.x * wxz - b.xy * i - b.y * wyz), .xy = (b.s * xy + b.xy * s + b.xyz * z + b.z * xyz), .xz = (b.s * xz + b.xz * s - b.xyz * y - b.y * xyz), .yz = (b.s * yz + b.x * xyz + b.xyz * x + b.yz * s), .wxy = (b.s * wxy + b.wxy * s + b.z * i - b.i * z), .wxz = (b.i * y + b.s * wxz + b.wxz * s - b.y * i), .wyz = (b.s * wyz + b.wyz * s + b.x * i - b.i * x), .xyz = (b.s * xyz + b.xyz * s), .i = (b.i * s + b.s * i)}; }

    constexpr Motor Motor::dot(const Motor& b) const noexcept { return {.s = (b.s * s - b.xy * xy - b.xz * xz - b.yz * yz), .wx = (b.s * wx + b.wx * s - b.i * yz - b.yz * i), .wy = (b.i * xz + b.s * wy + b.wy * s + b.xz * i), .wz = (b.s * wz + b.wz * s - b.i * xy - b.xy * i), .xy = (b.s * xy + b.xy * s), .xz = (b.s * xz + b.xz * s), .yz = (b.s * yz + b.yz * s), .i = (b.i * s + b.s * i)}; }
    constexpr Multivector Motor::dot(const Plane& b) const noexcept { return {.s = 0.0, .w = (b.w * s + b.x * wx + b.y * wy + b.z * wz), .x = (b.x * s + b.y * xy + b.z * xz), .y = (b.y * s + b.z * yz - b.x * xy), .z = (b.z * s - b.x * xz - b.y * yz), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = b.z * i, .wxz = -b.y * i, .wyz = b.x * i, .xyz = 0.0, .i = 0.0}; }
    constexpr Motor Motor::dot(const Bivector& b) const noexcept { return {.s = (-b.xy * xy - b.xz * xz - b.yz * yz), .wx = (b.wx * s - b.yz * i), .wy = (b.wy * s + b.xz * i), .wz = (b.wz * s - b.xy * i), .xy = b.xy * s, .xz = b.xz * s, .yz = b.yz * s, .i = 0.0}; }
    constexpr Multivector Motor::dot(const ProjectivePoint& b) const noexcept { return {.s = 0.0, .w = (b.x * yz + b.z * xy - b.w * i - b.y * xz), .x = -b.w * yz, .y = b.w * xz, .z = -b.w * xy, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = -b.z * s, .wxz = b.y * s, .wyz = -b.x * s, .xyz = b.w * s, .i = 0.0}; }
    constexpr Motor Motor::dot(const Quaternion& b) const noexcept { return {.s = (b.s * s - b.xy * xy - b.xz * xz - b.yz * yz), .wx = (b.s * wx - b.yz * i), .wy = (b.s * wy + b.xz * i), .wz = (b.s * wz - b.xy * i), .xy = (b.s * xy + b.xy * s), .xz = (b.s * xz + b.xz * s), .yz = (b.s * yz + b.yz * s), .i = b.s * i}; }
    constexpr Motor Motor::dot(const ProjectiveTranslator& b) const noexcept { return {.s = b.s * s, .wx = (b.s * wx + b.wx * s), .wy = (b.s * wy + b.wy * s), .wz = (b.s * wz + b.wz * s), .xy = b.s * xy, .xz = b.s * xz, .yz = b.s * yz, .i = b.s * i}; }
    constexpr Motor Motor::dot(const Translator& b) const noexcept { return {.s = s, .wx = (wx + b.wx * s), .wy = (wy + b.wy * s), .wz = (wz + b.wz * s), .xy = xy, .xz = xz, .yz = yz, .i = i}; }
    constexpr Multivector Motor::dot(const Vector& b) const noexcept { return {.s = 0.0, .w = (b.x * yz + b.z * xy - b.y * xz), .x = 0.0, .y = 0.0, .z = 0.0, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = -b.z * s, .wxz = b.y * s, .wyz = -b.x * s, .xyz = 0.0, .i = 0.0}; }
    constexpr Multivector Motor::dot(const Point& b) const noexcept { return {.s = 0.0, .w = (-i + b.x * yz + b.z * xy - b.y * xz), .x = -yz, .y = xz, .z = -xy, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = -b.z * s, .wxz = b.y * s, .wyz = -b.x * s, .xyz = s, .i = 0.0}; }
    constexpr Multivector Motor::dot(const PlaneIdeal& b) const noexcept { return {.s = 0.0, .w = (b.x * wx + b.y * wy + b.z * wz), .x = (b.x * s + b.y * xy + b.z * xz), .y = (b.y * s + b.z * yz - b.x * xy), .z = (b.z * s - b.x * xz - b.y * yz), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = b.z * i, .wxz = -b.y * i, .wyz = b.x * i, .xyz = 0.0, .i = 0.0}; }
    constexpr Motor Motor::dot(const BivectorBulk& b) const noexcept { return {.s = (-b.xy * xy - b.xz * xz - b.yz * yz), .wx = -b.yz * i, .wy = b.xz * i, .wz = -b.xy * i, .xy = b.xy * s, .xz = b.xz * s, .yz = b.yz * s, .i = 0.0}; }
    constexpr BivectorWeight Motor::dot(const BivectorWeight& b) const noexcept { return {.wx = b.wx * s, .wy = b.wy * s, .wz = b.wz * s}; }
    constexpr Motor Motor::dot(const PseudoScalar& b) const noexcept { return {.s = 0.0, .wx = -b.i * yz, .wy = b.i * xz, .wz = -b.i * xy, .xy = 0.0, .xz = 0.0, .yz = 0.0, .i = b.i * s}; }
    constexpr Multivector Motor::dot(const PointCenter& b) const noexcept { return {.s = 0.0, .w = -i, .x = -yz, .y = xz, .z = -xy, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = 0.0, .wxz = 0.0, .wyz = 0.0, .xyz = s, .i = 0.0}; }

    constexpr Multivector Plane::dot(const Motor& b) const noexcept { return {.s = 0.0, .w = (b.s * w - b.wx * x - b.wy * y - b.wz * z), .x = (b.s * x - b.xy * y - b.xz * z), .y = (b.s * y + b.xy * x - b.yz * z), .z = (b.s * z + b.xz * x + b.yz * y), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = -b.i * z, .wxz = b.i * y, .wyz = -b.i * x, .xyz = 0.0, .i = 0.0}; }
    constexpr double Plane::dot(const Plane& b) const noexcept { return (b.x * x + b.y * y + b.z * z); }
    constexpr Plane Plane::dot(const Bivector& b) const noexcept { return {.x = (-b.xy * y - b.xz * z), .y = (b.xy * x - b.yz * z), .z = (b.xz * x + b.yz * y), .w = (-b.wx * x - b.wy * y - b.wz * z)}; }
    constexpr Bivector Plane::dot(const ProjectivePoint& b) const noexcept { return {.wx = (b.y * z - b.z * y), .wy = (b.z * x - b.x * z), .wz = (b.x * y - b.y * x), .xy = b.w * z, .xz = -b.w * y, .yz = b.w * x}; }
    constexpr Plane Plane::dot(const Quaternion& b) const noexcept { return {.x = (b.s * x - b.xy * y - b.xz * z), .y = (b.s * y + b.xy * x - b.yz * z), .z = (b.s * z + b.xz * x + b.yz * y), .w = b.s * w}; }
    constexpr Plane Plane::dot(const ProjectiveTranslator& b) const noexcept { return {.x = b.s * x, .y = b.s * y, .z = b.s * z, .w = (b.s * w - b.wx * x - b.wy * y - b.wz * z)}; }
    constexpr Plane Plane::dot(const Translator& b) const noexcept { return {.x = x, .y = y, .z = z, .w = (w - b.wx * x - b.wy * y - b.wz * z)}; }
    constexpr BivectorWeight Plane::dot(const Vector& b) const noexcept { return {.wx = (b.y * z - b.z * y), .wy = (b.z * x - b.x * z), .wz = (b.x * y - b.y * x)}; }
    constexpr Bivector Plane::dot(const Point& b) const noexcept { return {.wx = (b.y * z - b.z * y), .wy = (b.z * x - b.x * z), .wz = (b.x * y - b.y * x), .xy = z, .xz = -y, .yz = x}; }
    constexpr double Plane::dot(const PlaneIdeal& b) const noexcept { return (b.x * x + b.y * y + b.z * z); }
    constexpr PlaneIdeal Plane::dot(const BivectorBulk& b) const noexcept { return {.x = (-b.xy * y - b.xz * z), .y = (b.xy * x - b.yz * z), .z = (b.xz * x + b.yz * y)}; }
    constexpr Plane Plane::dot(const BivectorWeight& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = (-b.wx * x - b.wy * y - b.wz * z)}; }
    constexpr Vector Plane::dot(const PseudoScalar& b) const noexcept { return {.x = b.i * x, .y = b.i * y, .z = b.i * z}; }
    constexpr BivectorBulk Plane::dot(const PointCenter& b) const noexcept { return {.xy = z, .xz = -y, .yz = x}; }

    constexpr Motor Bivector::dot(const Motor& b) const noexcept { return {.s = (-b.xy * xy - b.xz * xz - b.yz * yz), .wx = (b.s * wx - b.i * yz), .wy = (b.i * xz + b.s * wy), .wz = (b.s * wz - b.i * xy), .xy = b.s * xy, .xz = b.s * xz, .yz = b.s * yz, .i = 0.0}; }
    constexpr Plane Bivector::dot(const Plane& b) const noexcept { return {.x = (b.y * xy + b.z * xz), .y = (b.z * yz - b.x * xy), .z = (-b.x * xz - b.y * yz), .w = (b.x * wx + b.y * wy + b.z * wz)}; }
    constexpr double Bivector::dot(const Bivector& b) const noexcept { return (-b.xy * xy - b.xz * xz - b.yz * yz); }
    constexpr Plane Bivector::dot(const ProjectivePoint& b) const noexcept { return {.x = -b.w * yz, .y = b.w * xz, .z = -b.w * xy, .w = (b.x * yz + b.z * xy - b.y * xz)}; }
    constexpr Motor Bivector::dot(const Quaternion& b) const noexcept { return {.s = (-b.xy * xy - b.xz * xz - b.yz * yz), .wx = b.s * wx, .wy = b.s * wy, .wz = b.s * wz, .xy = b.s * xy, .xz = b.s * xz, .yz = b.s * yz, .i = 0.0}; }
    constexpr Bivector Bivector::dot(const ProjectiveTranslator& b) const noexcept { return {.wx = b.s * wx, .wy = b.s * wy, .wz = b.s * wz, .xy = b.s * xy, .xz = b.s * xz, .yz = b.s * yz}; }
    constexpr Bivector Bivector::dot(const Translator& b) const noexcept { return {.wx = wx, .wy = wy, .wz = wz, .xy = xy, .xz = xz, .yz = yz}; }
    constexpr Plane Bivector::dot(const Vector& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = (b.x * yz + b.z * xy - b.y * xz)}; }
    constexpr Plane Bivector::dot(const Point& b) const noexcept { return {.x = -yz, .y = xz, .z = -xy, .w = (b.x * yz + b.z * xy - b.y * xz)}; }
    constexpr Plane Bivector::dot(const PlaneIdeal& b) const noexcept { return {.x = (b.y * xy + b.z * xz), .y = (b.z * yz - b.x * xy), .z = (-b.x * xz - b.y * yz), .w = (b.x * wx + b.y * wy + b.z * wz)}; }
    constexpr double Bivector::dot(const BivectorBulk& b) const noexcept { return (-b.xy * xy - b.xz * xz - b.yz * yz); }
    constexpr BivectorWeight Bivector::dot(const PseudoScalar& b) const noexcept { return {.wx = -b.i * yz, .wy = b.i * xz, .wz = -b.i * xy}; }
    constexpr PlaneIdeal Bivector::dot(const PointCenter& b) const noexcept { return {.x = -yz, .y = xz, .z = -xy}; }

    constexpr Multivector ProjectivePoint::dot(const Motor& b) const noexcept { return {.s = 0.0, .w = (b.i * w + b.xy * z + b.yz * x - b.xz * y), .x = -b.yz * w, .y = b.xz * w, .z = -b.xy * w, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = -b.s * z, .wxz = b.s * y, .wyz = -b.s * x, .xyz = b.s * w, .i = 0.0}; }
    constexpr Bivector ProjectivePoint::dot(const Plane& b) const noexcept { return {.wx = (b.z * y - b.y * z), .wy = (b.x * z - b.z * x), .wz = (b.y * x - b.x * y), .xy = b.z * w, .xz = -b.y * w, .yz = b.x * w}; }
    constexpr Plane ProjectivePoint::dot(const Bivector& b) const noexcept { return {.x = -b.yz * w, .y = b.xz * w, .z = -b.xy * w, .w = (b.xy * z + b.yz * x - b.xz * y)}; }
    constexpr double ProjectivePoint::dot(const ProjectivePoint& b) const noexcept { return -b.w * w; }
    constexpr Multivector ProjectivePoint::dot(const Quaternion& b) const noexcept { return {.s = 0.0, .w = (b.xy * z + b.yz * x - b.xz * y), .x = -b.yz * w, .y = b.xz * w, .z = -b.xy * w, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = -b.s * z, .wxz = b.s * y, .wyz = -b.s * x, .xyz = b.s * w, .i = 0.0}; }
    constexpr ProjectivePoint ProjectivePoint::dot(const ProjectiveTranslator& b) const noexcept { return {.x = b.s * x, .y = b.s * y, .z = b.s * z, .w = b.s * w}; }
    constexpr ProjectivePoint ProjectivePoint::dot(const Translator& b) const noexcept { return {.x = x, .y = y, .z = z, .w = w}; }
    constexpr double ProjectivePoint::dot(const Point& b) const noexcept { return -w; }
    constexpr Bivector ProjectivePoint::dot(const PlaneIdeal& b) const noexcept { return {.wx = (b.z * y - b.y * z), .wy = (b.x * z - b.z * x), .wz = (b.y * x - b.x * y), .xy = b.z * w, .xz = -b.y * w, .yz = b.x * w}; }
    constexpr Plane ProjectivePoint::dot(const BivectorBulk& b) const noexcept { return {.x = -b.yz * w, .y = b.xz * w, .z = -b.xy * w, .w = (b.xy * z + b.yz * x - b.xz * y)}; }
    constexpr Plane ProjectivePoint::dot(const PseudoScalar& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = b.i * w}; }
    constexpr double ProjectivePoint::dot(const PointCenter& b) const noexcept { return -w; }

    constexpr Motor Quaternion::dot(const Motor& b) const noexcept { return {.s = (b.s * s - b.xy * xy - b.xz * xz - b.yz * yz), .wx = (b.wx * s - b.i * yz), .wy = (b.i * xz + b.wy * s), .wz = (b.wz * s - b.i * xy), .xy = (b.s * xy + b.xy * s), .xz = (b.s * xz + b.xz * s), .yz = (b.s * yz + b.yz * s), .i = b.i * s}; }
    constexpr Plane Quaternion::dot(const Plane& b) const noexcept { return {.x = (b.x * s + b.y * xy + b.z * xz), .y = (b.y * s + b.z * yz - b.x * xy), .z = (b.z * s - b.x * xz - b.y * yz), .w = b.w * s}; }
    constexpr Motor Quaternion::dot(const Bivector& b) const noexcept { return {.s = (-b.xy * xy - b.xz * xz - b.yz * yz), .wx = b.wx * s, .wy = b.wy * s, .wz = b.wz * s, .xy = b.xy * s, .xz = b.xz * s, .yz = b.yz * s, .i = 0.0}; }
    constexpr Multivector Quaternion::dot(const ProjectivePoint& b) const noexcept { return {.s = 0.0, .w = (b.x * yz + b.z * xy - b.y * xz), .x = -b.w * yz, .y = b.w * xz, .z = -b.w * xy, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = -b.z * s, .wxz = b.y * s, .wyz = -b.x * s, .xyz = b.w * s, .i = 0.0}; }
    constexpr Quaternion Quaternion::dot(const Quaternion& b) const noexcept { return {.s = (b.s * s - b.xy * xy - b.xz * xz - b.yz * yz), .xy = (b.s * xy + b.xy * s), .xz = (b.s * xz + b.xz * s), .yz = (b.s * yz + b.yz * s)}; }
    constexpr Motor Quaternion::dot(const ProjectiveTranslator& b) const noexcept { return {.s = b.s * s, .wx = b.wx * s, .wy = b.wy * s, .wz = b.wz * s, .xy = b.s * xy, .xz = b.s * xz, .yz = b.s * yz, .i = 0.0}; }
    constexpr Motor Quaternion::dot(const Translator& b) const noexcept { return {.s = s, .wx = b.wx * s, .wy = b.wy * s, .wz = b.wz * s, .xy = xy, .xz = xz, .yz = yz, .i = 0.0}; }
    constexpr Multivector Quaternion::dot(const Vector& b) const noexcept { return {.s = 0.0, .w = (b.x * yz + b.z * xy - b.y * xz), .x = 0.0, .y = 0.0, .z = 0.0, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = -b.z * s, .wxz = b.y * s, .wyz = -b.x * s, .xyz = 0.0, .i = 0.0}; }
    constexpr Multivector Quaternion::dot(const Point& b) const noexcept { return {.s = 0.0, .w = (b.x * yz + b.z * xy - b.y * xz), .x = -yz, .y = xz, .z = -xy, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = -b.z * s, .wxz = b.y * s, .wyz = -b.x * s, .xyz = s, .i = 0.0}; }
    constexpr PlaneIdeal Quaternion::dot(const PlaneIdeal& b) const noexcept { return {.x = (b.x * s + b.y * xy + b.z * xz), .y = (b.y * s + b.z * yz - b.x * xy), .z = (b.z * s - b.x * xz - b.y * yz)}; }
    constexpr Quaternion Quaternion::dot(const BivectorBulk& b) const noexcept { return {.s = (-b.xy * xy - b.xz * xz - b.yz * yz), .xy = b.xy * s, .xz = b.xz * s, .yz = b.yz * s}; }
    constexpr BivectorWeight Quaternion::dot(const BivectorWeight& b) const noexcept { return {.wx = b.wx * s, .wy = b.wy * s, .wz = b.wz * s}; }
    constexpr Motor Quaternion::dot(const PseudoScalar& b) const noexcept { return {.s = 0.0, .wx = -b.i * yz, .wy = b.i * xz, .wz = -b.i * xy, .xy = 0.0, .xz = 0.0, .yz = 0.0, .i = b.i * s}; }
    constexpr Multivector Quaternion::dot(const PointCenter& b) const noexcept { return {.s = 0.0, .w = 0.0, .x = -yz, .y = xz, .z = -xy, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = 0.0, .wxz = 0.0, .wyz = 0.0, .xyz = s, .i = 0.0}; }

    constexpr Motor ProjectiveTranslator::dot(const Motor& b) const noexcept { return {.s = b.s * s, .wx = (b.s * wx + b.wx * s), .wy = (b.s * wy + b.wy * s), .wz = (b.s * wz + b.wz * s), .xy = b.xy * s, .xz = b.xz * s, .yz = b.yz * s, .i = b.i * s}; }
    constexpr Plane ProjectiveTranslator::dot(const Plane& b) const noexcept { return {.x = b.x * s, .y = b.y * s, .z = b.z * s, .w = (b.w * s + b.x * wx + b.y * wy + b.z * wz)}; }
    constexpr Bivector ProjectiveTranslator::dot(const Bivector& b) const noexcept { return {.wx = b.wx * s, .wy = b.wy * s, .wz = b.wz * s, .xy = b.xy * s, .xz = b.xz * s, .yz = b.yz * s}; }
    constexpr ProjectivePoint ProjectiveTranslator::dot(const ProjectivePoint& b) const noexcept { return {.x = b.x * s, .y = b.y * s, .z = b.z * s, .w = b.w * s}; }
    constexpr Motor ProjectiveTranslator::dot(const Quaternion& b) const noexcept { return {.s = b.s * s, .wx = b.s * wx, .wy = b.s * wy, .wz = b.s * wz, .xy = b.xy * s, .xz = b.xz * s, .yz = b.yz * s, .i = 0.0}; }
    constexpr ProjectiveTranslator ProjectiveTranslator::dot(const ProjectiveTranslator& b) const noexcept { return {.s = b.s * s, .wx = (b.s * wx + b.wx * s), .wy = (b.s * wy + b.wy * s), .wz = (b.s * wz + b.wz * s)}; }
    constexpr ProjectiveTranslator ProjectiveTranslator::dot(const Translator& b) const noexcept { return {.s = s, .wx = (wx + b.wx * s), .wy = (wy + b.wy * s), .wz = (wz + b.wz * s)}; }
    constexpr Vector ProjectiveTranslator::dot(const Vector& b) const noexcept { return {.x = b.x * s, .y = b.y * s, .z = b.z * s}; }
    constexpr ProjectivePoint ProjectiveTranslator::dot(const Point& b) const noexcept { return {.x = b.x * s, .y = b.y * s, .z = b.z * s, .w = s}; }
    constexpr Plane ProjectiveTranslator::dot(const PlaneIdeal& b) const noexcept { return {.x = b.x * s, .y = b.y * s, .z = b.z * s, .w = (b.x * wx + b.y * wy + b.z * wz)}; }
    constexpr BivectorBulk ProjectiveTranslator::dot(const BivectorBulk& b) const noexcept { return {.xy = b.xy * s, .xz = b.xz * s, .yz = b.yz * s}; }
    constexpr BivectorWeight ProjectiveTranslator::dot(const BivectorWeight& b) const noexcept { return {.wx = b.wx * s, .wy = b.wy * s, .wz = b.wz * s}; }
    constexpr PseudoScalar ProjectiveTranslator::dot(const PseudoScalar& b) const noexcept { return {.i = b.i * s}; }
    constexpr ProjectivePoint ProjectiveTranslator::dot(const PointCenter& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = s}; }

    constexpr Motor Translator::dot(const Motor& b) const noexcept { return {.s = b.s, .wx = (b.wx + b.s * wx), .wy = (b.wy + b.s * wy), .wz = (b.wz + b.s * wz), .xy = b.xy, .xz = b.xz, .yz = b.yz, .i = b.i}; }
    constexpr Plane Translator::dot(const Plane& b) const noexcept { return {.x = b.x, .y = b.y, .z = b.z, .w = (b.w + b.x * wx + b.y * wy + b.z * wz)}; }
    constexpr Bivector Translator::dot(const Bivector& b) const noexcept { return {.wx = b.wx, .wy = b.wy, .wz = b.wz, .xy = b.xy, .xz = b.xz, .yz = b.yz}; }
    constexpr ProjectivePoint Translator::dot(const ProjectivePoint& b) const noexcept { return {.x = b.x, .y = b.y, .z = b.z, .w = b.w}; }
    constexpr Motor Translator::dot(const Quaternion& b) const noexcept { return {.s = b.s, .wx = b.s * wx, .wy = b.s * wy, .wz = b.s * wz, .xy = b.xy, .xz = b.xz, .yz = b.yz, .i = 0.0}; }
    constexpr ProjectiveTranslator Translator::dot(const ProjectiveTranslator& b) const noexcept { return {.s = b.s, .wx = (b.wx + b.s * wx), .wy = (b.wy + b.s * wy), .wz = (b.wz + b.s * wz)}; }
    constexpr Translator Translator::dot(const Translator& b) const noexcept { return {.wx = (b.wx + wx), .wy = (b.wy + wy), .wz = (b.wz + wz)}; }
    constexpr Vector Translator::dot(const Vector& b) const noexcept { return {.x = b.x, .y = b.y, .z = b.z}; }
    constexpr Point Translator::dot(const Point& b) const noexcept { return {.x = b.x, .y = b.y, .z = b.z}; }
    constexpr Plane Translator::dot(const PlaneIdeal& b) const noexcept { return {.x = b.x, .y = b.y, .z = b.z, .w = (b.x * wx + b.y * wy + b.z * wz)}; }
    constexpr BivectorBulk Translator::dot(const BivectorBulk& b) const noexcept { return {.xy = b.xy, .xz = b.xz, .yz = b.yz}; }
    constexpr BivectorWeight Translator::dot(const BivectorWeight& b) const noexcept { return {.wx = b.wx, .wy = b.wy, .wz = b.wz}; }
    constexpr PseudoScalar Translator::dot(const PseudoScalar& b) const noexcept { return {.i = b.i}; }
    constexpr PointCenter Translator::dot(const PointCenter& b) const noexcept { return {}; }

    constexpr Multivector Vector::dot(const Motor& b) const noexcept { return {.s = 0.0, .w = (b.xy * z + b.yz * x - b.xz * y), .x = 0.0, .y = 0.0, .z = 0.0, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = -b.s * z, .wxz = b.s * y, .wyz = -b.s * x, .xyz = 0.0, .i = 0.0}; }
    constexpr BivectorWeight Vector::dot(const Plane& b) const noexcept { return {.wx = (b.z * y - b.y * z), .wy = (b.x * z - b.z * x), .wz = (b.y * x - b.x * y)}; }
    constexpr Plane Vector::dot(const Bivector& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = (b.xy * z + b.yz * x - b.xz * y)}; }
    constexpr Multivector Vector::dot(const Quaternion& b) const noexcept { return {.s = 0.0, .w = (b.xy * z + b.yz * x - b.xz * y), .x = 0.0, .y = 0.0, .z = 0.0, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = -b.s * z, .wxz = b.s * y, .wyz = -b.s * x, .xyz = 0.0, .i = 0.0}; }
    constexpr Vector Vector::dot(const ProjectiveTranslator& b) const noexcept { return {.x = b.s * x, .y = b.s * y, .z = b.s * z}; }
    constexpr Vector Vector::dot(const Translator& b) const noexcept { return {.x = x, .y = y, .z = z}; }
    constexpr BivectorWeight Vector::dot(const PlaneIdeal& b) const noexcept { return {.wx = (b.z * y - b.y * z), .wy = (b.x * z - b.z * x), .wz = (b.y * x - b.x * y)}; }
    constexpr Plane Vector::dot(const BivectorBulk& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = (b.xy * z + b.yz * x - b.xz * y)}; }

    constexpr Multivector Point::dot(const Motor& b) const noexcept { return {.s = 0.0, .w = (b.i + b.xy * z + b.yz * x - b.xz * y), .x = -b.yz, .y = b.xz, .z = -b.xy, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = -b.s * z, .wxz = b.s * y, .wyz = -b.s * x, .xyz = b.s, .i = 0.0}; }
    constexpr Bivector Point::dot(const Plane& b) const noexcept { return {.wx = (b.z * y - b.y * z), .wy = (b.x * z - b.z * x), .wz = (b.y * x - b.x * y), .xy = b.z, .xz = -b.y, .yz = b.x}; }
    constexpr Plane Point::dot(const Bivector& b) const noexcept { return {.x = -b.yz, .y = b.xz, .z = -b.xy, .w = (b.xy * z + b.yz * x - b.xz * y)}; }
    constexpr double Point::dot(const ProjectivePoint& b) const noexcept { return -b.w; }
    constexpr Multivector Point::dot(const Quaternion& b) const noexcept { return {.s = 0.0, .w = (b.xy * z + b.yz * x - b.xz * y), .x = -b.yz, .y = b.xz, .z = -b.xy, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = -b.s * z, .wxz = b.s * y, .wyz = -b.s * x, .xyz = b.s, .i = 0.0}; }
    constexpr ProjectivePoint Point::dot(const ProjectiveTranslator& b) const noexcept { return {.x = b.s * x, .y = b.s * y, .z = b.s * z, .w = b.s}; }
    constexpr Point Point::dot(const Translator& b) const noexcept { return {.x = x, .y = y, .z = z}; }
    constexpr double Point::dot(const Point& b) const noexcept { return -1.0; }
    constexpr Bivector Point::dot(const PlaneIdeal& b) const noexcept { return {.wx = (b.z * y - b.y * z), .wy = (b.x * z - b.z * x), .wz = (b.y * x - b.x * y), .xy = b.z, .xz = -b.y, .yz = b.x}; }
    constexpr Plane Point::dot(const BivectorBulk& b) const noexcept { return {.x = -b.yz, .y = b.xz, .z = -b.xy, .w = (b.xy * z + b.yz * x - b.xz * y)}; }
    constexpr Plane Point::dot(const PseudoScalar& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = b.i}; }
    constexpr double Point::dot(const PointCenter& b) const noexcept { return -1.0; }

    constexpr Multivector PlaneIdeal::dot(const Motor& b) const noexcept { return {.s = 0.0, .w = (-b.wx * x - b.wy * y - b.wz * z), .x = (b.s * x - b.xy * y - b.xz * z), .y = (b.s * y + b.xy * x - b.yz * z), .z = (b.s * z + b.xz * x + b.yz * y), .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = -b.i * z, .wxz = b.i * y, .wyz = -b.i * x, .xyz = 0.0, .i = 0.0}; }
    constexpr double PlaneIdeal::dot(const Plane& b) const noexcept { return (b.x * x + b.y * y + b.z * z); }
    constexpr Plane PlaneIdeal::dot(const Bivector& b) const noexcept { return {.x = (-b.xy * y - b.xz * z), .y = (b.xy * x - b.yz * z), .z = (b.xz * x + b.yz * y), .w = (-b.wx * x - b.wy * y - b.wz * z)}; }
    constexpr Bivector PlaneIdeal::dot(const ProjectivePoint& b) const noexcept { return {.wx = (b.y * z - b.z * y), .wy = (b.z * x - b.x * z), .wz = (b.x * y - b.y * x), .xy = b.w * z, .xz = -b.w * y, .yz = b.w * x}; }
    constexpr PlaneIdeal PlaneIdeal::dot(const Quaternion& b) const noexcept { return {.x = (b.s * x - b.xy * y - b.xz * z), .y = (b.s * y + b.xy * x - b.yz * z), .z = (b.s * z + b.xz * x + b.yz * y)}; }
    constexpr Plane PlaneIdeal::dot(const ProjectiveTranslator& b) const noexcept { return {.x = b.s * x, .y = b.s * y, .z = b.s * z, .w = (-b.wx * x - b.wy * y - b.wz * z)}; }
    constexpr Plane PlaneIdeal::dot(const Translator& b) const noexcept { return {.x = x, .y = y, .z = z, .w = (-b.wx * x - b.wy * y - b.wz * z)}; }
    constexpr BivectorWeight PlaneIdeal::dot(const Vector& b) const noexcept { return {.wx = (b.y * z - b.z * y), .wy = (b.z * x - b.x * z), .wz = (b.x * y - b.y * x)}; }
    constexpr Bivector PlaneIdeal::dot(const Point& b) const noexcept { return {.wx = (b.y * z - b.z * y), .wy = (b.z * x - b.x * z), .wz = (b.x * y - b.y * x), .xy = z, .xz = -y, .yz = x}; }
    constexpr double PlaneIdeal::dot(const PlaneIdeal& b) const noexcept { return (b.x * x + b.y * y + b.z * z); }
    constexpr PlaneIdeal PlaneIdeal::dot(const BivectorBulk& b) const noexcept { return {.x = (-b.xy * y - b.xz * z), .y = (b.xy * x - b.yz * z), .z = (b.xz * x + b.yz * y)}; }
    constexpr Plane PlaneIdeal::dot(const BivectorWeight& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = (-b.wx * x - b.wy * y - b.wz * z)}; }
    constexpr Vector PlaneIdeal::dot(const PseudoScalar& b) const noexcept { return {.x = b.i * x, .y = b.i * y, .z = b.i * z}; }
    constexpr BivectorBulk PlaneIdeal::dot(const PointCenter& b) const noexcept { return {.xy = z, .xz = -y, .yz = x}; }

    constexpr Motor BivectorBulk::dot(const Motor& b) const noexcept { return {.s = (-b.xy * xy - b.xz * xz - b.yz * yz), .wx = -b.i * yz, .wy = b.i * xz, .wz = -b.i * xy, .xy = b.s * xy, .xz = b.s * xz, .yz = b.s * yz, .i = 0.0}; }
    constexpr PlaneIdeal BivectorBulk::dot(const Plane& b) const noexcept { return {.x = (b.y * xy + b.z * xz), .y = (b.z * yz - b.x * xy), .z = (-b.x * xz - b.y * yz)}; }
    constexpr double BivectorBulk::dot(const Bivector& b) const noexcept { return (-b.xy * xy - b.xz * xz - b.yz * yz); }
    constexpr Plane BivectorBulk::dot(const ProjectivePoint& b) const noexcept { return {.x = -b.w * yz, .y = b.w * xz, .z = -b.w * xy, .w = (b.x * yz + b.z * xy - b.y * xz)}; }
    constexpr Quaternion BivectorBulk::dot(const Quaternion& b) const noexcept { return {.s = (-b.xy * xy - b.xz * xz - b.yz * yz), .xy = b.s * xy, .xz = b.s * xz, .yz = b.s * yz}; }
    constexpr BivectorBulk BivectorBulk::dot(const ProjectiveTranslator& b) const noexcept { return {.xy = b.s * xy, .xz = b.s * xz, .yz = b.s * yz}; }
    constexpr BivectorBulk BivectorBulk::dot(const Translator& b) const noexcept { return {.xy = xy, .xz = xz, .yz = yz}; }
    constexpr Plane BivectorBulk::dot(const Vector& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = (b.x * yz + b.z * xy - b.y * xz)}; }
    constexpr Plane BivectorBulk::dot(const Point& b) const noexcept { return {.x = -yz, .y = xz, .z = -xy, .w = (b.x * yz + b.z * xy - b.y * xz)}; }
    constexpr PlaneIdeal BivectorBulk::dot(const PlaneIdeal& b) const noexcept { return {.x = (b.y * xy + b.z * xz), .y = (b.z * yz - b.x * xy), .z = (-b.x * xz - b.y * yz)}; }
    constexpr double BivectorBulk::dot(const BivectorBulk& b) const noexcept { return (-b.xy * xy - b.xz * xz - b.yz * yz); }
    constexpr BivectorWeight BivectorBulk::dot(const PseudoScalar& b) const noexcept { return {.wx = -b.i * yz, .wy = b.i * xz, .wz = -b.i * xy}; }
    constexpr PlaneIdeal BivectorBulk::dot(const PointCenter& b) const noexcept { return {.x = -yz, .y = xz, .z = -xy}; }

    constexpr BivectorWeight BivectorWeight::dot(const Motor& b) const noexcept { return {.wx = b.s * wx, .wy = b.s * wy, .wz = b.s * wz}; }
    constexpr Plane BivectorWeight::dot(const Plane& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = (b.x * wx + b.y * wy + b.z * wz)}; }
    constexpr BivectorWeight BivectorWeight::dot(const Quaternion& b) const noexcept { return {.wx = b.s * wx, .wy = b.s * wy, .wz = b.s * wz}; }
    constexpr BivectorWeight BivectorWeight::dot(const ProjectiveTranslator& b) const noexcept { return {.wx = b.s * wx, .wy = b.s * wy, .wz = b.s * wz}; }
    constexpr BivectorWeight BivectorWeight::dot(const Translator& b) const noexcept { return {.wx = wx, .wy = wy, .wz = wz}; }
    constexpr Plane BivectorWeight::dot(const PlaneIdeal& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = (b.x * wx + b.y * wy + b.z * wz)}; }

    constexpr Motor PseudoScalar::dot(const Motor& b) const noexcept { return {.s = 0.0, .wx = -b.yz * i, .wy = b.xz * i, .wz = -b.xy * i, .xy = 0.0, .xz = 0.0, .yz = 0.0, .i = b.s * i}; }
    constexpr Vector PseudoScalar::dot(const Plane& b) const noexcept { return {.x = -b.x * i, .y = -b.y * i, .z = -b.z * i}; }
    constexpr BivectorWeight PseudoScalar::dot(const Bivector& b) const noexcept { return {.wx = -b.yz * i, .wy = b.xz * i, .wz = -b.xy * i}; }
    constexpr Plane PseudoScalar::dot(const ProjectivePoint& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = -b.w * i}; }
    constexpr Motor PseudoScalar::dot(const Quaternion& b) const noexcept { return {.s = 0.0, .wx = -b.yz * i, .wy = b.xz * i, .wz = -b.xy * i, .xy = 0.0, .xz = 0.0, .yz = 0.0, .i = b.s * i}; }
    constexpr PseudoScalar PseudoScalar::dot(const ProjectiveTranslator& b) const noexcept { return {.i = b.s * i}; }
    constexpr PseudoScalar PseudoScalar::dot(const Translator& b) const noexcept { return {.i = i}; }
    constexpr Plane PseudoScalar::dot(const Point& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = -i}; }
    constexpr Vector PseudoScalar::dot(const PlaneIdeal& b) const noexcept { return {.x = -b.x * i, .y = -b.y * i, .z = -b.z * i}; }
    constexpr BivectorWeight PseudoScalar::dot(const BivectorBulk& b) const noexcept { return {.wx = -b.yz * i, .wy = b.xz * i, .wz = -b.xy * i}; }
    constexpr Plane PseudoScalar::dot(const PointCenter& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = -i}; }

    constexpr Multivector PointCenter::dot(const Motor& b) const noexcept { return {.s = 0.0, .w = b.i, .x = -b.yz, .y = b.xz, .z = -b.xy, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = 0.0, .wxz = 0.0, .wyz = 0.0, .xyz = b.s, .i = 0.0}; }
    constexpr BivectorBulk PointCenter::dot(const Plane& b) const noexcept { return {.xy = b.z, .xz = -b.y, .yz = b.x}; }
    constexpr PlaneIdeal PointCenter::dot(const Bivector& b) const noexcept { return {.x = -b.yz, .y = b.xz, .z = -b.xy}; }
    constexpr double PointCenter::dot(const ProjectivePoint& b) const noexcept { return -b.w; }
    constexpr Multivector PointCenter::dot(const Quaternion& b) const noexcept { return {.s = 0.0, .w = 0.0, .x = -b.yz, .y = b.xz, .z = -b.xy, .wx = 0.0, .wy = 0.0, .wz = 0.0, .xy = 0.0, .xz = 0.0, .yz = 0.0, .wxy = 0.0, .wxz = 0.0, .wyz = 0.0, .xyz = b.s, .i = 0.0}; }
    constexpr ProjectivePoint PointCenter::dot(const ProjectiveTranslator& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = b.s}; }
    constexpr PointCenter PointCenter::dot(const Translator& b) const noexcept { return {}; }
    constexpr double PointCenter::dot(const Point& b) const noexcept { return -1.0; }
    constexpr BivectorBulk PointCenter::dot(const PlaneIdeal& b) const noexcept { return {.xy = b.z, .xz = -b.y, .yz = b.x}; }
    constexpr PlaneIdeal PointCenter::dot(const BivectorBulk& b) const noexcept { return {.x = -b.yz, .y = b.xz, .z = -b.xy}; }
    constexpr Plane PointCenter::dot(const PseudoScalar& b) const noexcept { return {.x = 0.0, .y = 0.0, .z = 0.0, .w = b.i}; }
    constexpr double PointCenter::dot(const PointCenter& b) const noexcept { return -1.0; }

}