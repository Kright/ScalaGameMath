// Copyright (c) 2025 Igor Slobodskov
// SPDX-License-Identifier: MIT

#pragma once

#include "Motor.h"
#include "Quaternion.h"
#include "Translator.h"

// generated by com.github.kright.pga3d.codegen.cpp.ops.TranslatorWithQuaternionGenerator

namespace pga3d {

    struct TranslatorWithQuaternion {
        Translator translator{};
        Quaternion quaternion{};

        static size_t constexpr componentsCount = Quaternion::componentsCount + Translator::componentsCount;

        [[nodiscard]] constexpr std::array<double, componentsCount> toArray() const noexcept {
            // a compiler will optimize this
            return { translator.toArray()[0], translator.toArray()[1], translator.toArray()[2], quaternion.toArray()[0], quaternion.toArray()[1], quaternion.toArray()[2], quaternion.toArray()[3] };
        }

        [[nodiscard]] static constexpr TranslatorWithQuaternion from(const std::span<double, componentsCount>& values) noexcept {
            return {
                .translator = Translator::from(values.first<Translator::componentsCount>()),
                .quaternion = Quaternion::from(values.last<Quaternion::componentsCount>())
            };
        }

        [[nodiscard]] constexpr Motor toMotor() const noexcept { return translator.geometric(quaternion); }

        [[nodiscard]] constexpr QuaternionWithTranslator reversed() const noexcept;

        [[nodiscard]] constexpr QuaternionWithTranslator toQuaternionWithTranslator() const noexcept;

        [[nodiscard]] static constexpr TranslatorWithQuaternion id() noexcept { return { .translator = Translator::id(), .quaternion = Quaternion::id() }; }
    };

    struct QuaternionWithTranslator {
        Quaternion quaternion{};
        Translator translator{};

        static size_t constexpr componentsCount = Quaternion::componentsCount + Translator::componentsCount;

        [[nodiscard]] constexpr std::array<double, componentsCount> toArray() const noexcept {
            // a compiler will optimize this
            return { quaternion.toArray()[0], quaternion.toArray()[1], quaternion.toArray()[2], quaternion.toArray()[3], translator.toArray()[0], translator.toArray()[1], translator.toArray()[2] };
        }

        [[nodiscard]] static constexpr QuaternionWithTranslator from(const std::span<double, componentsCount>& values) noexcept {
            return {
                .quaternion = Quaternion::from(values.first<Quaternion::componentsCount>()),
                .translator = Translator::from(values.last<Translator::componentsCount>())
            };
        }

        [[nodiscard]] constexpr Motor toMotor() const noexcept { return quaternion.geometric(translator); }

        [[nodiscard]] constexpr TranslatorWithQuaternion reversed() const noexcept;

        [[nodiscard]] constexpr TranslatorWithQuaternion toTranslatorWithQuaternion() const noexcept;

        [[nodiscard]] static constexpr QuaternionWithTranslator id() noexcept { return { .quaternion = Quaternion::id(), .translator = Translator::id() }; }
    };

    [[nodiscard]] constexpr QuaternionWithTranslator TranslatorWithQuaternion::reversed() const noexcept { return { .quaternion = quaternion.reversed(), .translator = translator.reversed() }; }
    [[nodiscard]] constexpr QuaternionWithTranslator TranslatorWithQuaternion::toQuaternionWithTranslator() const noexcept { return { .quaternion = quaternion, .translator = quaternion.reversed().sandwich(translator).toTranslator() }; };
    [[nodiscard]] constexpr TranslatorWithQuaternion QuaternionWithTranslator::reversed() const noexcept { return { .translator = translator.reversed(), .quaternion = quaternion.reversed() }; }
    [[nodiscard]] constexpr TranslatorWithQuaternion QuaternionWithTranslator::toTranslatorWithQuaternion() const noexcept { return { .translator = quaternion.sandwich(translator).toTranslator(), .quaternion = quaternion }; };
}