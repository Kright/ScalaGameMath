#pragma once

#include <cmath>
#include "types.h"
#include "ops_norm.h"
#include "ops_arithmetic.h"
#include "ops_geometric.h"

// generated by com.github.kright.pga3d.codegen.cpp.binops.QuaternionOpsGenerator

namespace pga3d {
    [[nodiscard]] inline Quaternion Quaternion::rotation(const Vector& from, const Vector& to) noexcept {
        return rotation(from.dual(), to.dual());
    }

    [[nodiscard]] inline Quaternion Quaternion::rotation(const PlaneIdeal& from, const PlaneIdeal& to) noexcept {
        const double norm = std::sqrt(from.normSquare() * to.normSquare());
        const Quaternion q2a = to.geometric(from) / norm;
        const double dot = q2a.s;

        if (dot > -1.0 + 1e-6) {
            const double newCos = std::sqrt((1.0 + dot) / 2);
            const double newSinDivSin2 = 0.5 / newCos;
            return Quaternion(newCos, q2a.xy * newSinDivSin2, q2a.xz * newSinDivSin2, q2a.yz * newSinDivSin2);
        }

        const double sin2a = std::sqrt(q2a.xy * q2a.xy + q2a.xz * q2a.xz + q2a.yz * q2a.yz);

        if (sin2a > 1e-8) {
            const double angle2 = std::atan2(sin2a, q2a.s);
            const double propAngle = angle2 * 0.5;
            const double mult = std::sin(propAngle) / sin2a;
            return Quaternion(std::cos(propAngle), q2a.xy * mult, q2a.xz * mult, q2a.yz * mult).normalizedByNorm();
        }

        // choose any axis
        const PlaneIdeal orthogonalPlane =
            (std::abs(from.x) > std::abs(from.z)) ? PlaneIdeal{-from.y, from.x, 0} : PlaneIdeal{0, -from.z, from.y};

        return Quaternion(0, orthogonalPlane.z, -orthogonalPlane.y, orthogonalPlane.x).normalizedByNorm();
    }

    [[nodiscard]] inline BivectorBulk Quaternion::log() const noexcept {
        const double scalar = s;
        if (s < 0.0) return (-(*this)).log();

        const double lenXYZ = std::sqrt(xy * xy + xz * xz + yz * yz);
        const double angle = std::atan2(lenXYZ, scalar);

         // 1 / sin^2
        const double a = 1.0 / (1.0 - scalar * scalar);

        // angle / sin(angle)
        const double b = (std::abs(angle) > 1e-5) ? angle * std::sqrt(a) : (1.0 + angle * angle / 6.0);

        return BivectorBulk {
            .xy = b * xy,
            .xz = b * xz,
            .yz = b * yz,
        };
    }

    [[nodiscard]] inline Quaternion Quaternion::projectToRotationInPlane(const PlaneIdeal& plane) const noexcept {
        const Quaternion q = normalizedByNorm();
        const Quaternion qPart = Quaternion::rotation(q.sandwich(plane), plane);
        return qPart.geometric(q);
    }

    [[nodiscard]] inline double Quaternion::restoreRotationInPlane(const PlaneIdeal& plane) const noexcept {
        const Quaternion q0 = projectToRotationInPlane(plane);
        const BivectorWeight logDual = q0.log().dual();
        const double currentAngle = 2.0 * (logDual.wx * plane.x + logDual.wy * plane.y + logDual.wz * plane.z) / plane.norm();
        return currentAngle;
    }

    [[nodiscard]] constexpr Vector Quaternion::axisX() const noexcept { return {.x = (s * s + yz * yz - xy * xy - xz * xz), .y = 2.0 * (-s * xy - xz * yz), .z = (-2.0 * s * xz + 2.0 * xy * yz)}; }
    [[nodiscard]] constexpr Vector Quaternion::axisY() const noexcept { return {.x = (-2.0 * xz * yz + 2.0 * s * xy), .y = (s * s + xz * xz - xy * xy - yz * yz), .z = (-2.0 * s * yz - 2.0 * xy * xz)}; }
    [[nodiscard]] constexpr Vector Quaternion::axisZ() const noexcept { return {.x = (2.0 * s * xz + 2.0 * xy * yz), .y = 2.0 * (s * yz - xy * xz), .z = (s * s + xy * xy - xz * xz - yz * yz)}; }
}