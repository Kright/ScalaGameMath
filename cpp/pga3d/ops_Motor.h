#pragma once

#include <cmath>
#include "types.h"
#include "ops_arithmetic.h"

// generated by com.github.kright.pga3d.codegen.cpp.binops.MotorOpsGenerator

namespace pga3d {

    [[nodiscard]] inline Bivector Motor::log() const noexcept {
        const double scalar = s;
        if (s < 0.0) return (-(*this)).log();

        const double lenXYZ = std::sqrt(xy * xy + xz * xz + yz * yz);
        const double angle = std::atan2(lenXYZ, scalar);

        // 1 / sin^2
        const double a = 1.0 / (1.0 - scalar * scalar);

        // angle / sin(angle)
        const double b = (std::abs(angle) > 1e-5)
            ? (angle * std::sqrt(a))
            : (1.0 + angle * angle / 6.0);

        const double c = (std::abs(angle) > 1e-5)
            ? (a * i * (1.0 - scalar * b))
            : ((1.0 + angle * angle / 2.0) * i / 3.0);

        return Bivector {
            .wx = (b * wx + c * yz),
            .wy = (b * wy - c * xz),
            .wz = (b * wz + c * xy),
            .xy = b * xy,
            .xz = b * xz,
            .yz = b * yz,
        };
    }

    [[nodiscard]] constexpr std::pair<Quaternion, Translator> Motor::toQuaternionAndTranslator() const noexcept {
        const Quaternion q = toQuaternionUnsafe();
        const Motor t = q.reverse().geometric(*this);
        return { q, t.toTranslatorUnsafe() };
    }

    [[nodiscard]] constexpr std::pair<Translator, Quaternion> Motor::toTranslatorAndQuaternion() const noexcept {
        const Quaternion q = toQuaternionUnsafe();
        const Motor t = geometric(q.reverse());
        return { t.toTranslatorUnsafe(), q };
    }

    [[nodiscard]] constexpr Vector Motor::axisX() const noexcept { return toQuaternionUnsafe().axisX(); }
    [[nodiscard]] constexpr Vector Motor::axisY() const noexcept { return toQuaternionUnsafe().axisY(); }
    [[nodiscard]] constexpr Vector Motor::axisZ() const noexcept { return toQuaternionUnsafe().axisZ(); }
}